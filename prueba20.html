<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Dungeon Protocol: Visual Design Overhaul</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #020205;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #game-container {
            position: relative;
            box-shadow: 0 0 80px rgba(0, 200, 255, 0.1);
            border: 2px solid #1a1a2e;
            background: #000;
            width: 1280px;
            height: 720px;
            overflow: hidden;
        }
        canvas {
            display: block;
            background-color: #050510;
            width: 100%;
            height: 100%;
        }
        /* Efectos de Post-Procesado vía CSS (Scanlines + Vignette) */
        #fx-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: 
                radial-gradient(circle, rgba(0,0,0,0) 50%, rgba(0,0,0,0.8) 100%),
                linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%);
            background-size: 100% 100%, 100% 4px;
            pointer-events: none;
            z-index: 100;
            mix-blend-mode: overlay;
        }
        #ui-layer {
            position: absolute; top: 20px; left: 20px; 
            color: #00ffea; 
            text-shadow: 0 0 10px #00ffea;
            font-size: 14px;
            z-index: 101;
            font-weight: bold;
            letter-spacing: 1px;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="mainCanvas"></canvas>
    <div id="fx-overlay"></div>
    <div id="ui-layer">
        <div>BIOME: ANCIENT SEWERS</div>
        <div style="font-size: 10px; opacity: 0.7;">RENDER: HIGH QUALITY + PARTICLES</div>
    </div>
</div>

<script>
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    const GAME_WIDTH = 1280; 
    const GAME_HEIGHT = 720;
    canvas.width = GAME_WIDTH; 
    canvas.height = GAME_HEIGHT;

    // --- PALETA DE COLORES "DEAD CELLS" INSPIRED ---
    const PALETTE = {
        bgStart: '#05070a', // Fondo muy oscuro
        bgEnd: '#1a1c29',   // Azul noche
        mist: 'rgba(20, 30, 50, 0.6)', // Niebla azulada
        bricks: ['#25283d', '#1e2130', '#181a26'], // Tonos piedras mazmorra
        moss: '#2d4d3d',
        
        // Luces / Acentos
        playerFire: '#ffaa00',
        playerGlow: 'rgba(255, 100, 0, 0.4)',
        playerCloth: '#333344',
        
        enemyBody: '#4a2525', // Rojo oscuro desaturado
        enemyHighlight: '#ff4d4d', // Rojo brillante
        
        chains: '#111',
        torch: 'rgba(255, 180, 50, 0.1)'
    };

    // --- SISTEMA DE PARTÍCULAS ---
    class ParticleSystem {
        constructor() {
            this.particles = [];
        }

        // Tipos: 'dust', 'spark', 'flame', 'spirit'
        emit(x, y, type, color, count = 1) {
            for(let i=0; i<count; i++) {
                this.particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * (type === 'spark' ? 6 : 2),
                    vy: (Math.random() - 0.5) * (type === 'spark' ? 6 : 2),
                    life: 1.0,
                    decay: 0.01 + Math.random() * 0.03,
                    type: type,
                    color: color,
                    size: Math.random() * 3
                });
            }
        }

        update() {
            for (let i = this.particles.length - 1; i >= 0; i--) {
                let p = this.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= p.decay;

                // Físicas simples
                if (p.type === 'spark') p.vy += 0.2; // Gravedad
                if (p.type === 'flame') p.vy -= 0.05; // Flotar
                if (p.type === 'dust') { p.vx *= 0.99; p.vy *= 0.99; } // Fricción

                if (p.life <= 0) this.particles.splice(i, 1);
            }
        }

        draw(ctx, camX, camY) {
            ctx.save();
            // Renderizamos partículas relativas a la cámara, excepto si son UI (no implementado aquí)
            // Asumimos que las particulas están en el mundo
            // Ajustamos posición por parallax si quisiéramos, pero por ahora en plano de juego
            
            this.particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                
                if (p.type === 'spark' || p.type === 'flame') {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = p.color;
                } else {
                    ctx.shadowBlur = 0;
                }

                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                ctx.fill();
            });
            ctx.restore();
        }
    }

    const particles = new ParticleSystem();

    // --- FUNCIONES GRÁFICAS AUXILIARES ---
    
    function drawGlow(ctx, x, y, radius, color) {
        let g = ctx.createRadialGradient(x, y, 0, x, y, radius);
        g.addColorStop(0, color);
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI*2); ctx.fill();
    }

    // Dibuja una textura de ladrillos procedimental
    function drawBrickPlatform(ctx, x, y, w, h) {
        // Base oscura
        ctx.fillStyle = '#111';
        ctx.fillRect(x, y, w, h);

        // Gradient top
        let g = ctx.createLinearGradient(x, y, x, y + h);
        g.addColorStop(0, PALETTE.bricks[0]);
        g.addColorStop(1, '#050505');
        ctx.fillStyle = g;
        ctx.fillRect(x, y, w, h);

        // Ladrillos
        ctx.fillStyle = PALETTE.bricks[1];
        let brickW = 30;
        let brickH = 15;
        for(let by = y; by < y + h; by += brickH) {
            let offset = ((by - y) / brickH) % 2 === 0 ? 0 : 15;
            for(let bx = x - 10; bx < x + w; bx += brickW) {
                // Aleatoriedad para que se vea roto/antiguo
                if (Math.random() > 0.8) continue; // Ladrillo faltante
                let noise = Math.random() * 5;
                ctx.fillRect(bx + offset, by + 2, brickW - 2, brickH - 4);
                
                // Highlight borde superior
                ctx.fillStyle = 'rgba(255,255,255,0.05)';
                ctx.fillRect(bx + offset, by + 2, brickW - 2, 2);
                ctx.fillStyle = PALETTE.bricks[1];
            }
        }

        // Musgo colgando
        ctx.fillStyle = PALETTE.moss;
        for(let i = x; i < x + w; i+= 15) {
            if (Math.random() > 0.6) {
                let len = Math.random() * 20 + 5;
                ctx.beginPath();
                ctx.moveTo(i, y + h);
                ctx.lineTo(i + 3, y + h + len);
                ctx.lineTo(i - 3, y + h + len + 5);
                ctx.lineTo(i, y + h);
                ctx.fill();
            }
        }
        
        // Borde superior brillante (Rim light)
        ctx.fillStyle = '#4a5e6d';
        ctx.fillRect(x, y, w, 4);
    }

    // --- VARIABLES DE SIMULACIÓN ---
    let gameTime = 0;
    let camera = { x: 0, y: 0 };

    // --- CLASES ---

    class Player {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 24; this.height = 40; // TAMAÑO ORIGINAL MANTENIDO
            this.vx = 0; 
            this.animTimer = 0;
            this.facingRight = true;
            this.state = 'wait';
            this.stateTimer = 0;
            
            // Efecto de bufanda (físicas simples)
            this.scarf = [];
            for(let i=0; i<5; i++) this.scarf.push({x:x, y:y});
        }

        update() {
            this.animTimer++;
            this.stateTimer++;

            // IA Simple Original
            if (this.state === 'wait') {
                this.vx = 0;
                if (this.stateTimer > 60) { 
                    this.state = Math.random() > 0.5 ? 'walk_right' : 'walk_left';
                    this.stateTimer = 0;
                }
            } else if (this.state === 'walk_right') {
                this.vx = 3;
                this.facingRight = true;
                this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
            } else if (this.state === 'walk_left') {
                this.vx = -3;
                this.facingRight = false;
                this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
            }
            
            // Limites
            if(this.x < 100) { this.x = 100; this.state = 'walk_right'; }
            if(this.x > 600) { this.x = 600; this.state = 'walk_left'; }

            // Actualizar Bufanda (Sigue a la cabeza con retraso)
            let targetX = this.x + 12;
            let targetY = this.y + 5;
            this.scarf[0].x = targetX;
            this.scarf[0].y = targetY;
            
            for(let i = 1; i < this.scarf.length; i++) {
                let prev = this.scarf[i-1];
                let curr = this.scarf[i];
                // Lerp simple
                curr.x += (prev.x - curr.x - (this.facingRight? 5 : -5)) * 0.3;
                curr.y += (prev.y - curr.y + 2) * 0.3;
            }

            // Emitir partículas al correr
            if (Math.abs(this.vx) > 0 && Math.random() > 0.7) {
                particles.emit(this.x + 12, this.y + 40, 'dust', '#556', 1);
            }
        }

        draw(ctx) {
            // Glow del "héroe"
            drawGlow(ctx, this.x + 12, this.y + 20, 60, 'rgba(255, 150, 0, 0.05)');

            // Bufanda (Dibujar primero para que esté detrás)
            ctx.beginPath();
            ctx.strokeStyle = '#ff4444';
            ctx.lineWidth = 4;
            ctx.moveTo(this.scarf[0].x, this.scarf[0].y);
            for(let i=1; i<this.scarf.length; i++) {
                ctx.lineTo(this.scarf[i].x, this.scarf[i].y);
            }
            ctx.stroke();

            // Cuerpo (Silueta estilizada)
            ctx.fillStyle = PALETTE.playerCloth;
            // Animación "Squash & Stretch" sutil al caminar
            let bounce = Math.abs(Math.sin(this.animTimer * 0.4)) * 2;
            
            // Pantalones
            ctx.fillRect(this.x + 4, this.y + 25, 6, 15 - bounce); // Pierna 1
            ctx.fillRect(this.x + 14, this.y + 25, 6, 15 + bounce); // Pierna 2
            
            // Torso (Túnica)
            ctx.beginPath();
            ctx.moveTo(this.x, this.y + 10);
            ctx.lineTo(this.x + 24, this.y + 10);
            ctx.lineTo(this.x + 20, this.y + 28); // Cintura estrecha
            ctx.lineTo(this.x + 4, this.y + 28);
            ctx.fill();

            // Detalles del traje (Cinturón)
            ctx.fillStyle = '#664422';
            ctx.fillRect(this.x + 4, this.y + 24, 16, 4);

            // CABEZA FLAMEANTE (Estilo Dead Cells)
            // Orbe central
            let headX = this.x + 12;
            let headY = this.y + 6 + Math.sin(this.animTimer * 0.1); // Flota un poco
            
            drawGlow(ctx, headX, headY, 15, 'rgba(255, 100, 50, 0.4)');
            
            ctx.fillStyle = '#ffaa00';
            ctx.beginPath();
            ctx.arc(headX, headY, 5, 0, Math.PI*2);
            ctx.fill();
            
            // Ojo unico brillante
            ctx.fillStyle = '#fff';
            ctx.fillRect(this.facingRight ? headX + 2 : headX - 4, headY - 1, 3, 3);

            // Llama subiendo
            if (Math.random() > 0.5) {
                particles.emit(headX, headY - 5, 'flame', '#ffaa00', 1);
            }

            // Arma (Espada brillante)
            ctx.save();
            ctx.translate(this.x + 12, this.y + 20);
            if (!this.facingRight) ctx.scale(-1, 1);
            
            ctx.rotate(0.2 + bounce * 0.1); // Sway
            ctx.fillStyle = '#aaddff';
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 10;
            // Hoja
            ctx.beginPath();
            ctx.moveTo(10, -5);
            ctx.lineTo(30, 0);
            ctx.lineTo(10, 5);
            ctx.fill();
            // Mango
            ctx.fillStyle = '#444';
            ctx.shadowBlur = 0;
            ctx.fillRect(5, -2, 6, 4);
            ctx.fillRect(8, -6, 2, 12); // Guardia
            ctx.restore();
        }
    }

    class Walker {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 30; this.height = 30;
            this.vx = 2;
            this.dir = 1;
            this.timer = 0;
            this.state = 'walk';
            this.startX = x;
        }

        update() {
            this.timer++;
            if (this.state === 'walk') {
                this.x += this.vx;
                if (Math.abs(this.x - this.startX) > 150) {
                    this.state = 'wait';
                    this.waitTimer = 60;
                }
            } else if (this.state === 'wait') {
                this.waitTimer--;
                if (this.waitTimer <= 0) {
                    this.dir *= -1;
                    this.vx = this.dir * 2;
                    this.state = 'walk';
                }
            }
            
            // Partículas de "corrupción" cayendo del enemigo
            if (Math.random() > 0.9) particles.emit(this.x + 15, this.y + 15, 'spirit', 'rgba(255, 50, 50, 0.5)', 1);
        }

        draw(ctx) {
            let anim = Math.sin(this.timer * 0.2);
            let drawY = this.y - 10;

            // Aura de peligro
            drawGlow(ctx, this.x + 15, this.y + 15, 30, 'rgba(255, 0, 0, 0.1)');

            // Cuerpo (Zombie/Esqueleto)
            ctx.fillStyle = PALETTE.enemyBody;
            // Torso deforme
            ctx.beginPath();
            ctx.moveTo(this.x + 5, drawY + 10);
            ctx.lineTo(this.x + 25, drawY + 12);
            ctx.lineTo(this.x + 20, drawY + 30);
            ctx.lineTo(this.x + 8, drawY + 28);
            ctx.fill();

            // Cabeza
            ctx.fillStyle = '#ccaaaa'; // Hueso
            ctx.beginPath();
            ctx.arc(this.x + 15, drawY + 5, 8, 0, Math.PI*2);
            ctx.fill();

            // Ojos brillantes
            ctx.fillStyle = '#ff0000';
            ctx.shadowColor = 'red'; ctx.shadowBlur = 5;
            ctx.fillRect(this.x + 16, drawY + 3, 3, 3);
            ctx.shadowBlur = 0;

            // Brazos largos (Estilo zombie)
            ctx.strokeStyle = PALETTE.enemyBody;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(this.x + 10, drawY + 15);
            ctx.quadraticCurveTo(this.x - 5, drawY + 25, this.x + 5 + anim * 5, drawY + 25);
            ctx.stroke();

            // Piernas
            ctx.fillStyle = '#332222';
            ctx.fillRect(this.x + 8, drawY + 28, 6, 12 + anim * 3); 
            ctx.fillRect(this.x + 18, drawY + 28, 6, 12 - anim * 3);
        }
    }

    class Flyer {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 30; this.height = 20;
            this.startX = x;
            this.timer = 0;
        }

        update() {
            this.timer++;
            this.x = this.startX + Math.sin(this.timer * 0.02) * 200;
            this.y += Math.cos(this.timer * 0.05) * 1;
            
            // Rastro
            if(this.timer % 5 === 0) {
                particles.emit(this.x + 15, this.y + 10, 'spirit', '#aa00aa', 1);
            }
        }

        draw(ctx) {
            let flap = Math.sin(this.timer * 0.3) * 10;
            
            // Murciélago mecánico / Dron mágico
            drawGlow(ctx, this.x + 15, this.y + 10, 40, 'rgba(200, 0, 255, 0.15)');

            // Cuerpo Central
            ctx.fillStyle = '#331133';
            ctx.beginPath();
            ctx.arc(this.x + 15, this.y + 10, 8, 0, Math.PI*2);
            ctx.fill();

            // Ojo ciclope
            ctx.fillStyle = '#ff00ff';
            ctx.shadowColor = '#ff00ff'; ctx.shadowBlur = 8;
            ctx.beginPath(); ctx.arc(this.x + 15, this.y + 10, 3, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0;

            // Alas dentadas
            ctx.fillStyle = '#220022';
            ctx.beginPath();
            // Ala Izq
            ctx.moveTo(this.x + 10, this.y + 5);
            ctx.lineTo(this.x - 10, this.y - 10 + flap);
            ctx.lineTo(this.x - 5, this.y + 5 + flap);
            ctx.lineTo(this.x + 10, this.y + 15);
            // Ala Der
            ctx.moveTo(this.x + 20, this.y + 5);
            ctx.lineTo(this.x + 40, this.y - 10 + flap);
            ctx.lineTo(this.x + 35, this.y + 5 + flap);
            ctx.lineTo(this.x + 20, this.y + 15);
            ctx.fill();
        }
    }

    // --- ESCENARIO ---
    const player = new Player(200, 500);
    const walker = new Walker(800, 450);
    const flyer = new Flyer(600, 200);

    const platforms = [
        { x: 0, y: 540, width: 800, height: 200 },
        { x: 750, y: 490, width: 400, height: 200 } // He aumentado la altura visual para dibujar ladrillos
    ];

    // --- FONDO PARALLAX AVANZADO ---
    function drawParallax(ctx, camX, camY) {
        // Cielo (Layer 0)
        let grad = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
        grad.addColorStop(0, PALETTE.bgStart);
        grad.addColorStop(1, PALETTE.bgEnd);
        ctx.fillStyle = grad;
        ctx.fillRect(0,0, GAME_WIDTH, GAME_HEIGHT);

        // Capas
        // Definición de capas: {speed, renderFunction}
        const layers = [
            { speed: 0.1, color: '#0d0d14', type: 'distant_ruins' },
            { speed: 0.25, color: '#11111c', type: 'arches' },
            { speed: 0.5, color: '#161824', type: 'chains' },
            { speed: 0.75, color: '#1a1c29', type: 'near_walls' }
        ];

        layers.forEach((layer, idx) => {
            ctx.save();
            let pX = -camX * layer.speed;
            let pY = -camY * (layer.speed * 0.2);
            
            // Offset inicial para centrar
            ctx.translate(pX % 1000, pY); 
            
            // Dibujamos 3 veces para bucle infinito horizontal
            for(let offset = -1000; offset <= 2000; offset += 1000) {
                ctx.save();
                ctx.translate(offset, 0);
                
                ctx.fillStyle = layer.color;

                if (layer.type === 'distant_ruins') {
                    // Montañas picudas / Castillos rotos
                    ctx.beginPath();
                    ctx.moveTo(0, 720);
                    for(let i=0; i<=1000; i+= 50) {
                        let h = 300 + Math.sin(i * 0.01 + idx) * 100 + Math.random()*20;
                        ctx.lineTo(i, 720 - h);
                    }
                    ctx.lineTo(1000, 720);
                    ctx.fill();
                    
                    // Niebla entre capas
                    let g = ctx.createLinearGradient(0, 400, 0, 720);
                    g.addColorStop(0, 'rgba(0,0,0,0)');
                    g.addColorStop(1, 'rgba(5, 10, 20, 0.8)');
                    ctx.fillStyle = g;
                    ctx.fillRect(0, 300, 1000, 420);
                }
                
                else if (layer.type === 'arches') {
                    // Arcos gigantes góticos
                    for(let i=0; i<1000; i+= 200) {
                        ctx.fillRect(i + 20, 100, 40, 620); // Pilares
                        // Arco
                        ctx.beginPath();
                        ctx.arc(i + 120, 150, 100, Math.PI, 0);
                        ctx.lineWidth = 20;
                        ctx.strokeStyle = layer.color;
                        ctx.stroke();
                    }
                }

                else if (layer.type === 'chains') {
                    // Cadenas colgantes gigantes
                    ctx.fillStyle = '#0a0a0a';
                    for(let i=50; i<1000; i+= 300) {
                        let chainW = 10;
                        let chainLen = 400 + Math.random() * 200;
                        // Eslabones
                        for(let c=0; c<chainLen; c+=15) {
                            if (c%30===0) ctx.strokeRect(i, c-100, 8, 12);
                            else ctx.fillRect(i+2, c-100, 4, 10);
                        }
                        // Jaula al final
                        ctx.fillRect(i - 15, chainLen - 100, 40, 60);
                    }
                }

                else if (layer.type === 'near_walls') {
                    // Muros con ventanas
                    for(let i=0; i<1000; i+= 250) {
                         ctx.fillRect(i, 0, 100, 720); // Columna
                         // Ventana con luz
                         ctx.fillStyle = '#331111';
                         ctx.fillRect(i+30, 300, 40, 80);
                         // Brillo ventana
                         ctx.fillStyle = 'rgba(255, 100, 50, 0.2)';
                         ctx.fillRect(i+35, 305, 30, 70);
                         ctx.fillStyle = layer.color;
                    }
                }

                ctx.restore();
            }
            ctx.restore();
        });
    }

    function drawForeground(ctx, camX) {
        // Capa 6: Muy cerca, desenfocada, negra
        ctx.save();
        let pX = -camX * 1.2; 
        ctx.translate(pX % 1500, 0);
        
        ctx.fillStyle = '#000';
        ctx.filter = 'blur(4px)'; // Desenfoque costoso pero bonito
        
        for(let offset = -1500; offset <= 1500; offset += 1500) {
             ctx.save();
             ctx.translate(offset, 0);
             // Pilares rotos en primer plano
             ctx.fillRect(200, 0, 100, 200); // Techo
             ctx.fillRect(800, 600, 150, 120); // Suelo estorbo
             
             // Cadenas gordas
             ctx.fillRect(500, -50, 20, 500);
             
             ctx.restore();
        }
        ctx.filter = 'none';
        ctx.restore();
    }

    // --- BUCLE PRINCIPAL ---
    function loop() {
        gameTime++;
        
        // Movimiento de cámara suave (Sinusoide para demo)
        camera.x = Math.sin(gameTime * 0.005) * 200 + 200; // Desplazamiento más lento
        
        // Generar partículas ambientales (polvo brillante)
        if (Math.random() > 0.8) {
            particles.emit(
                Math.random() * GAME_WIDTH, 
                Math.random() * GAME_HEIGHT, 
                'dust', 
                'rgba(100, 200, 255, 0.2)', 
                1
            );
        }

        // Updates
        player.update();
        walker.update();
        flyer.update();
        particles.update();

        // --- RENDER ---
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 1. Fondo Parallax
        drawParallax(ctx, camera.x, camera.y);

        // 2. Capa de "Juego"
        // Movemos el contexto para simular cámara en el mundo
        ctx.save();
        
        // Truco visual del testbed original mantenido:
        // Las entidades se mueven con la cámara para no perderlas de vista en la demo
        let screenOffset = -camera.x + 300; // Offset base
        ctx.translate(screenOffset, 0); 
        
        // A. Plataformas (Mapa)
        platforms.forEach(p => {
            drawBrickPlatform(ctx, p.x, p.y, p.width, p.height);
        });

        // B. Entidades y Partículas
        // Hack: movemos entidades para que acompañen un poco a la cámara en este demo infinito
        // En un juego real, esto no se haría, pero es para mantener el efecto visual del html original
        let demoFollow = camera.x - 200; 
        
        ctx.save();
        ctx.translate(demoFollow, 0);
            player.draw(ctx);
            walker.draw(ctx);
            flyer.draw(ctx);
            particles.draw(ctx); // Partículas en coordenadas de mundo
        ctx.restore();

        ctx.restore(); // Fin capa juego

        // 3. Efectos Frontales
        // Neblina baja
        let gradFog = ctx.createLinearGradient(0, 600, 0, 720);
        gradFog.addColorStop(0, 'rgba(0,0,0,0)');
        gradFog.addColorStop(1, PALETTE.mist);
        ctx.fillStyle = gradFog;
        ctx.fillRect(0, 600, GAME_WIDTH, 120);

        // Capa delantera (Foreground)
        drawForeground(ctx, camera.x);

        requestAnimationFrame(loop);
    }

    // Start
    loop();

</script>
</body>
</html>