<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shootman: Alien Mothership Level</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #020205;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #game-container {
            position: relative;
            box-shadow: 0 0 50px rgba(0, 255, 200, 0.15); /* Resplandor alienígena sutil */
            border: 4px solid #1a1a2e;
            background: #000;
            width: 100%;
            max-width: 1280px;
            aspect-ratio: 16/9;
        }
        canvas {
            display: block;
            background-color: #050510;
            image-rendering: pixelated;
            width: 100%;
            height: 100%;
        }
        /* Scanlines y viñeta mejorados para ambiente sci-fi */
        #scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: 
                radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,10,20,0.6) 100%), /* Viñeta */
                linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), /* Scanlines H */
                linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06)); /* RGB Split */
            background-size: 100% 100%, 100% 4px, 6px 100%;
            pointer-events: none;
            z-index: 100;
            mix-blend-mode: overlay;
        }
        #debug-ui {
            position: absolute; top: 10px; left: 10px; color: #00ffcc; z-index: 120;
            background: rgba(0, 10, 20, 0.85); 
            border: 1px solid #00ffcc;
            padding: 15px;
            font-size: 14px;
            box-shadow: 0 0 10px rgba(0, 255, 204, 0.2);
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 255, 204, 0.8);
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="testCanvas"></canvas>
    <div id="scanlines"></div>
    <div id="debug-ui">
        <h3>SISTEMA DE DISEÑO</h3>
        <p>Bioma: NAVE ALIENÍGENA</p>
        <p>Estado: CRÍTICO</p>
        <p>Capas Render: 8 (5 Fondo + 1 Juego + 2 Frente)</p>
    </div>
</div>

<script>
    const canvas = document.getElementById('testCanvas');
    const ctx = canvas.getContext('2d');
    
    const GAME_WIDTH = 1280; 
    const GAME_HEIGHT = 720;
    canvas.width = GAME_WIDTH; 
    canvas.height = GAME_HEIGHT;

    // --- PALETA DE COLORES SCI-FI ---
    const COLORS = { 
        player: '#e0e0e0', // Mantener original
        playerAccent: '#ffaa00', // Mantener original
        
        // Nuevos colores de ambiente
        spaceBg: '#020205',
        starBright: '#ffffff',
        starDim: '#4a4a6a',
        
        alienMetalDark: '#0a0a12',
        alienMetalMid: '#151525',
        alienMetalLight: '#2a2a40',
        
        neonCyan: '#00ffcc',
        neonPurple: '#aa00ff',
        hazardRed: '#ff3333'
    };
    
    const ENEMY_COLOR = '#cc4444'; // Mantener original para identificación

    // --- VARIABLES DE SIMULACIÓN ---
    let gameTime = 0;
    let camera = { x: 0, y: 0 };
    
    // --- SISTEMA DE PARTÍCULAS ---
    const particles = [];

    class Particle {
        constructor(x, y, type) {
            this.x = x; this.y = y;
            this.type = type; // 'spark', 'dust', 'fog'
            this.life = 1.0;
            
            if (type === 'spark') {
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = Math.random() * 3 + 1; // Caen hacia abajo
                this.decay = Math.random() * 0.03 + 0.02;
                this.color = '#ffffaa';
                this.size = Math.random() * 2 + 1;
            } else if (type === 'dust') {
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                this.decay = 0.005;
                this.color = Math.random() > 0.5 ? '#00ffcc' : '#aa00ff';
                this.size = Math.random() * 1.5;
            }
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life -= this.decay;
            if (this.type === 'spark') {
                // Rebote simple en "suelo" (y=720 aprox)
                if (this.y > GAME_HEIGHT) this.life = 0;
            }
        }
        draw(ctx) {
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, this.size, this.size);
            ctx.globalAlpha = 1.0;
        }
    }

    function spawnParticles() {
        // Polvo ambiental constante
        if (Math.random() < 0.3) {
            particles.push(new Particle(Math.random() * GAME_WIDTH, Math.random() * GAME_HEIGHT, 'dust'));
        }
        // Chispas de cables rotos (posiciones fijas en el aire simuladas)
        if (Math.random() < 0.1) {
            particles.push(new Particle(300 + Math.random()*10, 100, 'spark'));
        }
        if (Math.random() < 0.1) {
            particles.push(new Particle(900 + Math.random()*10, 50, 'spark'));
        }
    }

    // --- CLASES DE ENTIDADES (SIN CAMBIOS DE TAMAÑO NI LÓGICA) ---
    class MockPlayer {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 24; this.height = 40;
            this.vx = 0; 
            this.animTimer = 0;
            this.facingRight = true;
            this.state = 'wait';
            this.stateTimer = 0;
        }
        update() {
            this.animTimer++;
            this.stateTimer++;
            if (this.state === 'wait') {
                this.vx = 0;
                if (this.stateTimer > 60) {
                    this.state = Math.random() > 0.5 ? 'walk_right' : 'walk_left';
                    this.stateTimer = 0;
                }
            } else if (this.state === 'walk_right') {
                this.vx = 3; this.facingRight = true; this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
            } else if (this.state === 'walk_left') {
                this.vx = -3; this.facingRight = false; this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
            }
            if(this.x < 100) { this.x = 100; this.state = 'walk_right'; }
            if(this.x > 600) { this.x = 600; this.state = 'walk_left'; }
        }
        draw(ctx) {
            ctx.save(); 
            // Sombra sutil para integrar
            ctx.shadowColor = 'black'; ctx.shadowBlur = 10;
            
            ctx.fillStyle = COLORS.player;
            let lean = 0; if (Math.abs(this.vx) > 1) lean = this.facingRight ? 3 : -3; 
            ctx.translate(lean, 0);
            if (Math.abs(this.vx) > 0.5) {
                let cycle = Math.sin(this.animTimer * 0.5);
                ctx.fillRect(this.x + 4, this.y + 25, 6, 15 + cycle * 3); 
                ctx.fillRect(this.x + 14, this.y + 25, 6, 15 - cycle * 3);
            } else { 
                ctx.fillRect(this.x + 4, this.y + 25, 6, 15); 
                ctx.fillRect(this.x + 14, this.y + 25, 6, 15); 
            }
            ctx.fillStyle = '#fff'; ctx.fillRect(this.x, this.y + 10, this.width, 18);
            ctx.fillStyle = '#55f'; ctx.fillRect(this.facingRight ? this.x - 4 : this.x + 20, this.y + 12, 4, 10);
            ctx.fillStyle = '#333'; ctx.fillRect(this.x + 2, this.y, 20, 12);
            ctx.fillStyle = COLORS.playerAccent; ctx.fillRect(this.facingRight ? this.x + 12 : this.x + 2, this.y + 3, 10, 4);
            ctx.fillStyle = '#555';
            let gunX = this.facingRight ? this.x + 14 : this.x - 6; 
            let gunY = this.y + 14;
            ctx.fillRect(gunX, gunY, 16, 6);
            ctx.restore();
        }
    }

    class MockWalker {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 30; this.height = 30;
            this.vx = 2; this.dir = 1; this.timer = 0; this.state = 'walk'; this.startX = x;
        }
        update() {
            this.timer++;
            if (this.state === 'walk') {
                this.x += this.vx;
                if (Math.abs(this.x - this.startX) > 150) {
                    this.state = 'wait'; this.waitTimer = 60;
                }
            } else if (this.state === 'wait') {
                this.waitTimer--;
                if (this.waitTimer <= 0) {
                    this.dir *= -1; this.vx = this.dir * 2; this.state = 'walk';
                }
            }
        }
        draw(ctx) {
            ctx.save();
            ctx.shadowColor = COLORS.hazardRed; ctx.shadowBlur = 5; // Glow enemigo
            ctx.fillStyle = ENEMY_COLOR;
            let anim = Math.sin(this.timer * 0.2);
            let drawY = this.y - 10; 
            ctx.fillRect(this.x, drawY, this.width, this.height);
            ctx.fillStyle = '#fff'; ctx.fillRect(this.x + 10, drawY + 5, 10, 10); 
            ctx.fillStyle = '#f00'; ctx.fillRect(this.x + 13, drawY + 8, 4, 4);
            ctx.fillStyle = ENEMY_COLOR; 
            ctx.save(); ctx.translate(this.x + 5, drawY + 15); ctx.rotate(anim); ctx.fillRect(0, 0, 5, 15); ctx.restore();
            ctx.save(); ctx.translate(this.x + 25, drawY + 15); ctx.rotate(-anim); ctx.fillRect(0, 0, 5, 15); ctx.restore();
            ctx.fillRect(this.x + 5, drawY + 30, 5, 10 + anim * 5); 
            ctx.fillRect(this.x + 20, drawY + 30, 5, 10 - anim * 5);
            ctx.restore();
        }
    }

    class MockFlyer {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 30; this.height = 20; this.startX = x; this.timer = 0;
        }
        update() {
            this.timer++;
            this.x = this.startX + Math.sin(this.timer * 0.02) * 200;
            this.y += Math.cos(this.timer * 0.05) * 1; 
        }
        draw(ctx) {
            let flap = Math.sin(this.timer * 0.8) * 10;
            ctx.save();
            ctx.shadowColor = COLORS.hazardRed; ctx.shadowBlur = 8;
            ctx.fillStyle = ENEMY_COLOR;
            ctx.fillRect(this.x, this.y, 30, 20); 
            ctx.fillStyle = '#777'; 
            ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x - 10, this.y - 10 + flap); ctx.lineTo(this.x + 10, this.y); ctx.fill();
            ctx.beginPath(); ctx.moveTo(this.x + 30, this.y); ctx.lineTo(this.x + 40, this.y - 10 + flap); ctx.lineTo(this.x + 20, this.y); ctx.fill(); 
            ctx.fillStyle = '#ff0'; ctx.fillRect(this.x + 10, this.y + 5, 10, 5);
            ctx.restore();
        }
    }

    // --- INSTANCIAS ---
    const player = new MockPlayer(200, 500);
    const walker = new MockWalker(800, 450);
    const flyer = new MockFlyer(600, 200);

    const platforms = [
        { x: 0, y: 540, width: 800, height: 200 },
        { x: 750, y: 490, width: 400, height: 20 }
    ];

    // --- SISTEMA DE DIBUJADO DE FONDO AVANZADO (5 CAPAS) ---
    // Capa 1: Estrellas (Más lejana)
    // Capa 2: Nebulosas / Estructuras masivas lejanas
    // Capa 3: Casco exterior de la nave (oscuro)
    // Capa 4: Cables densos y tuberías (medio)
    // Capa 5: Estructura interior / Marcos de ventana (cercano)

    function drawAlienBackground(ctx, camX, camY) {
        
        // --- CAPA 0: CIELO ESPACIAL ---
        ctx.fillStyle = COLORS.spaceBg;
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        // --- CAPA 1: ESTRELLAS (Muy lentas) ---
        ctx.save();
        ctx.translate(-camX * 0.02, -camY * 0.02);
        ctx.fillStyle = '#fff';
        for(let i=0; i<200; i++) {
            // Generación pseudo-aleatoria consistente basada en i
            let sx = (i * 137.5) % (GAME_WIDTH * 2);
            let sy = (i * 293.1) % GAME_HEIGHT;
            let size = (i % 3 === 0) ? 2 : 1;
            // Parpadeo
            let alpha = 0.5 + Math.sin(gameTime * 0.05 + i) * 0.4;
            ctx.globalAlpha = alpha;
            ctx.fillRect(sx, sy, size, size);
        }
        ctx.globalAlpha = 1;
        ctx.restore();

        // --- CAPA 2: ESTRUCTURAS MASIVAS EXTERIORES (Lento) ---
        ctx.save();
        let pX2 = -camX * 0.1;
        ctx.translate(pX2, -camY * 0.1);
        ctx.fillStyle = '#080810'; // Silueta oscura
        for(let i=-1; i<4; i++) {
            let offset = i * 600;
            ctx.beginPath();
            ctx.moveTo(offset, 200);
            ctx.lineTo(offset + 100, 150);
            ctx.lineTo(offset + 300, 150);
            ctx.lineTo(offset + 400, 300);
            ctx.lineTo(offset + 500, 100);
            ctx.lineTo(offset + 600, 700);
            ctx.lineTo(offset, 700);
            ctx.fill();
            
            // Luces rojas lejanas
            ctx.fillStyle = '#500';
            ctx.fillRect(offset + 120, 170, 4, 4);
            ctx.fillRect(offset + 130, 170, 4, 4);
            ctx.fillStyle = '#080810'; // Reset
        }
        ctx.restore();

        // --- CAPA 3: TUBERÍAS Y CABLES DE FONDO (Medio) ---
        ctx.save();
        let pX3 = -camX * 0.3;
        ctx.translate(pX3, -camY * 0.3);
        ctx.strokeStyle = '#1a1a25';
        ctx.lineWidth = 8;
        for (let i = -1; i < 10; i++) {
            let xBase = i * 200;
            // Cables colgando verticalmente
            ctx.beginPath();
            ctx.moveTo(xBase, -50);
            ctx.bezierCurveTo(xBase + 20, 300, xBase - 20, 500, xBase, GAME_HEIGHT);
            ctx.stroke();
            
            // Conectores
            ctx.fillStyle = '#222';
            ctx.fillRect(xBase - 10, 100 + (i%3)*100, 20, 30);
        }
        ctx.restore();

        // --- CAPA 4: ESTRUCTURA INTERIOR DENSAS (Rápido) ---
        // Techo y Suelo mecánico denso
        ctx.save();
        let pX4 = -camX * 0.5;
        ctx.translate(pX4, -camY * 0.5);
        ctx.fillStyle = '#11111a';
        
        let tileSize = 300;
        let startI = Math.floor(-pX4 / tileSize) - 1;
        let endI = startI + 6;

        for(let i = startI; i < endI; i++) {
            let bx = i * tileSize;
            
            // Estructura SUPERIOR (Techo denso)
            ctx.fillRect(bx, 0, tileSize - 10, 150);
            // Detalles techo
            ctx.fillStyle = '#222';
            ctx.fillRect(bx + 20, 20, 50, 50);
            ctx.fillRect(bx + 100, 10, 150, 30);
            // Cables colgando del techo
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(bx + 150, 40);
            ctx.lineTo(bx + 150, 180 + Math.sin(gameTime*0.05 + i)*10);
            ctx.stroke();

            // Estructura INFERIOR (Suelo bajo plataforma)
            ctx.fillStyle = '#11111a';
            ctx.fillRect(bx, GAME_HEIGHT - 100, tileSize - 10, 100);
            
            // Luces de estado en las paredes
            if (i % 2 === 0) {
                ctx.fillStyle = (Math.sin(gameTime * 0.1) > 0) ? COLORS.neonCyan : '#003322';
                ctx.shadowColor = COLORS.neonCyan; ctx.shadowBlur = 10;
                ctx.fillRect(bx + 50, 120, 5, 5);
                ctx.shadowBlur = 0;
            }
            
            ctx.fillStyle = '#11111a'; // Reset
        }
        ctx.restore();

        // --- CAPA 5: COLUMNAS GIGANTES Y MARCOS DE VENTANA (Muy Rápido - Define el espacio) ---
        // Esta capa crea la sensación de estar "dentro" mirando hacia fuera
        ctx.save();
        let pX5 = -camX * 0.8;
        ctx.translate(pX5, -camY * 0.8);
        
        let pillarGap = 800; // Grandes ventanales
        let startP = Math.floor(-pX5 / pillarGap) - 1;
        let endP = startP + 4;
        
        for(let i = startP; i < endP; i++) {
            let px = i * pillarGap;
            
            // Gran columna de soporte
            let grad = ctx.createLinearGradient(px, 0, px + 100, 0);
            grad.addColorStop(0, '#050505');
            grad.addColorStop(0.5, '#222');
            grad.addColorStop(1, '#050505');
            ctx.fillStyle = grad;
            
            // Columna en forma de trapecio/soporte
            ctx.beginPath();
            ctx.moveTo(px, 0);
            ctx.lineTo(px + 120, 0);
            ctx.lineTo(px + 100, GAME_HEIGHT);
            ctx.lineTo(px - 20, GAME_HEIGHT);
            ctx.fill();
            
            // Detalles de remaches y luces en la columna
            ctx.fillStyle = '#000';
            ctx.fillRect(px + 30, 0, 10, GAME_HEIGHT);
            
            // Luz de advertencia parpadeante en la columna
            ctx.fillStyle = (Math.floor(gameTime / 30) % 2 === 0) ? COLORS.hazardRed : '#330000';
            ctx.fillRect(px + 45, 300, 20, 60);
        }
        ctx.restore();
    }

    // --- DIBUJADO DE PLATAFORMAS SCI-FI ---
    function drawSciFiPlatforms(ctx) {
        platforms.forEach(p => {
            ctx.save();
            
            // 1. Base Metálica con Gradiente
            let grad = ctx.createLinearGradient(p.x, p.y, p.x, p.y + p.height);
            grad.addColorStop(0, COLORS.alienMetalLight);
            grad.addColorStop(1, COLORS.alienMetalDark);
            ctx.fillStyle = grad;
            ctx.fillRect(p.x, p.y, p.width, p.height);
            
            // 2. Textura de rejilla
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            for(let i = 0; i < p.width; i+=20) {
                ctx.fillRect(p.x + i, p.y, 2, p.height);
            }
            for(let i = 0; i < p.height; i+=20) {
                ctx.fillRect(p.x, p.y + i, p.width, 2);
            }
            
            // 3. Borde Superior Neón (La superficie caminable)
            ctx.shadowColor = COLORS.neonCyan;
            ctx.shadowBlur = 10;
            ctx.fillStyle = COLORS.neonCyan;
            ctx.fillRect(p.x, p.y, p.width, 4);
            ctx.shadowBlur = 0; // Reset
            
            // 4. Decoración lateral (Paneles de precaución)
            ctx.fillStyle = COLORS.alienMetalMid;
            // Dibuja un patrón de rayas de peligro en los lados si es una plataforma flotante
            if (p.height < 100) {
                 ctx.fillStyle = '#222';
                 ctx.beginPath();
                 ctx.moveTo(p.x, p.y+p.height);
                 ctx.lineTo(p.x+20, p.y+p.height+10);
                 ctx.lineTo(p.x+p.width-20, p.y+p.height+10);
                 ctx.lineTo(p.x+p.width, p.y+p.height);
                 ctx.fill();
            }

            ctx.restore();
        });
    }

    // --- CAPAS FRONTALES (FOREGROUND) ---
    function drawForeground(ctx, camX, camY) {
        // Capa F1: Cables borrosos muy cercanos (Arriba y abajo)
        ctx.save();
        let pXF1 = -camX * 1.2; // Se mueven más rápido que la cámara (efecto profundidad)
        ctx.translate(pXF1, -camY * 1.2);
        
        ctx.strokeStyle = 'rgba(0,0,0,0.8)';
        ctx.lineWidth = 20;
        // Blur simulado con transparencia
        for(let i=0; i<5; i++) {
            let offset = i * 900;
            ctx.beginPath();
            ctx.moveTo(offset, -50);
            ctx.quadraticCurveTo(offset + 300, 300, offset + 600, -50);
            ctx.stroke();
        }
        
        // Estructuras inferiores que tapan la visión a veces
        ctx.fillStyle = '#000';
        for(let i=0; i<6; i++) {
            let offset = i * 700 + 200;
            ctx.fillRect(offset, GAME_HEIGHT - 30, 100, 100);
        }
        ctx.restore();

        // Capa F2: Atmósfera y Luces Volumétricas (Estático relativo a la pantalla)
        // Simulamos "neblina" o luz ambiental de la nave
        let grad = ctx.createRadialGradient(GAME_WIDTH/2, GAME_HEIGHT/2, 100, GAME_WIDTH/2, GAME_HEIGHT/2, 600);
        grad.addColorStop(0, 'rgba(0, 255, 204, 0)');
        grad.addColorStop(1, 'rgba(0, 10, 20, 0.4)');
        ctx.fillStyle = grad;
        ctx.fillRect(0,0, GAME_WIDTH, GAME_HEIGHT);
    }

    // --- BUCLE PRINCIPAL ---
    function loop() {
        gameTime++;
        
        // Movimiento de cámara automático (Auto-scroll)
        camera.x = Math.sin(gameTime * 0.005) * 300 + 200; // Desplazamiento lento
        
        // Spawnear partículas
        spawnParticles();

        // Actualizar entidades
        player.update();
        walker.update();
        flyer.update();
        particles.forEach((p, i) => {
            p.update();
            if(p.life <= 0) particles.splice(i, 1);
        });

        // --- RENDERIZADO ---
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 1. FONDO (5 CAPAS)
        drawAlienBackground(ctx, camera.x, camera.y);
        
        // --- MUNDO DEL JUEGO ---
        ctx.save();
        ctx.translate(-camera.x + 200, 0); 

        // 2. PLATAFORMAS (Rediseñadas)
        drawSciFiPlatforms(ctx);
        
        // Hack visual para personajes (mismo del archivo original)
        ctx.save();
        ctx.translate(camera.x - 200, 0); 
        ctx.restore();
        
        let screenOffsetX = camera.x;
        
        // 3. ENTIDADES (Personajes originales)
        ctx.save();
        ctx.translate(screenOffsetX - 200, 0); // Ajuste para demo
        // Dibujamos
        ctx.translate(-screenOffsetX + 200, 0); // Contrarrestar para dibujar en coordenadas mundo
            // Dibuja personajes
            player.draw(ctx);
            walker.draw(ctx);
            flyer.draw(ctx);
            
            // 4. PARTÍCULAS (En el mundo)
            particles.forEach(p => p.draw(ctx));
        ctx.restore();
        
        ctx.restore();
        // --- FIN MUNDO DEL JUEGO ---

        // 5. FOREGROUND (2 CAPAS + UI)
        drawForeground(ctx, camera.x, camera.y);

        requestAnimationFrame(loop);
    }

    loop();

</script>
</body>
</html>