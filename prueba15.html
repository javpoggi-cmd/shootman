<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Shootman: Mystic Forest Engine V2</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #game-container {
            position: relative;
            box-shadow: 0 0 100px rgba(100, 255, 218, 0.2);
            width: 1280px;
            height: 720px;
            background: #0d0221;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #ui {
            position: absolute;
            bottom: 30px; left: 30px;
            font-family: 'Cinzel', serif;
            color: rgba(200, 255, 230, 0.9);
            text-shadow: 0 0 10px rgba(100, 255, 200, 0.5);
            pointer-events: none;
            z-index: 1000;
        }
        h1 { margin: 0; font-size: 24px; letter-spacing: 4px; font-weight: 400; }
        p { margin: 5px 0 0 0; font-size: 14px; opacity: 0.7; font-style: italic; }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>

<div id="game-container">
    <canvas id="artCanvas"></canvas>
    <div id="ui">
        <h1>ETHERIAL ENGINE II</h1>
        <p>Dense Atmosphere & Stone Relics</p>
    </div>
</div>

<script>
(function() {
    const canvas = document.getElementById('artCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    const W = 1280;
    const H = 720;
    canvas.width = W;
    canvas.height = H;

    // --- CONFIGURACIÓN ESTÉTICA ---
    const PALETTE = {
        skyTop: '#050208', // Más oscuro
        skyBot: '#1a0b2e',
        moon: '#ffeebb',
        ruinDark: '#0d0515',
        ruinLight: '#2a1a38',
        floorDark: '#1a1a24',
        floorLight: '#2e2e3d',
        glow: '#64ffda',
        enemy: '#ff4d6d'
    };

    let globalTime = 0;
    const rand = (min, max) => Math.random() * (max - min) + min;

    // --- CLASE BUFANDA (Manteniendo estética del jugador) ---
    class Scarf {
        constructor(length, segments, color) {
            this.nodes = [];
            this.length = length;
            this.color = color;
            for(let i=0; i<segments; i++) this.nodes.push({x: 0, y: 0});
        }
        update(headX, headY, vx) {
            this.nodes[0].x = headX;
            this.nodes[0].y = headY;
            for(let i=1; i<this.nodes.length; i++) {
                let node = this.nodes[i];
                let prev = this.nodes[i-1];
                let wind = Math.sin(globalTime * 0.05 + i) * 2 - (vx * 2);
                let dx = prev.x - node.x;
                let dy = prev.y - node.y;
                node.x += dx * 0.3 + wind * 0.1;
                node.y += dy * 0.3 + 0.5;
                let dist = Math.hypot(dx, dy);
                if (dist > 10) {
                    let angle = Math.atan2(dy, dx);
                    node.x = prev.x - Math.cos(angle) * 10;
                    node.y = prev.y - Math.sin(angle) * 10;
                }
            }
        }
        draw(ctx) {
            ctx.beginPath();
            ctx.moveTo(this.nodes[0].x, this.nodes[0].y);
            for (let i = 1; i < this.nodes.length - 1; i++) {
                let xc = (this.nodes[i].x + this.nodes[i + 1].x) / 2;
                let yc = (this.nodes[i].y + this.nodes[i + 1].y) / 2;
                ctx.quadraticCurveTo(this.nodes[i].x, this.nodes[i].y, xc, yc);
            }
            ctx.quadraticCurveTo(this.nodes[this.nodes.length-1].x, this.nodes[this.nodes.length-1].y, this.nodes[this.nodes.length-1].x, this.nodes[this.nodes.length-1].y);
            ctx.lineWidth = 4;
            ctx.strokeStyle = this.color;
            ctx.lineCap = 'round';
            ctx.stroke();
            ctx.lineWidth = 1; 
        }
    }

    // --- JUGADOR (MISTICO) ---
    class MysticPlayer {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 24; this.height = 40;
            this.vx = 0; this.facingRight = true;
            this.stateTimer = 0; this.state = 'wait';
            this.scarf = new Scarf(50, 6, '#64ffda');
        }
        update() {
            this.stateTimer++;
            if (this.state === 'wait') {
                this.vx = 0;
                if (this.stateTimer > 60) {
                    this.state = Math.random() > 0.5 ? 'walk_right' : 'walk_left';
                    this.stateTimer = 0;
                }
            } else if (this.state === 'walk_right') {
                this.vx = 3; this.facingRight = true; this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
            } else if (this.state === 'walk_left') {
                this.vx = -3; this.facingRight = false; this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
            }
            if(this.x < 100) this.state = 'walk_right';
            if(this.x > 600) this.state = 'walk_left';
            this.scarf.update(this.x + 12 + (this.facingRight ? -4 : 4), this.y + 10, this.vx);
        }
        draw(ctx) {
            // Sombra
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.beginPath(); ctx.ellipse(this.x + 12, this.y + 40, 12, 4, 0, 0, Math.PI*2); ctx.fill();
            this.scarf.draw(ctx);
            ctx.save();
            ctx.translate(this.x + 12, this.y + 20);
            if(!this.facingRight) ctx.scale(-1, 1);
            // Túnica
            ctx.fillStyle = '#1c1c2e'; 
            ctx.beginPath(); ctx.moveTo(-6, -10); ctx.lineTo(6, -10);
            let walkCycle = Math.abs(this.vx) > 0.1 ? Math.sin(globalTime * 0.2) * 4 : 0;
            ctx.lineTo(8 + walkCycle, 20); ctx.lineTo(-8 + walkCycle, 20); ctx.fill();
            // Capucha
            ctx.fillStyle = '#2d2d44';
            ctx.beginPath(); ctx.moveTo(0, -22); ctx.quadraticCurveTo(10, -10, 8, 0); ctx.lineTo(-8, 0); ctx.quadraticCurveTo(-10, -10, 0, -22); ctx.fill();
            // Ojos
            ctx.fillStyle = PALETTE.glow; ctx.shadowBlur = 10; ctx.shadowColor = PALETTE.glow;
            ctx.fillRect(2, -8, 2, 2); ctx.fillRect(5, -8, 2, 2); ctx.shadowBlur = 0;
            ctx.restore();
        }
    }

    // --- ENEMIGO GOLEM (4 CUADRADOS - EL QUE TE GUSTÓ) ---
    class GolemEnemy {
        constructor(x, y) {
            this.x = x; this.y = y; this.startX = x;
            this.vx = 1; this.timer = 0;
            this.stones = [
                {ox: 0, oy: 0, s: 14}, // Cuerpo
                {ox: -12, oy: -8, s: 10}, // Hombro
                {ox: 12, oy: -8, s: 10},  // Hombro
                {ox: 0, oy: -18, s: 8}    // Cabeza
            ];
        }
        update() {
            this.timer++;
            this.x += this.vx;
            if (Math.abs(this.x - this.startX) > 100) this.vx *= -1;
        }
        draw(ctx) {
            ctx.save();
            ctx.translate(this.x + 15, this.y + 15);
            ctx.shadowBlur = 15; ctx.shadowColor = PALETTE.enemy;
            this.stones.forEach((stone, i) => {
                let floatY = Math.sin(this.timer * 0.05 + i) * 4;
                let floatX = Math.cos(this.timer * 0.03 + i) * 2;
                ctx.fillStyle = '#3a2b3d'; 
                ctx.fillRect(stone.ox + floatX - stone.s/2, stone.oy + floatY - stone.s/2, stone.s, stone.s);
                // Núcleo brillante en cada piedra
                ctx.fillStyle = PALETTE.enemy;
                ctx.fillRect(stone.ox + floatX - 2, stone.oy + floatY - 2, 4, 4);
            });
            ctx.shadowBlur = 0;
            ctx.restore();
        }
    }

    // --- NUEVO ENEMIGO VOLADOR: RELIC SENTRY ---
    class RelicSentry {
        constructor(x, y) {
            this.x = x; this.y = y; this.startX = x; this.timer = 0;
        }
        update() {
            this.timer++;
            this.x = this.startX + Math.sin(this.timer * 0.02) * 250;
            this.y += Math.cos(this.timer * 0.04) * 2;
        }
        draw(ctx) {
            let hover = Math.sin(this.timer * 0.1) * 5;
            ctx.save();
            ctx.translate(this.x + 15, this.y + 10 + hover);
            
            // Rotación lenta de la reliquia
            ctx.rotate(this.timer * 0.02);

            // Anillo exterior de piedra
            ctx.strokeStyle = '#5a5e6b';
            ctx.lineWidth = 3;
            ctx.beginPath(); 
            // Dibujamos un rombo hueco
            ctx.moveTo(0, -20); ctx.lineTo(15, 0); ctx.lineTo(0, 20); ctx.lineTo(-15, 0); ctx.closePath();
            ctx.stroke();

            // Cristales flotantes alrededor
            ctx.fillStyle = PALETTE.enemy;
            for(let i=0; i<4; i++) {
                ctx.save();
                ctx.rotate(i * (Math.PI/2));
                ctx.fillRect(0, -25, 4, 8);
                ctx.restore();
            }

            // Ojo central estático (contrarresta rotación)
            ctx.rotate(-this.timer * 0.02); 
            ctx.fillStyle = '#111';
            ctx.beginPath(); ctx.arc(0,0, 8, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.beginPath(); ctx.arc(0,0, 3, 0, Math.PI*2); ctx.fill();
            
            // Haz de luz (Scan)
            ctx.fillStyle = 'rgba(255, 77, 109, 0.2)';
            ctx.beginPath();
            ctx.moveTo(0,0);
            let scanSweep = Math.sin(this.timer * 0.1) * 0.5;
            ctx.lineTo(-30 + (scanSweep*20), 80);
            ctx.lineTo(30 + (scanSweep*20), 80);
            ctx.fill();

            ctx.restore();
        }
    }

    // --- CAPAS DE FONDO Y PRIMER PLANO ---
    
    // Generador de capas
    function createLayer(width, height, type) {
        const c = document.createElement('canvas');
        c.width = width; c.height = height;
        const x = c.getContext('2d');
        
        if (type === 'sky') {
            const grd = x.createLinearGradient(0,0,0,height);
            grd.addColorStop(0, PALETTE.skyTop);
            grd.addColorStop(1, PALETTE.skyBot);
            x.fillStyle = grd;
            x.fillRect(0,0,width,height);
            // Estrellas
            x.fillStyle = '#fff';
            for(let i=0; i<200; i++) {
                x.globalAlpha = rand(0.1, 0.6);
                x.fillRect(rand(0, width), rand(0, height), rand(1, 2), rand(1, 2));
            }
            x.globalAlpha = 1;
        }

        if (type === 'bg_ruins') {
            // Fondo lejano muy denso
            x.fillStyle = '#08030a'; // Casi negro
            // 3 filas de siluetas
            for(let r=0; r<3; r++) {
                let yOff = height - 200 - (r*100);
                x.globalAlpha = 0.3 + (r*0.2);
                for(let i=0; i<width; i+=rand(20, 50)) {
                    let h = rand(100, 400);
                    x.fillRect(i, yOff - h, rand(10, 40), h + 500);
                    // Picos de árboles
                    if(Math.random()>0.5) {
                        x.beginPath(); x.moveTo(i, yOff-h); x.lineTo(i+15, yOff-h-50); x.lineTo(i+30, yOff-h); x.fill();
                    }
                }
            }
        }
        
        if (type === 'mid_forest') {
            // Árboles mas definidos
            x.fillStyle = '#11081a';
            for(let i=0; i<width; i+=80) {
                let h = rand(300, 600);
                // Tronco
                x.beginPath();
                x.moveTo(i, height);
                x.lineTo(i+10, height-h);
                x.lineTo(i+30, height);
                x.fill();
                // Hojas (Círculos)
                x.fillStyle = '#180b24';
                x.beginPath(); x.arc(i+10, height-h, rand(40, 80), 0, Math.PI*2); x.fill();
                x.fillStyle = '#11081a'; // Restaurar
            }
        }

        // NUEVO: PRIMER PLANO (FOREGROUND)
        if (type === 'foreground_bushes') {
            // Siluetas negras puras o muy oscuras
            x.fillStyle = '#020103'; 
            for(let i=0; i<width; i+=40) {
                // Helechos / Hierba alta
                x.beginPath();
                x.moveTo(i, height);
                let h = rand(50, 150);
                x.quadraticCurveTo(i+10, height - h, i+rand(-20, 20), height - h - 20);
                x.lineTo(i+20, height);
                x.fill();
                
                // Rocas ocasionales
                if (Math.random() > 0.8) {
                    x.beginPath();
                    x.arc(i, height, rand(30, 60), Math.PI, 0);
                    x.fill();
                }
            }
        }
        
        return c;
    }

    const bgSky = createLayer(W, H, 'sky');
    const bgRuins = createLayer(W, H, 'bg_ruins');
    const bgForest = createLayer(W, H, 'mid_forest');
    const fgLayer = createLayer(W, 300, 'foreground_bushes'); // Canvas más pequeño para el foreground

    const player = new MysticPlayer(200, 500);
    const walker = new GolemEnemy(800, 440);
    const flyer = new RelicSentry(600, 200);

    const platforms = [
        { x: -100, y: 540, width: 2000, height: 200 }, 
        { x: 750, y: 490, width: 400, height: 20 }
    ];

    let camera = {x:0, y:0};

    function drawMap(ctx) {
        platforms.forEach(p => {
            // NUEVO PISO: Ruinas de piedra labrada
            const stoneGrad = ctx.createLinearGradient(p.x, p.y, p.x, p.y + p.height);
            stoneGrad.addColorStop(0, PALETTE.floorLight);
            stoneGrad.addColorStop(1, PALETTE.floorDark);
            ctx.fillStyle = stoneGrad;
            
            // Bloque principal
            ctx.fillRect(p.x, p.y, p.width, p.height);

            // DETALLES: Baldosas
            ctx.strokeStyle = '#1e1e29';
            ctx.lineWidth = 2;
            for(let i=0; i<p.width; i+=40) {
                // Líneas verticales de baldosas
                ctx.beginPath(); ctx.moveTo(p.x + i, p.y); ctx.lineTo(p.x + i, p.y + p.height); ctx.stroke();
                // Patrón griego simple en el borde superior
                if (i % 80 === 0) {
                    ctx.fillStyle = '#15151f';
                    ctx.fillRect(p.x + i + 10, p.y + 5, 20, 20);
                }
            }
            
            // Borde superior decorado
            ctx.fillStyle = '#3e3e4f';
            ctx.fillRect(p.x, p.y, p.width, 5);

            // Musgo brillante en las grietas
            ctx.fillStyle = PALETTE.glow;
            for(let k=0; k<10; k++) {
                if (Math.random() > 0.8) { // Aleatorio por frame pero 'vibrante'
                    // En un juego real esto sería estático o shader
                    let rx = p.x + Math.random() * p.width;
                    let ry = p.y + Math.random() * p.height;
                    ctx.globalAlpha = 0.3;
                    ctx.fillRect(rx, ry, 5, 5);
                    ctx.globalAlpha = 1;
                }
            }
        });
    }

    function loop() {
        globalTime++;
        camera.x = Math.sin(globalTime * 0.005) * 200 + 200;

        ctx.drawImage(bgSky, 0, 0);

        // --- PARALLAX BACKGROUND (Lleno y Denso) ---
        
        // 1. Ruinas lejanas (Muy lento)
        ctx.save();
        let p1 = -camera.x * 0.1;
        ctx.translate(p1 % W, 0);
        ctx.drawImage(bgRuins, -W, 0); 
        ctx.drawImage(bgRuins, 0, 0);
        ctx.drawImage(bgRuins, W, 0);
        ctx.restore();

        // 2. Bosque Medio (Medio)
        ctx.save();
        let p2 = -camera.x * 0.3;
        ctx.translate(p2 % W, 0);
        ctx.drawImage(bgForest, -W, 0); 
        ctx.drawImage(bgForest, 0, 0);
        ctx.drawImage(bgForest, W, 0);
        ctx.restore();

        // --- JUEGO ---
        ctx.save();
        let screenOffset = camera.x - 200;
        ctx.translate(-screenOffset, 0);

        player.update();
        walker.update();
        flyer.update();

        drawMap(ctx); // Piso nuevo

        // Sombras entidades
        ctx.fillStyle = 'rgba(0,0,0,0.4)';
        ctx.beginPath(); ctx.ellipse(walker.x+15, walker.y+30, 10, 3, 0, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(flyer.x+15, flyer.y+50, 8, 2, 0, 0, Math.PI*2); ctx.fill();

        player.draw(ctx);
        walker.draw(ctx);
        flyer.draw(ctx);
        
        ctx.restore();

        // --- FOREGROUND PARALLAX (NUEVO) ---
        // Pasa por DELANTE del jugador, más cerca de la cámara (rápido)
        // Se dibuja SIN el translate del juego para simular capa de UI/Cámara, pero con offset propio
        ctx.save();
        let pFg = -camera.x * 1.2; // 1.2x velocidad = más cerca
        ctx.translate(pFg % W, H - 250); // Posicionarlo abajo
        // Dibujar capa de helechos repetida
        ctx.drawImage(fgLayer, -W, 0);
        ctx.drawImage(fgLayer, 0, 0);
        ctx.drawImage(fgLayer, W, 0);
        ctx.restore();

        // --- POST PROCESS ---
        const vignette = ctx.createRadialGradient(W/2, H/2, H/3, W/2, H/2, H);
        vignette.addColorStop(0, 'rgba(0,0,0,0)');
        vignette.addColorStop(1, 'rgba(5, 2, 10, 0.6)');
        ctx.fillStyle = vignette;
        ctx.fillRect(0,0,W,H);

        requestAnimationFrame(loop);
    }

    loop();

})();
</script>
</body>
</html>