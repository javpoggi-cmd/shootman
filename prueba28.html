<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shootman: Level 5 - Reactor Core</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #020205; /* Fondo de página oscuro */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #game-wrapper {
            position: relative;
            box-shadow: 0 0 80px rgba(255, 50, 0, 0.15); /* Resplandor rojizo del reactor */
            border: 2px solid #1a1a1a;
            width: 1280px;
            height: 720px;
            background: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        /* Capa de efectos CRT/Scanlines mejorada */
        #overlay-fx {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: 
                linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%), 
                radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.6) 100%); /* Viñeta */
            background-size: 100% 4px, 100% 100%;
            pointer-events: none;
            z-index: 100;
            mix-blend-mode: overlay;
        }
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 110;
            color: #ffaa00; text-shadow: 0 0 5px #ff4400;
            font-family: monospace; pointer-events: none;
        }
        .hazard-text { color: #ff3333; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }
    </style>
</head>
<body>

<div id="game-wrapper">
    <canvas id="gameCanvas"></canvas>
    <div id="overlay-fx"></div>
    <div id="ui-layer">
        <h2>SECTOR 5: NÚCLEO TÉRMICO</h2>
        <p>NIVEL DE RADIACIÓN: <span class="hazard-text">CRÍTICO</span></p>
        <p>SISTEMA DE VENTILACIÓN: FALLANDO</p>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false }); // Optimización
    
    const GAME_WIDTH = 1280; 
    const GAME_HEIGHT = 720;
    canvas.width = GAME_WIDTH; 
    canvas.height = GAME_HEIGHT;

    // --- UTILIDADES GRÁFICAS ---
    
    // Generador de ruido para texturas (Granulado, metal sucio)
    function createNoisePattern(opacity = 0.1, density = 1) {
        const pCanvas = document.createElement('canvas');
        pCanvas.width = 64; pCanvas.height = 64;
        const pCtx = pCanvas.getContext('2d');
        for (let i = 0; i < 64 * 64 * density; i++) {
            const x = Math.random() * 64;
            const y = Math.random() * 64;
            pCtx.fillStyle = `rgba(255, 255, 255, ${Math.random() * opacity})`;
            pCtx.fillRect(x, y, 1, 1);
        }
        return ctx.createPattern(pCanvas, 'repeat');
    }

    const NOISE_TEXTURE = createNoisePattern(0.05);
    const METAL_TEXTURE = createNoisePattern(0.15, 2);

    // --- CONFIGURACIÓN VISUAL AVANZADA ---
    const PALETTE = {
        bgBottom: '#1a0500',   // Rojo oscuro profundo
        bgTop: '#050100',      // Casi negro
        fog: 'rgba(255, 60, 0, 0.05)',
        platformDark: '#111',
        platformLight: '#332222',
        lavaGlow: '#ff4400'
    };

    // --- SISTEMA DE PARTÍCULAS ---
    class ParticleSystem {
        constructor() {
            this.particles = [];
        }

        // Generar chispas o polvo
        emit(x, y, type) {
            const p = {
                x: x, y: y,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                life: 1.0,
                decay: Math.random() * 0.02 + 0.01,
                type: type // 'ember', 'spark', 'dust'
            };
            
            if (type === 'spark') {
                p.vy = Math.random() * -5 - 2; // Saltar hacia arriba
                p.color = '#ffffaa';
            } else if (type === 'ember') {
                p.vy = Math.random() * -1 - 0.5; // Flotar lento
                p.color = `hsl(${Math.random()*40}, 100%, 50%)`;
                p.life = 2.0;
            } else if (type === 'fog_cloud') {
                p.vx = -0.5; // Moverse con el viento
                p.size = Math.random() * 100 + 50;
                p.decay = 0.002;
            }

            this.particles.push(p);
        }

        update() {
            for (let i = this.particles.length - 1; i >= 0; i--) {
                let p = this.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= p.decay;

                // Gravedad simple para chispas
                if (p.type === 'spark') {
                    p.vy += 0.2;
                    // Rebote en piso (aprox y=540 para demo)
                    if (p.y > 540 && p.vy > 0) {
                        p.vy *= -0.6;
                        p.y = 540;
                    }
                }

                if (p.life <= 0) this.particles.splice(i, 1);
            }
        }

        draw(ctx, cameraX) {
            ctx.save();
            for (let p of this.particles) {
                // Dibujar relativo a cámara si no es UI
                let drawX = p.x - (p.type === 'fog_cloud' ? cameraX * 0.8 : cameraX); // Neblina tiene parallax propio
                
                if (p.type === 'fog_cloud') {
                    ctx.globalAlpha = p.life * 0.1;
                    ctx.fillStyle = '#cc5500';
                    ctx.beginPath();
                    ctx.arc(drawX + 200, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Partículas brillantes
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.fillRect(drawX + 200, p.y, 2, 2);
                }
            }
            ctx.restore();
        }
    }

    const particles = new ParticleSystem();

    // --- CLASES DEL JUEGO (Lógica Original mantenida, Draw mejorado ligeramente) ---
    // No cambiamos tamaños ni lógica de movimiento, solo colores y efectos.

    class MockPlayer {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 24; this.height = 40;
            this.vx = 0; 
            this.animTimer = 0;
            this.facingRight = true;
            this.state = 'wait';
            this.stateTimer = 0;
        }
        update() {
            this.animTimer++;
            this.stateTimer++;
            if (this.state === 'wait') {
                this.vx = 0;
                if (this.stateTimer > 60) { this.state = Math.random() > 0.5 ? 'walk_right' : 'walk_left'; this.stateTimer = 0; }
            } else if (this.state === 'walk_right') {
                this.vx = 3; this.facingRight = true; this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
            } else if (this.state === 'walk_left') {
                this.vx = -3; this.facingRight = false; this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
            }
            if(this.x < 100) { this.x = 100; this.state = 'walk_right'; }
            if(this.x > 600) { this.x = 600; this.state = 'walk_left'; }
        }
        draw(ctx) {
            // Sombra debajo
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(this.x + 2, this.y + 38, 20, 4);

            ctx.save(); 
            let lean = 0; if (Math.abs(this.vx) > 1) lean = this.facingRight ? 3 : -3; 
            ctx.translate(lean, 0);
            
            // Piernas (Mismo tamaño)
            ctx.fillStyle = '#222'; // Traje oscuro táctico
            if (Math.abs(this.vx) > 0.5) {
                let cycle = Math.sin(this.animTimer * 0.5);
                ctx.fillRect(this.x + 4, this.y + 25, 6, 15 + cycle * 3); 
                ctx.fillRect(this.x + 14, this.y + 25, 6, 15 - cycle * 3);
            } else { 
                ctx.fillRect(this.x + 4, this.y + 25, 6, 15); 
                ctx.fillRect(this.x + 14, this.y + 25, 6, 15); 
            }
            
            // Cuerpo (Con textura sutil)
            ctx.fillStyle = '#333'; 
            ctx.fillRect(this.x, this.y + 10, this.width, 18);
            
            // Jetpack (Ahora brilla)
            ctx.fillStyle = '#444'; 
            ctx.fillRect(this.facingRight ? this.x - 4 : this.x + 20, this.y + 12, 4, 10); 
            ctx.fillStyle = '#00ffaa'; // Luz del jetpack
            ctx.globalCompositeOperation = 'lighter';
            ctx.fillRect(this.facingRight ? this.x - 4 : this.x + 20, this.y + 14, 2, 4);
            ctx.globalCompositeOperation = 'source-over';

            // Casco
            ctx.fillStyle = '#1a1a1a'; 
            ctx.fillRect(this.x + 2, this.y, 20, 12); 
            // Visor (Brillante)
            ctx.fillStyle = '#ffaa00'; 
            ctx.shadowColor = '#ffaa00'; ctx.shadowBlur = 10; // Glow effect
            ctx.fillRect(this.facingRight ? this.x + 12 : this.x + 2, this.y + 3, 10, 4);
            ctx.shadowBlur = 0;

            // Arma (Metálica)
            ctx.fillStyle = '#555';
            let gunX = this.facingRight ? this.x + 14 : this.x - 6; 
            ctx.fillRect(gunX, this.y + 14, 16, 6);
            ctx.restore();
        }
    }

    class MockWalker {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 30; this.height = 30;
            this.vx = 2; this.dir = 1; this.timer = 0; this.state = 'walk'; this.startX = x;
        }
        update() {
            this.timer++;
            if (this.state === 'walk') {
                this.x += this.vx;
                if (Math.abs(this.x - this.startX) > 150) { this.state = 'wait'; this.waitTimer = 60; }
            } else if (this.state === 'wait') {
                this.waitTimer--;
                if (this.waitTimer <= 0) { this.dir *= -1; this.vx = this.dir * 2; this.state = 'walk'; }
            }
            // Emitir humo
            if (Math.random() > 0.9) particles.emit(this.x + 15, this.y, 'dust');
        }
        draw(ctx) {
            // Diseño "Rusty Mech"
            let anim = Math.sin(this.timer * 0.2);
            let drawY = this.y - 10; 
            
            // Cuerpo principal (Gradiente metálico oxidado)
            let grad = ctx.createLinearGradient(this.x, drawY, this.x + 30, drawY + 30);
            grad.addColorStop(0, '#8B4513'); grad.addColorStop(0.5, '#A0522D'); grad.addColorStop(1, '#5c3a21');
            ctx.fillStyle = grad;
            ctx.fillRect(this.x, drawY, this.width, this.height);
            
            // Ojo Cylon/Robot (Brillante)
            ctx.fillStyle = '#000'; ctx.fillRect(this.x + 5, drawY + 5, 20, 10); 
            ctx.fillStyle = '#ff0000'; 
            ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 15;
            let eyeX = this.x + 10 + Math.sin(this.timer * 0.1) * 5;
            ctx.fillRect(eyeX, drawY + 8, 6, 4);
            ctx.shadowBlur = 0;
            
            // Extremidades oscuras
            ctx.fillStyle = '#2a2a2a'; 
            ctx.save(); ctx.translate(this.x + 5, drawY + 15); ctx.rotate(anim); ctx.fillRect(0, 0, 5, 15); ctx.restore();
            ctx.save(); ctx.translate(this.x + 25, drawY + 15); ctx.rotate(-anim); ctx.fillRect(0, 0, 5, 15); ctx.restore();
            ctx.fillRect(this.x + 5, drawY + 30, 5, 10 + anim * 5); 
            ctx.fillRect(this.x + 20, drawY + 30, 5, 10 - anim * 5);
        }
    }

    class MockFlyer {
        constructor(x, y) {
            this.x = x; this.y = y; this.width = 30; this.height = 20; this.startX = x; this.timer = 0;
        }
        update() {
            this.timer++;
            this.x = this.startX + Math.sin(this.timer * 0.02) * 200;
            this.y += Math.cos(this.timer * 0.05) * 1;
            // Emitir rastro de fuego
            if (this.timer % 5 === 0) particles.emit(this.x + 15, this.y + 10, 'spark');
        }
        draw(ctx) {
            let flap = Math.sin(this.timer * 0.8) * 10;
            // Dron de Seguridad - Color Metálico Azulado
            ctx.fillStyle = '#2F4F4F';
            ctx.fillRect(this.x, this.y, 30, 20); 
            // Alas
            ctx.fillStyle = '#708090'; 
            ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x - 10, this.y - 10 + flap); ctx.lineTo(this.x + 10, this.y); ctx.fill();
            ctx.beginPath(); ctx.moveTo(this.x + 30, this.y); ctx.lineTo(this.x + 40, this.y - 10 + flap); ctx.lineTo(this.x + 20, this.y); ctx.fill(); 
            // Luz de escaneo
            ctx.fillStyle = 'rgba(0, 255, 255, 0.5)'; 
            ctx.beginPath(); ctx.moveTo(this.x + 15, this.y + 20); ctx.lineTo(this.x - 10, this.y + 100); ctx.lineTo(this.x + 40, this.y + 100); ctx.fill();
        }
    }

    const player = new MockPlayer(200, 500);
    const walker = new MockWalker(800, 450);
    const flyer = new MockFlyer(600, 200);

    // --- MAPA / PLATAFORMAS (Texturizado) ---
    const platforms = [
        { x: 0, y: 540, width: 800, height: 200 },
        { x: 750, y: 490, width: 400, height: 20 }
    ];

    function drawMap(ctx) {
        platforms.forEach(p => {
            // 1. Cuerpo Principal de la plataforma (Textura de metal industrial)
            ctx.fillStyle = '#1a1a1a'; 
            ctx.fillRect(p.x, p.y, p.width, p.height);
            
            ctx.fillStyle = METAL_TEXTURE; // Aplicar ruido
            ctx.globalAlpha = 0.3;
            ctx.fillRect(p.x, p.y, p.width, p.height);
            ctx.globalAlpha = 1.0;

            // 2. Borde Superior (Con gradiente de desgaste)
            let topGrad = ctx.createLinearGradient(0, p.y, 0, p.y + 10);
            topGrad.addColorStop(0, '#555'); topGrad.addColorStop(1, '#222');
            ctx.fillStyle = topGrad; 
            ctx.fillRect(p.x, p.y, p.width, 10);

            // 3. Detalles Industriales (Remaches y rejillas)
            ctx.fillStyle = '#000';
            
            // Bandas de peligro (Amarillo/Negro) en los bordes
            if (p.width > 100) {
                for(let k=0; k<p.width; k+=40) {
                    ctx.fillStyle = '#333';
                    ctx.fillRect(p.x + k, p.y + 5, 2, 5); // Tornillos
                }
                // Rejillas de ventilación brillantes (lava debajo)
                if (p.height > 50) {
                    ctx.fillStyle = '#110500';
                    ctx.fillRect(p.x + 50, p.y + 30, p.width - 100, 10);
                    // Brillo de lava
                    ctx.fillStyle = '#ff4400';
                    ctx.globalAlpha = 0.5 + Math.sin(Date.now() * 0.005) * 0.2;
                    for(let r=0; r<p.width-110; r+=20) {
                        ctx.fillRect(p.x + 55 + r, p.y + 32, 10, 6);
                    }
                    ctx.globalAlpha = 1.0;
                }
            }
        });
    }

    // --- FONDO PARALLAX AVANZADO (5 Capas + Cielo) ---
    function drawBackground(ctx, cameraX) {
        // 0. Cielo (Gradiente profundo)
        let skyGrad = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
        skyGrad.addColorStop(0, '#000000');
        skyGrad.addColorStop(0.6, '#1a0505'); // Rojizo medio
        skyGrad.addColorStop(1, '#331100');   // Magma abajo
        ctx.fillStyle = skyGrad;
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        // Configuración de capas (Velocidad, Color Base, Tipo de Estructura)
        const layers = [
            { speed: 0.05, color: '#080202', type: 'silhouette_huge', yOff: 100 },
            { speed: 0.10, color: '#0f0505', type: 'pipes_distant', yOff: 50 },
            { speed: 0.25, color: '#1a0a0a', type: 'pillars', yOff: 0 },
            { speed: 0.50, color: '#261111', type: 'tech_wall', yOff: -50 },
            { speed: 0.75, color: '#331a1a', type: 'details', yOff: -100 }
        ];

        layers.forEach((l, idx) => {
            ctx.save();
            // Parallax offset
            let px = -(cameraX * l.speed) % 1000; // Modulo para loop
            if (px > 0) px -= 1000;
            
            ctx.translate(px, 0);

            // Dibujamos 3 segmentos para cubrir la pantalla y el loop
            for (let i = -1; i < 3; i++) {
                ctx.save();
                ctx.translate(i * 1000, l.yOff);
                
                ctx.fillStyle = l.color;

                if (l.type === 'silhouette_huge') {
                    // Formas masivas de fondo
                    ctx.beginPath();
                    ctx.moveTo(0, 720);
                    ctx.lineTo(0, 300);
                    ctx.lineTo(200, 250);
                    ctx.lineTo(400, 350);
                    ctx.lineTo(600, 200);
                    ctx.lineTo(800, 300);
                    ctx.lineTo(1000, 250);
                    ctx.lineTo(1000, 720);
                    ctx.fill();
                } else if (l.type === 'pipes_distant') {
                    // Tuberías verticales repetitivas
                    for(let j=0; j<1000; j+=50) {
                        if (j%150 === 0) ctx.fillRect(j, 0, 30, 720);
                    }
                } else if (l.type === 'pillars') {
                    // Estructuras diagonales
                    ctx.beginPath();
                    for (let j=0; j<1000; j+= 200) {
                        ctx.moveTo(j, 720); ctx.lineTo(j+50, 0); ctx.lineTo(j+150, 0); ctx.lineTo(j+100, 720);
                    }
                    ctx.fill();
                } else if (l.type === 'tech_wall') {
                    // Pared mecánica con "ventanas" brillantes
                    ctx.fillRect(0, 100, 1000, 620);
                    ctx.fillStyle = '#441100'; // Luz ventanas
                    for (let j=0; j<20; j++) {
                        if (Math.random() > 0.6) 
                            ctx.fillRect(Math.random() * 1000, 200 + Math.random() * 400, 10, 20);
                    }
                } else if (l.type === 'details') {
                    // Cables colgantes
                     ctx.strokeStyle = '#111';
                     ctx.lineWidth = 4;
                     ctx.beginPath();
                     ctx.moveTo(0, -50);
                     ctx.bezierCurveTo(300, 200, 600, 0, 1000, -50);
                     ctx.stroke();
                }

                ctx.restore();
            }
            ctx.restore();
            
            // Añadir una capa de "niebla" entre planos para profundidad
            ctx.fillStyle = `rgba(5, 1, 1, ${0.1 + idx * 0.05})`;
            ctx.fillRect(0,0, GAME_WIDTH, GAME_HEIGHT);
        });
    }

    // --- PRIMER PLANO (FOREGROUND) ---
    // Objetos que pasan FRENTE a la cámara (muy desenfocados y oscuros)
    function drawForeground(ctx, cameraX) {
        ctx.save();
        let speed = 1.2; // Se mueve más rápido que la cámara
        let px = -(cameraX * speed) % 1500;
        if (px > 0) px -= 1500;
        
        ctx.translate(px, 0);
        ctx.fillStyle = '#000';
        ctx.filter = 'blur(4px)'; // Efecto de desenfoque

        for (let i = -1; i < 2; i++) {
            let offset = i * 1500;
            // Gran pilar a la derecha
            ctx.fillRect(offset + 1200, 0, 100, 720);
            // Cadenas colgando
            ctx.fillRect(offset + 400, 0, 10, 400);
            ctx.fillRect(offset + 420, 0, 10, 300);
        }
        
        ctx.filter = 'none';
        ctx.restore();
    }

    // --- LOOP PRINCIPAL ---
    let gameTime = 0;
    let camera = { x: 0, y: 0 };

    function loop() {
        gameTime++;
        
        // Generación ambiental de partículas
        if (gameTime % 10 === 0) {
            // Esporas subiendo desde el fondo
            particles.emit(Math.random() * GAME_WIDTH, GAME_HEIGHT + 10, 'ember');
        }
        if (gameTime % 60 === 0) {
            // Nubes de humo pasando
            particles.emit(GAME_WIDTH + 100, Math.random() * 500, 'fog_cloud');
        }

        // Movimiento de cámara (Scroll automático lento)
        camera.x += 1.5; 

        // Update Entidades
        player.update();
        walker.update();
        flyer.update();
        particles.update();

        // --- RENDER ---
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 1. Fondo
        drawBackground(ctx, camera.x);

        // 2. Capa del Juego (Mundo)
        ctx.save();
        // Centramos las entidades en pantalla de forma relativa para el demo
        // Simulamos que avanzamos infinitamente
        ctx.translate(-200, 0); // Offset base
        
        drawMap(ctx);
        
        // Ajustamos entidades para que parezcan estar en el nivel mientras scrolleamos
        // En un juego real, esto sería la posición absoluta - cámara.
        // Aquí hacemos un pequeño truco para que no se vayan de la pantalla en 2 segundos
        ctx.save();
        // El jugador se queda "quieto" relativamente en X para el demo visual
        // (En un juego real la camara seguiría al jugador)
        
        player.draw(ctx);
        walker.draw(ctx);
        flyer.draw(ctx);
        
        // Dibujar partículas (convertidas a espacio local si es necesario, aquí las dibujamos globales con offset manual en su draw)
        ctx.restore();
        ctx.restore();
        
        // Dibujar partículas (El sistema maneja su propio offset de cámara)
        particles.draw(ctx, camera.x);

        // 3. Primer Plano (Foreground)
        drawForeground(ctx, camera.x);
        
        // 4. Efectos Globales (Tintes)
        // Luz rojiza parpadeante de alarma
        ctx.fillStyle = 'rgba(255, 0, 0, 0.05)';
        ctx.globalCompositeOperation = 'overlay';
        ctx.globalAlpha = 0.1 + Math.sin(gameTime * 0.05) * 0.1;
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        ctx.globalAlpha = 1.0;
        ctx.globalCompositeOperation = 'source-over';

        requestAnimationFrame(loop);
    }

    loop();

</script>
</body>
</html>