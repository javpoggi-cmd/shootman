<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Shootman: Nivel 4 - Núcleo de Fusión</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #020202;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #game-container {
            position: relative;
            box-shadow: 0 0 60px rgba(255, 80, 0, 0.3); /* Resplandor naranja */
            border: 2px solid #444;
            background: #110b0b;
            width: 1280px;
            height: 720px;
        }
        canvas {
            display: block;
            /* El fondo base lo maneja el canvas, pero ponemos un color de respaldo */
            background-color: #1a0f0f;
            image-rendering: pixelated; /* Importante para mantener el estilo retro-hd */
            width: 100%;
            height: 100%;
        }
        
        /* Capa de UI/Vignette para atmósfera */
        #overlay-fx {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.6) 100%);
            pointer-events: none;
            z-index: 10;
        }

        /* Scanlines más sutiles y modernas */
        #scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 11;
            opacity: 0.5;
        }

        #debug-ui {
            position: absolute; top: 15px; left: 15px; 
            color: #ffaa00; 
            text-shadow: 0 0 5px #ff4400;
            z-index: 20;
            font-family: 'Courier New', monospace;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid #ff4400;
            padding: 15px;
            border-radius: 4px;
        }
        h3 { margin: 0 0 5px 0; font-size: 1.2em; text-transform: uppercase; letter-spacing: 2px; }
        p { margin: 2px 0; font-size: 0.85em; color: #aaa; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="testCanvas"></canvas>
    <div id="overlay-fx"></div>
    <div id="scanlines"></div>
    <div id="debug-ui">
        <h3>Sector: NÚCLEO</h3>
        <p>Profundidad: -4500m</p>
        <p>Atmósfera: TÓXICA/CALOR</p>
        <p>Partículas: <span id="p-count">0</span></p>
    </div>
</div>

<script>
    const canvas = document.getElementById('testCanvas');
    const ctx = canvas.getContext('2d', { alpha: false }); // Optimización
    const GAME_WIDTH = 1280; 
    const GAME_HEIGHT = 720;
    canvas.width = GAME_WIDTH; 
    canvas.height = GAME_HEIGHT;

    // --- UTILIDADES GRÁFICAS ---
    
    // Generador de texturas de ruido (Noise) para dar textura a las superficies
    function createNoisePattern(opacity = 0.1, density = 1) {
        const noiseCanvas = document.createElement('canvas');
        noiseCanvas.width = 64; noiseCanvas.height = 64;
        const nCtx = noiseCanvas.getContext('2d');
        
        for(let i=0; i < 64*64*density; i++) {
            const x = Math.random() * 64;
            const y = Math.random() * 64;
            nCtx.fillStyle = `rgba(255,255,255,${Math.random() * opacity})`;
            nCtx.fillRect(x, y, 1, 1);
            nCtx.fillStyle = `rgba(0,0,0,${Math.random() * opacity})`;
            nCtx.fillRect(x+1, y+1, 1, 1);
        }
        return ctx.createPattern(noiseCanvas, 'repeat');
    }

    const noisePattern = createNoisePattern(0.15);
    const heavyNoisePattern = createNoisePattern(0.3, 2);

    // --- CONFIGURACIÓN DEL NIVEL ---
    
    // Colores actualizados para el tema "Volcánico/Industrial"
    const PALETTE = {
        skyTop: '#1a0505',
        skyBottom: '#330a0a',
        fog: 'rgba(255, 100, 50, 0.05)',
        ember: '#ffcc00',
        bgLayer0: '#0f0404', // Más lejano
        bgLayer1: '#1f0a0a',
        bgLayer2: '#2d1010',
        bgLayer3: '#3d1815',
        bgLayer4: '#4f221a', // Más cercano
        platformDark: '#1a1515',
        platformLight: '#332a2a',
        platformGlow: '#ff5500',
        foreground: '#000000'
    };

    const COLORS = { 
        player: '#aaccff', // Azul frío para contrastar con el fondo rojo
        playerAccent: '#00ffff', 
        bullet: '#00ffff', 
        enemyBullet: '#ffaa00', 
        weapon: '#ffffff' 
    };
    
    const ENEMY_COLOR = '#aa3333'; // Rojo oscuro camuflaje

    // --- SISTEMA DE PARTÍCULAS ---
    class ParticleSystem {
        constructor() {
            this.particles = [];
        }

        spawn(x, y, type) {
            if (type === 'ember') {
                this.particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 2,
                    vy: -(Math.random() * 2 + 1), // Flotan hacia arriba
                    life: Math.random() * 100 + 50,
                    maxLife: 150,
                    size: Math.random() * 3 + 1,
                    type: 'ember'
                });
            } else if (type === 'dust') {
                 this.particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5,
                    life: Math.random() * 200 + 100,
                    maxLife: 300,
                    size: Math.random() * 40 + 20,
                    type: 'dust'
                });
            }
        }

        update() {
            for (let i = this.particles.length - 1; i >= 0; i--) {
                let p = this.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;

                if (p.type === 'ember') {
                    p.vx += Math.sin(gameTime * 0.05 + p.life) * 0.05; // Movimiento ondulante
                }

                if (p.life <= 0) this.particles.splice(i, 1);
            }
        }

        draw(ctx, cameraX) {
            ctx.save();
            // Dibujar partículas 'world space' (se mueven con la cámara inversa)
            // Pero para efectos atmosféricos, a veces es mejor que sigan a la cámara un poco (parallax)
            
            this.particles.forEach(p => {
                let drawX = p.x - cameraX; // Posición relativa a pantalla
                // Ajuste simple para partículas infinitas
                if (drawX < -50) p.x += GAME_WIDTH + 100;
                if (drawX > GAME_WIDTH + 50) p.x -= (GAME_WIDTH + 100);

                let alpha = p.life / p.maxLife;
                
                if (p.type === 'ember') {
                    ctx.globalCompositeOperation = 'screen';
                    ctx.fillStyle = `rgba(255, 180, 50, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(drawX, p.y, p.size, 0, Math.PI*2);
                    ctx.fill();
                } else if (p.type === 'dust') {
                    ctx.globalCompositeOperation = 'overlay';
                    ctx.fillStyle = `rgba(255, 100, 50, ${alpha * 0.1})`;
                    ctx.beginPath();
                    ctx.arc(drawX, p.y, p.size, 0, Math.PI*2);
                    ctx.fill();
                }
            });
            ctx.restore();
        }
    }

    const particles = new ParticleSystem();
    // Inicializar ambiente
    for(let i=0; i<50; i++) particles.spawn(Math.random()*GAME_WIDTH, Math.random()*GAME_HEIGHT, 'dust');
    for(let i=0; i<30; i++) particles.spawn(Math.random()*GAME_WIDTH, GAME_HEIGHT, 'ember');

    // --- VARIABLES DE SIMULACIÓN ---
    let gameTime = 0;
    let camera = { x: 0, y: 0 };
    
    // --- CLASES DE ENTIDADES (Lógica Original - Diseño Tweakeado) ---
    class MockPlayer {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 24; this.height = 40;
            this.vx = 0; 
            this.animTimer = 0;
            this.facingRight = true;
            this.state = 'wait';
            this.stateTimer = 0;
        }

        update() {
            this.animTimer++;
            this.stateTimer++;
            // IA Simple (Idéntica al original)
            if (this.state === 'wait') {
                this.vx = 0;
                if (this.stateTimer > 60) { 
                    this.state = Math.random() > 0.5 ? 'walk_right' : 'walk_left';
                    this.stateTimer = 0;
                }
            } else if (this.state === 'walk_right') {
                this.vx = 3; this.facingRight = true; this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
            } else if (this.state === 'walk_left') {
                this.vx = -3; this.facingRight = false; this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
            }
            // Límites
            if(this.x < 100) { this.x = 100; this.state = 'walk_right'; }
            if(this.x > 600) { this.x = 600; this.state = 'walk_left'; }
        }

        draw(ctx) {
            // Sombra simple
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(this.x + 2, this.y + this.height - 2, this.width, 4);

            ctx.save(); 
            let lean = 0; if (Math.abs(this.vx) > 1) lean = this.facingRight ? 3 : -3; 
            ctx.translate(lean, 0);
            
            // Traje mejorado con degradados
            let suitGrad = ctx.createLinearGradient(this.x, this.y, this.x+this.width, this.y+this.height);
            suitGrad.addColorStop(0, '#eee'); suitGrad.addColorStop(1, '#999');
            
            // Piernas
            ctx.fillStyle = '#444'; // Pantalones oscuros
            if (Math.abs(this.vx) > 0.5) {
                let cycle = Math.sin(this.animTimer * 0.5);
                ctx.fillRect(this.x + 4, this.y + 25, 6, 15 + cycle * 3); 
                ctx.fillRect(this.x + 14, this.y + 25, 6, 15 - cycle * 3);
            } else { 
                ctx.fillRect(this.x + 4, this.y + 25, 6, 15); 
                ctx.fillRect(this.x + 14, this.y + 25, 6, 15); 
            }
            
            // Cuerpo (Armadura)
            ctx.fillStyle = COLORS.player; ctx.fillRect(this.x, this.y + 10, this.width, 18);
            // Detalle armadura
            ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.fillRect(this.x, this.y+10, 4, 18); // Brillo lateral

            // Mochila/Jetpack (con luz)
            ctx.fillStyle = '#222'; ctx.fillRect(this.facingRight ? this.x - 4 : this.x + 20, this.y + 12, 4, 10);
            ctx.fillStyle = '#0ff'; ctx.fillRect(this.facingRight ? this.x - 4 : this.x + 20, this.y + 14, 2, 2); // Luz led
            
            // Casco
            ctx.fillStyle = '#222'; ctx.fillRect(this.x + 2, this.y, 20, 12); 
            // Visor Brillante
            ctx.shadowColor = COLORS.playerAccent; ctx.shadowBlur = 10;
            ctx.fillStyle = COLORS.playerAccent; ctx.fillRect(this.facingRight ? this.x + 12 : this.x + 2, this.y + 3, 10, 4);
            ctx.shadowBlur = 0;

            // Arma
            ctx.fillStyle = '#888';
            let gunX = this.facingRight ? this.x + 14 : this.x - 6; 
            ctx.fillRect(gunX, this.y + 14, 16, 6);
            // Brillo arma
            ctx.fillStyle = '#0ff'; ctx.fillRect(this.facingRight ? gunX + 14 : gunX, this.y + 14, 2, 2);

            ctx.restore();
        }
    }

    class MockWalker {
        constructor(x, y) {
            this.x = x; this.y = y; this.width = 30; this.height = 30;
            this.vx = 2; this.dir = 1; this.timer = 0; this.state = 'walk'; this.startX = x;
            this.waitTimer = 0;
        }

        update() {
            this.timer++;
            if (this.state === 'walk') {
                this.x += this.vx;
                if (Math.abs(this.x - this.startX) > 150) {
                    this.state = 'wait'; this.waitTimer = 60;
                }
            } else if (this.state === 'wait') {
                this.waitTimer--;
                if (this.waitTimer <= 0) {
                    this.dir *= -1; this.vx = this.dir * 2; this.state = 'walk';
                }
            }
        }

        draw(ctx) {
            // Robot Oxidado
            let anim = Math.sin(this.timer * 0.2);
            let drawY = this.y - 10; 
            
            // Cuerpo principal
            let grad = ctx.createLinearGradient(this.x, drawY, this.x + 30, drawY + 30);
            grad.addColorStop(0, '#804040'); grad.addColorStop(1, '#402020');
            ctx.fillStyle = grad;
            ctx.fillRect(this.x, drawY, this.width, this.height);
            
            // Textura óxido
            ctx.fillStyle = noisePattern; ctx.fillRect(this.x, drawY, this.width, this.height);

            // Ojo (Cíclope brillante)
            ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 15;
            ctx.fillStyle = '#500'; ctx.fillRect(this.x + 10, drawY + 5, 10, 10); 
            ctx.fillStyle = '#f00'; ctx.fillRect(this.x + 13, drawY + 8, 4, 4);
            ctx.shadowBlur = 0;
            
            // Brazos
            ctx.fillStyle = '#554444'; 
            ctx.save(); ctx.translate(this.x + 5, drawY + 15); ctx.rotate(anim); ctx.fillRect(0, 0, 5, 15); ctx.restore();
            ctx.save(); ctx.translate(this.x + 25, drawY + 15); ctx.rotate(-anim); ctx.fillRect(0, 0, 5, 15); ctx.restore();
            
            // Piernas mecánicas
            ctx.fillRect(this.x + 5, drawY + 30, 5, 10 + anim * 5); 
            ctx.fillRect(this.x + 20, drawY + 30, 5, 10 - anim * 5);
        }
    }

    class MockFlyer {
        constructor(x, y) {
            this.x = x; this.y = y; this.width = 30; this.height = 20;
            this.startX = x; this.timer = 0;
        }
        update() {
            this.timer++;
            this.x = this.startX + Math.sin(this.timer * 0.02) * 200;
            this.y += Math.cos(this.timer * 0.05) * 1; 
        }
        draw(ctx) {
            let flap = Math.sin(this.timer * 0.8) * 10;
            // Drone de combate
            ctx.fillStyle = '#333';
            ctx.fillRect(this.x, this.y, 30, 20); 
            
            // Alas brillantes
            ctx.fillStyle = 'rgba(200, 200, 255, 0.5)'; 
            ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x - 10, this.y - 10 + flap); ctx.lineTo(this.x + 10, this.y); ctx.fill();
            ctx.beginPath(); ctx.moveTo(this.x + 30, this.y); ctx.lineTo(this.x + 40, this.y - 10 + flap); ctx.lineTo(this.x + 20, this.y); ctx.fill(); 
            
            // Motor ardiente
            ctx.fillStyle = '#ffaa00'; ctx.globalAlpha = 0.8 + Math.sin(this.timer)*0.2;
            ctx.fillRect(this.x + 10, this.y + 5, 10, 5);
            ctx.globalAlpha = 1.0;
            
            // Rastro de partículas del motor
            if (Math.random() > 0.5) {
                particles.spawn(this.x + 15, this.y + 10, 'ember');
            }
        }
    }

    // --- GENERACIÓN DEL ESCENARIO ---
    const player = new MockPlayer(200, 500);
    const walker = new MockWalker(800, 450);
    const flyer = new MockFlyer(600, 200);

    const platforms = [
        { x: 0, y: 540, width: 800, height: 200 },
        { x: 750, y: 490, width: 400, height: 20 }
    ];

    // --- DIBUJADO DE FONDO AVANZADO (PARALLAX) ---
    function drawLayer(ctx, layer, cameraX, cameraY, index) {
        let parallaxX = -cameraX * layer.speed; 
        let parallaxY = -cameraY * (layer.speed * 0.3); 
        
        ctx.save();
        ctx.translate(parallaxX, parallaxY);
        
        let totalW = layer.width + layer.gap; 
        // Cálculo para bucle infinito
        let startI = Math.floor(-parallaxX / totalW) - 2; 
        let endI = startI + Math.ceil(GAME_WIDTH / totalW) + 5;
        
        for (let i = startI; i < endI; i++) {
            let noiseVal = Math.sin(i * 12.5 + index * 44.1); 
            let h = layer.heightMod + (noiseVal * 100 + 50); 
            let x = i * totalW; 
            let y = GAME_HEIGHT - h;
            
            // Estilo base según capa
            ctx.fillStyle = layer.color;
            
            // DETALLES ESPECÍFICOS POR CAPA
            if (index === 0) { 
                // Capa 0: Siluetas masivas de fondo (Factorías lejanas)
                ctx.beginPath();
                ctx.moveTo(x, GAME_HEIGHT);
                ctx.lineTo(x, y);
                ctx.lineTo(x + layer.width, y);
                ctx.lineTo(x + layer.width + 20, GAME_HEIGHT);
                ctx.fill();
                // Luces rojas lejanas
                if (i % 3 === 0) {
                    ctx.fillStyle = '#500'; ctx.fillRect(x + 20, y + 20, 5, 5);
                }
            } 
            else if (index === 1 || index === 2) {
                // Capa 1-2: Estructuras de tuberías y soportes
                ctx.fillRect(x, y, layer.width, h + 500);
                // Patrón de vigas
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fillRect(x + 10, y + 10, layer.width - 20, h - 20);
                // Cables colgando
                ctx.beginPath(); ctx.strokeStyle = '#111'; ctx.lineWidth = 2;
                ctx.moveTo(x, y); ctx.quadraticCurveTo(x + layer.width/2, y + 50, x + layer.width, y);
                ctx.stroke();
            }
            else if (index === 3) {
                 // Capa 3: Maquinaria detallada
                 let grad = ctx.createLinearGradient(x, y, x, y+h);
                 grad.addColorStop(0, layer.color);
                 grad.addColorStop(1, '#000');
                 ctx.fillStyle = grad;
                 ctx.fillRect(x, y, layer.width, h + 500);
                 
                 // Rejillas de ventilación brillantes
                 if (noiseVal > 0) {
                     ctx.fillStyle = '#ffaa00'; ctx.globalAlpha = 0.2;
                     for(let r=0; r<5; r++) ctx.fillRect(x + 20, y + 50 + r*10, layer.width - 40, 5);
                     ctx.globalAlpha = 1.0;
                 }
            }
            else {
                // Capa 4: Estructuras cercanas (Grúas, paredes)
                ctx.fillStyle = layer.color;
                ctx.fillRect(x, y, layer.width, h + 500);
                // Remaches
                ctx.fillStyle = '#221111';
                for(let b=0; b<h; b+=40) {
                    ctx.beginPath(); ctx.arc(x+5, y+b, 3, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x+layer.width-5, y+b, 3, 0, Math.PI*2); ctx.fill();
                }
                // Textura de ruido
                ctx.fillStyle = noisePattern;
                ctx.fillRect(x, y, layer.width, h+500);
            }
        }
        ctx.restore();
    }

    function drawBackground(ctx, cameraX, cameraY) {
        // Cielo degradado (Atmósfera pesada)
        let skyGrad = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
        skyGrad.addColorStop(0, PALETTE.skyTop);
        skyGrad.addColorStop(0.6, PALETTE.skyBottom);
        skyGrad.addColorStop(1, '#ff5500'); // Resplandor de lava/horno abajo
        ctx.fillStyle = skyGrad;
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        // Capas de fondo (Parallax)
        const layers = [
            { speed: 0.05, color: PALETTE.bgLayer0, heightMod: 400, width: 300, gap: 0 },
            { speed: 0.15, color: PALETTE.bgLayer1, heightMod: 350, width: 150, gap: 50 },
            { speed: 0.30, color: PALETTE.bgLayer2, heightMod: 200, width: 100, gap: 20 },
            { speed: 0.50, color: PALETTE.bgLayer3, heightMod: 150, width: 200, gap: 100 },
            { speed: 0.75, color: PALETTE.bgLayer4, heightMod: 50, width: 120, gap: 150 }
        ];

        layers.forEach((l, i) => drawLayer(ctx, l, cameraX, cameraY, i));
        
        // Niebla volumétrica (Subiendo desde abajo)
        let fogGrad = ctx.createLinearGradient(0, GAME_HEIGHT - 200, 0, GAME_HEIGHT);
        fogGrad.addColorStop(0, 'rgba(255, 100, 50, 0)');
        fogGrad.addColorStop(1, 'rgba(255, 80, 0, 0.3)');
        ctx.fillStyle = fogGrad;
        ctx.fillRect(0, GAME_HEIGHT - 200, GAME_WIDTH, 200);
    }

    // --- NUEVA CAPA FRONTAL (FOREGROUND) ---
    function drawForeground(ctx, cameraX) {
        let parallaxX = -cameraX * 1.2; // Se mueve más rápido que el jugador
        
        ctx.save();
        ctx.translate(parallaxX, 0);
        
        // Cadenas borrosas y columnas desenfocadas que pasan rápido
        let spacing = 600;
        let startI = Math.floor(-parallaxX / spacing) - 1;
        let endI = startI + Math.ceil(GAME_WIDTH / spacing) + 2;

        for (let i = startI; i < endI; i++) {
            let x = i * spacing;
            
            // Columna borrosa (simulada con alpha bajo y bordes difusos)
            // Canvas no tiene blur performante en tiempo real, usamos degradados
            let grad = ctx.createLinearGradient(x, 0, x + 60, 0);
            grad.addColorStop(0, 'rgba(0,0,0,0)');
            grad.addColorStop(0.2, 'rgba(0,0,0,0.8)');
            grad.addColorStop(0.8, 'rgba(0,0,0,0.8)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            
            ctx.fillStyle = grad;
            ctx.fillRect(x, -50, 60, GAME_HEIGHT + 100);

            // Cadenas colgando
            if (i % 2 === 0) {
                ctx.fillStyle = '#000';
                for(let c=0; c<GAME_HEIGHT/2; c+=30) {
                    ctx.fillRect(x + 30, c, 10, 20);
                }
            }
        }
        ctx.restore();
    }

    function drawMap(ctx) {
        // Dibujo de Plataformas con alta fidelidad
        platforms.forEach(p => {
            // 1. Cuerpo de la plataforma
            ctx.fillStyle = PALETTE.platformDark;
            ctx.fillRect(p.x, p.y, p.width, p.height);
            
            // 2. Textura Heavy Metal
            ctx.fillStyle = heavyNoisePattern;
            ctx.fillRect(p.x, p.y, p.width, p.height);

            // 3. Borde superior (Piso)
            ctx.fillStyle = PALETTE.platformLight;
            ctx.fillRect(p.x, p.y, p.width, 10);
            
            // 4. Brillo de lava reflejado abajo
            let lavaGlow = ctx.createLinearGradient(p.x, p.y + p.height - 20, p.x, p.y + p.height);
            lavaGlow.addColorStop(0, 'rgba(0,0,0,0)');
            lavaGlow.addColorStop(1, 'rgba(255, 80, 0, 0.5)');
            ctx.fillStyle = lavaGlow;
            ctx.fillRect(p.x, p.y + p.height - 20, p.width, 20);

            // 5. Detalles industriales (Rejillas y tuberías)
            if (p.height > 50) {
                // Tubería lateral
                ctx.fillStyle = '#222';
                ctx.fillRect(p.x, p.y + 30, p.width, 10);
                // Rayas de peligro
                ctx.fillStyle = '#332200';
                for(let i=0; i<p.width; i+=40) {
                    ctx.beginPath();
                    ctx.moveTo(p.x + i, p.y + 30);
                    ctx.lineTo(p.x + i + 10, p.y + 30);
                    ctx.lineTo(p.x + i, p.y + 40);
                    ctx.fill();
                }
            } else {
                // Plataforma flotante
                // Propulsores abajo
                ctx.fillStyle = '#444';
                for(let i=20; i<p.width; i+=100) {
                    ctx.fillRect(p.x + i, p.y + p.height, 20, 5);
                    // Fuego del propulsor
                    ctx.fillStyle = `rgba(0, 255, 255, ${0.5 + Math.random()*0.5})`;
                    ctx.beginPath(); ctx.moveTo(p.x+i, p.y+p.height+5); ctx.lineTo(p.x+i+10, p.y+p.height+15+Math.random()*10); ctx.lineTo(p.x+i+20, p.y+p.height+5); ctx.fill();
                    ctx.fillStyle = '#444';
                }
            }
        });
    }

    // --- BUCLE PRINCIPAL ---
    function loop() {
        gameTime++;
        
        // Generar partículas ambientales aleatorias
        if (Math.random() < 0.2) {
            particles.spawn(camera.x + Math.random() * GAME_WIDTH, GAME_HEIGHT, 'ember');
        }

        // Movimiento de cámara (Simulación)
        camera.x = Math.sin(gameTime * 0.005) * 300 + 100; 

        player.update();
        walker.update();
        flyer.update();
        particles.update();

        // Renderizado
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 1. Fondo y Parallax
        drawBackground(ctx, camera.x, camera.y);
        
        // 2. Mundo del Juego (Cámara aplicada)
        ctx.save();
        let screenOffsetX = -camera.x + 200; 
        ctx.translate(screenOffsetX, 0); 

        // Mapa
        drawMap(ctx);
        
        // Partículas (Detrás de personajes)
        // Ajustamos la posición de dibujo de partículas para que coincida con el mundo
        // Como el sistema de partículas dibuja relativo a pantalla, usamos un truco inverso o las dibujamos antes
        ctx.restore(); 
        
        // Partículas (Dibujadas en screen space pero calculadas para verse integradas)
        particles.draw(ctx, camera.x - 200);

        // Volvemos a espacio mundo para entidades
        ctx.save();
        ctx.translate(screenOffsetX, 0);

        // Entidades
        // Para mantenerlas en pantalla en este demo:
        let playerScreenPos = player.x + screenOffsetX;
        
        // Dibujamos personajes "reales"
        player.draw(ctx);
        walker.draw(ctx);
        flyer.draw(ctx);
        
        ctx.restore();

        // 3. Foreground (Capa frontal muy rápida)
        drawForeground(ctx, camera.x);

        // UI Debug
        document.getElementById('p-count').innerText = particles.particles.length;

        requestAnimationFrame(loop);
    }

    loop();

</script>
</body>
</html>