<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Shootman: Abstract Space Redesign</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #0a0505;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #game-wrapper {
            position: relative;
            box-shadow: 0 0 100px rgba(255, 100, 0, 0.3);
            border: 1px solid #442211;
            width: 1280px;
            height: 720px;
            overflow: hidden;
            background: #1a0b0b;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Efectos de Post-Procesado CSS */
        #vignette {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(0,0,0,0) 50%, rgba(50, 10, 0, 0.6) 90%, rgba(0,0,0,1) 100%);
            pointer-events: none;
            z-index: 10;
        }

        #scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 11;
            opacity: 0.6;
        }

        #noise {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.05'/%3E%3C/svg%3E");
            pointer-events: none;
            z-index: 12;
            opacity: 0.4;
        }

        #ui-layer {
            position: absolute;
            top: 20px; left: 20px;
            z-index: 20;
            color: #ffccaa;
            text-shadow: 0 0 10px #ff4400;
        }
        
        h3 { margin: 0; letter-spacing: 2px; text-transform: uppercase; font-size: 18px; }
        p { margin: 5px 0; font-size: 12px; color: #aa8877; }

    </style>
</head>
<body>

<div id="game-wrapper">
    <canvas id="gameCanvas"></canvas>
    <div id="vignette"></div>
    <div id="scanlines"></div>
    <div id="noise"></div>
    <div id="ui-layer">
        <h3>Abstract Horizon</h3>
        <p>Render: Canvas 2D / Style: Low Poly</p>
        <p>Active Layers: 5 + Foreground</p>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false }); // Optimización
    const GAME_WIDTH = 1280; 
    const GAME_HEIGHT = 720;
    canvas.width = GAME_WIDTH; 
    canvas.height = GAME_HEIGHT;

    // --- PALETA DE COLORES (Inspirada en la imagen provista) ---
    const PALETTE = {
        bg_deep: '#1a0505',       // Rojo muy oscuro
        bg_grid: '#331111',       // Rojo rejilla
        sun_start: '#ffaa00',     // Amarillo sol
        sun_end: '#ff4400',       // Rojo sol
        accent_cyan: '#00ffee',   // Cyan neón (contraste)
        poly_orange: '#ff6600',   // Naranja principal
        poly_dark: '#441111',     // Sombra polígonos
        ground_top: '#ff8844',
        ground_base: '#220a0a',
        fog: 'rgba(60, 20, 10, 0.5)'
    };

    // --- UTILIDADES GRÁFICAS ---

    // Dibuja un polígono regular o irregular para el look "Low Poly"
    function drawPoly(ctx, x, y, radius, sides, rotation, color, shine = false) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotation);
        ctx.beginPath();
        for (let i = 0; i < sides; i++) {
            const angle = (i * 2 * Math.PI) / sides;
            ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
        }
        ctx.closePath();
        ctx.fillStyle = color;
        
        if (shine) {
            ctx.shadowBlur = 15;
            ctx.shadowColor = color;
        }
        ctx.fill();
        
        // Efecto facetado (borde interior ligero)
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.restore();
    }

    // Generador de gradientes facetados
    function createFacetGradient(ctx, x, y, width, height, c1, c2) {
        let grad = ctx.createLinearGradient(x, y, x + width, y + height);
        grad.addColorStop(0, c1);
        grad.addColorStop(0.5, c2);
        grad.addColorStop(1, c1);
        return grad;
    }

    // --- SISTEMA DE PARTÍCULAS ---
    class ParticleSystem {
        constructor() {
            this.particles = [];
        }

        // Tipos: 'dust', 'spark', 'trail'
        spawn(x, y, type, options = {}) {
            let p = {
                x: x, y: y,
                vx: (Math.random() - 0.5) * (options.speed || 1),
                vy: (Math.random() - 0.5) * (options.speed || 1),
                life: 1.0,
                decay: options.decay || 0.02,
                size: options.size || 2,
                color: options.color || '#fff',
                type: type
            };

            if (type === 'dust') {
                p.vy = -0.2; // Flota hacia arriba
                p.vx = 0.5; // Viento suave
            } else if (type === 'spark') {
                p.vy = Math.random() * 2 + 1; // Cae
                p.vx = (Math.random() - 0.5) * 4;
            }

            this.particles.push(p);
        }

        update() {
            for (let i = this.particles.length - 1; i >= 0; i--) {
                let p = this.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= p.decay;

                if (p.type === 'spark') p.vy += 0.1; // Gravedad

                if (p.life <= 0) this.particles.splice(i, 1);
            }
        }

        draw(ctx, cameraX) {
            ctx.save();
            ctx.translate(-cameraX + 200, 0); // Ajuste de cámara simplificado para partículas del mundo
            
            this.particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                
                if (p.type === 'dust') {
                    // Polvo hexagonal
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.fillRect(p.x, p.y, p.size, p.size);
                }
            });
            ctx.restore();
        }
    }

    const particles = new ParticleSystem();

    // --- ENTIDADES ---

    class VisualPlayer {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 24; this.height = 40;
            this.vx = 0; 
            this.animTimer = 0;
            this.facingRight = true;
            this.state = 'wait';
            this.stateTimer = 0;
        }

        update() {
            // Lógica simple original
            this.animTimer++;
            this.stateTimer++;
            
            // Generar partículas de "propulsor" si se mueve
            if (Math.abs(this.vx) > 0) {
                if (Math.random() > 0.5) {
                    particles.spawn(this.x + (this.facingRight ? 0 : 20), this.y + 30, 'spark', 
                        { color: PALETTE.accent_cyan, size: 2, decay: 0.05 });
                }
            }

            if (this.state === 'wait') {
                this.vx = 0;
                if (this.stateTimer > 60) { 
                    this.state = Math.random() > 0.5 ? 'walk_right' : 'walk_left';
                    this.stateTimer = 0;
                }
            } else if (this.state === 'walk_right') {
                this.vx = 3;
                this.facingRight = true;
                this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
            } else if (this.state === 'walk_left') {
                this.vx = -3;
                this.facingRight = false;
                this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
            }
            
            if(this.x < 100) { this.x = 100; this.state = 'walk_right'; }
            if(this.x > 600) { this.x = 600; this.state = 'walk_left'; }
        }

        draw(ctx) {
            ctx.save(); 
            // Dibujamos centrado en la base del rectángulo original
            ctx.translate(this.x + this.width/2, this.y + this.height/2);
            if (!this.facingRight) ctx.scale(-1, 1);

            // Bobbing animation
            let bob = Math.sin(this.animTimer * 0.2) * 2;
            
            // Sombra
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.beginPath(); ctx.ellipse(0, 20, 10, 3, 0, 0, Math.PI*2); ctx.fill();

            ctx.translate(0, bob);

            // --- DISEÑO DEL JUGADOR (Estilo Soldado Geométrico) ---
            
            // Pie trasero
            ctx.fillStyle = '#333';
            ctx.beginPath(); ctx.moveTo(-5, 10); ctx.lineTo(0, 20); ctx.lineTo(-8, 20); ctx.fill();

            // Cuerpo (Hexagonal estilizado)
            let bodyGrad = ctx.createLinearGradient(-10, -15, 10, 15);
            bodyGrad.addColorStop(0, '#fff');
            bodyGrad.addColorStop(1, '#999');
            ctx.fillStyle = bodyGrad;
            
            ctx.beginPath();
            ctx.moveTo(-8, -10); ctx.lineTo(8, -10); // Hombros
            ctx.lineTo(6, 10); ctx.lineTo(-6, 10);   // Cintura
            ctx.fill();

            // Cabeza (Casco angular con visor)
            ctx.fillStyle = '#e0e0e0';
            ctx.beginPath(); ctx.moveTo(-6, -10); ctx.lineTo(6, -10); ctx.lineTo(8, -22); ctx.lineTo(-8, -22); ctx.fill();
            
            // Visor (Brillante)
            ctx.fillStyle = PALETTE.accent_cyan;
            ctx.shadowColor = PALETTE.accent_cyan; ctx.shadowBlur = 10;
            ctx.beginPath(); ctx.moveTo(2, -18); ctx.lineTo(8, -18); ctx.lineTo(7, -14); ctx.lineTo(2, -14); ctx.fill();
            ctx.shadowBlur = 0;

            // Arma (Bloque futurista)
            ctx.fillStyle = '#555';
            ctx.fillRect(0, -2, 18, 6);
            ctx.fillStyle = PALETTE.poly_orange; // Punta arma
            ctx.fillRect(16, -1, 3, 4);

            // Pie delantero
            ctx.fillStyle = '#555';
            let legAnim = Math.sin(this.animTimer * 0.5) * 5;
            if (Math.abs(this.vx) < 0.1) legAnim = 0;
            ctx.beginPath(); ctx.moveTo(2, 10); ctx.lineTo(5 + legAnim, 20); ctx.lineTo(-2 + legAnim, 20); ctx.fill();

            ctx.restore();
        }
    }

    class VisualWalker {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 30; this.height = 30;
            this.vx = 2; this.dir = 1; this.timer = 0; this.startX = x; this.state = 'walk';
            this.rotation = 0;
        }

        update() {
            this.timer++;
            if (this.state === 'walk') {
                this.x += this.vx;
                this.rotation += this.vx * 0.05; // Rodar un poco
                if (Math.abs(this.x - this.startX) > 150) {
                    this.state = 'wait'; this.waitTimer = 60;
                }
            } else if (this.state === 'wait') {
                this.waitTimer--;
                if (this.waitTimer <= 0) {
                    this.dir *= -1; this.vx = this.dir * 2; this.state = 'walk';
                }
            }
        }

        draw(ctx) {
            ctx.save();
            ctx.translate(this.x + 15, this.y + 15);
            
            // Cuerpo: Icosaedro rodante (Estilo "Virus" de la imagen)
            // Color base rojo/naranja
            let grad = ctx.createRadialGradient(0,0, 2, 0,0, 15);
            grad.addColorStop(0, PALETTE.poly_orange);
            grad.addColorStop(1, '#aa2200');
            
            ctx.fillStyle = grad;
            
            // Dibujar picos giratorios
            ctx.rotate(this.rotation);
            for(let i=0; i<6; i++) {
                ctx.save();
                ctx.rotate((i * 60 * Math.PI) / 180);
                ctx.beginPath();
                ctx.moveTo(0, -10); ctx.lineTo(5, -20); ctx.lineTo(-5, -20);
                ctx.fill();
                ctx.restore();
            }

            // Núcleo central
            ctx.beginPath();
            ctx.arc(0, 0, 12, 0, Math.PI*2);
            ctx.fill();

            // Ojo brillante central
            ctx.fillStyle = PALETTE.accent_cyan;
            ctx.shadowBlur = 10; ctx.shadowColor = PALETTE.accent_cyan;
            ctx.beginPath();
            ctx.arc(0, 0, 4, 0, Math.PI*2);
            ctx.fill();
            ctx.shadowBlur = 0;

            ctx.restore();
        }
    }

    class VisualFlyer {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 30; this.height = 20;
            this.startX = x; this.timer = 0;
        }

        update() {
            this.timer++;
            this.x = this.startX + Math.sin(this.timer * 0.02) * 200;
            this.y += Math.cos(this.timer * 0.05) * 1;
            
            // Estela de partículas
            if (this.timer % 5 === 0) {
                particles.spawn(this.x + 15, this.y + 10, 'trail', { 
                    color: 'rgba(255, 100, 0, 0.5)', size: 4, decay: 0.05, speed: 0 
                });
            }
        }

        draw(ctx) {
            ctx.save();
            ctx.translate(this.x + 15, this.y + 10);
            
            let hover = Math.sin(this.timer * 0.1) * 5;
            ctx.translate(0, hover);

            // Forma: Rombo agresivo flotante
            ctx.fillStyle = '#cc3300';
            ctx.beginPath();
            ctx.moveTo(0, -15); // Arriba
            ctx.lineTo(15, 0);  // Derecha
            ctx.lineTo(0, 10);  // Abajo
            ctx.lineTo(-15, 0); // Izquierda
            ctx.fill();

            // Detalles internos (Facetado)
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.beginPath(); ctx.moveTo(0, -15); ctx.lineTo(5, 0); ctx.lineTo(0, 10); ctx.fill();

            // Núcleo energía
            ctx.fillStyle = '#ffee00';
            ctx.shadowColor = '#ff4400'; ctx.shadowBlur = 15;
            ctx.beginPath(); ctx.arc(0, 0, 5, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0;

            ctx.restore();
        }
    }

    // --- MUNDO ---
    const player = new VisualPlayer(200, 500);
    const walker = new VisualWalker(800, 430); // Ajustado altura
    const flyer = new VisualFlyer(600, 200);

    const platforms = [
        { x: 0, y: 540, width: 800, height: 200 }, 
        { x: 750, y: 490, width: 400, height: 20 } 
    ];

    // --- BACKGROUND MEJORADO (PARALLAX GEOMÉTRICO) ---
    function drawBackground(ctx, cameraX, cameraY) {
        // 0. CIELO GRADIENTE PROFUNDO
        let skyGrad = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
        skyGrad.addColorStop(0, '#331100');
        skyGrad.addColorStop(1, '#050000');
        ctx.fillStyle = skyGrad;
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        // 1. FONDO LEJANO: RED GEOMÉTRICA (GRID) + SOL ABSTRACTO
        ctx.save();
        ctx.translate(-cameraX * 0.02, -cameraY * 0.01);
        
        // Grid
        ctx.strokeStyle = 'rgba(255, 100, 50, 0.08)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for(let i=0; i<GAME_WIDTH*2; i+=80) {
            ctx.moveTo(i, 0); ctx.lineTo(i - 200, GAME_HEIGHT); // Líneas diagonales
        }
        for(let i=0; i<GAME_HEIGHT; i+=80) {
            ctx.moveTo(0, i); ctx.lineTo(GAME_WIDTH*1.5, i);
        }
        ctx.stroke();

        // Sol Abstracto Facetado
        ctx.translate(800, 300);
        let sunGrad = ctx.createRadialGradient(0,0, 50, 0,0, 200);
        sunGrad.addColorStop(0, PALETTE.sun_start);
        sunGrad.addColorStop(1, 'rgba(255, 60, 0, 0)');
        ctx.fillStyle = sunGrad;
        ctx.beginPath(); ctx.arc(0,0,200, 0, Math.PI*2); ctx.fill();
        
        // Elementos flotantes decorativos (triángulos)
        for(let k=0; k<5; k++) {
            drawPoly(ctx, Math.cos(k)*300, Math.sin(k)*200, 40, 3, k, 'rgba(255,200,100,0.05)');
        }
        ctx.restore();

        // 2-5. CAPAS DE MONTAÑAS GEOMÉTRICAS (Generación procedural simple)
        const layers = [
            { speed: 0.1, color: '#1a0505', heightBase: 400, spike: 100 }, // Más lejano, oscuro
            { speed: 0.2, color: '#2b0a0a', heightBase: 300, spike: 150 },
            { speed: 0.4, color: '#44110a', heightBase: 200, spike: 200 },
            { speed: 0.6, color: '#662200', heightBase: 100, spike: 80 }  // Más cercano
        ];

        layers.forEach((layer, idx) => {
            ctx.save();
            let px = -cameraX * layer.speed;
            let py = -cameraY * layer.speed * 0.3;
            ctx.translate(px, py);

            // Neblina entre capas
            ctx.fillStyle = layer.color;
            
            // Dibujar siluetas poligonales
            ctx.beginPath();
            ctx.moveTo(-1000, GAME_HEIGHT);
            
            // Simulamos montañas repetitivas
            let startI = Math.floor(-px / 200) - 2;
            let endI = startI + 15;

            for (let i = startI; i < endI; i++) {
                let seed = Math.sin(i * 132.4 + idx * 43.1);
                let x = i * 300;
                let h = layer.heightBase + Math.abs(seed) * layer.spike;
                let peakX = x + 150;
                
                // Montaña triangular simple
                ctx.lineTo(x, GAME_HEIGHT);
                ctx.lineTo(peakX, GAME_HEIGHT - h);
                ctx.lineTo(x + 300, GAME_HEIGHT);
            }
            
            ctx.lineTo(endI * 300, GAME_HEIGHT + 500);
            ctx.lineTo(-1000, GAME_HEIGHT + 500);
            ctx.fill();

            // Añadir borde iluminado a la capa más cercana
            if (idx === 3) {
                ctx.strokeStyle = '#ff8800';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Neblina atmosférica encima de cada capa
            let fogGrad = ctx.createLinearGradient(0, GAME_HEIGHT - layer.heightBase, 0, GAME_HEIGHT);
            fogGrad.addColorStop(0, 'rgba(255,100,0,0)');
            fogGrad.addColorStop(1, 'rgba(50,10,0,0.3)');
            ctx.fillStyle = fogGrad;
            ctx.fillRect(startI * 300, 0, (endI - startI) * 300, GAME_HEIGHT);

            ctx.restore();
        });
    }

    function drawForeground(ctx, cameraX) {
        // CAPA EXTRA DELANTE DE PLATAFORMAS (Objetos muy rápidos y borrosos)
        ctx.save();
        let speed = 1.2; // Más rápido que el jugador
        let px = -cameraX * speed;
        ctx.translate(px, 0);

        ctx.fillStyle = '#000';
        ctx.globalAlpha = 0.8;
        
        // Pilares negros grandes que pasan frente a la cámara
        let startI = Math.floor(-px / 1000) - 1;
        let endI = startI + 4;

        for (let i = startI; i < endI; i++) {
            // Solo dibujar ocasionalmente
            if (i % 2 !== 0) continue;
            
            let x = i * 1000;
            
            // Blur simulado dibujando varias veces con baja opacidad
            for(let b=0; b<5; b++) {
                ctx.fillRect(x - b*10, 0, 100 + b*20, GAME_HEIGHT); // Pilar vertical
                ctx.globalAlpha = 0.1;
            }
            ctx.globalAlpha = 0.8;
        }
        ctx.restore();
    }

    function drawMap(ctx) {
        platforms.forEach(p => {
            // Cuerpo de la plataforma (Textura tecnológica oscura)
            ctx.save();
            
            // Gradiente del bloque
            let grad = ctx.createLinearGradient(p.x, p.y, p.x, p.y + p.height);
            grad.addColorStop(0, '#2a1111');
            grad.addColorStop(1, '#000');
            ctx.fillStyle = grad;
            ctx.fillRect(p.x, p.y, p.width, p.height);

            // Borde Superior "Neón" (Estilo TRON/Cyber)
            ctx.fillStyle = PALETTE.poly_orange;
            ctx.shadowColor = '#ff4400';
            ctx.shadowBlur = 15;
            ctx.fillRect(p.x, p.y, p.width, 4);
            ctx.shadowBlur = 0;

            // Patrón de rejilla decorativa en el frente
            ctx.strokeStyle = '#442211';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for(let i=p.x; i<p.x+p.width; i+=40) {
                ctx.moveTo(i, p.y); ctx.lineTo(i - 20, p.y + p.height);
            }
            ctx.stroke();

            // Detalles brillantes aleatorios (Luces de la plataforma)
            ctx.fillStyle = PALETTE.accent_cyan;
            for(let i=20; i<p.width; i+=100) {
                if (p.height > 20) { // Solo si es bloque grande
                    ctx.fillRect(p.x + i, p.y + 20, 6, 6);
                }
            }

            ctx.restore();
        });
    }

    // --- BUCLE PRINCIPAL ---
    let gameTime = 0;
    let camera = { x: 0, y: 0 };

    // Generar partículas de ambiente iniciales (Polvo)
    for(let i=0; i<50; i++) {
        particles.spawn(Math.random()*GAME_WIDTH, Math.random()*GAME_HEIGHT, 'dust', { color: '#ffaa55', size: Math.random()*2 });
    }

    function loop() {
        gameTime++;
        
        // Movimiento de cámara (Oscilación para demo)
        camera.x = Math.sin(gameTime * 0.005) * 250; 
        camera.y = Math.cos(gameTime * 0.01) * 20;

        // Actualizar
        player.update();
        walker.update();
        flyer.update();
        particles.update();

        // Spawn continuo de polvo
        if (Math.random() > 0.9) {
             particles.spawn(Math.random()*GAME_WIDTH + camera.x - 200, Math.random()*GAME_HEIGHT, 'dust', { color: 'rgba(255,200,100,0.3)', size: Math.random()*3 });
        }

        // Renderizar
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 1. Fondo Parallax
        drawBackground(ctx, camera.x, camera.y);
        
        // 2. Mundo de Juego
        ctx.save();
        ctx.translate(-camera.x + 200, 0); 

        drawMap(ctx);
        
        // Nota: En el demo original usabamos trucos de coords de pantalla.
        // Aquí usamos transformación normal para simplificar el dibujo de partículas en el mundo.
        // Para que el jugador siga la cámara en este demo visual (ya que no tiene input real):
        // Vamos a "empujar" visualmente al jugador para que se mantenga en encuadre si quieres
        // o simplemente dejar que la cámara se mueva sobre él. 
        // Para respetar el archivo original:
        
        ctx.restore(); // Reset mundo

        // Dibujamos entidades relativas a la pantalla para mantener el "Demo visual"
        // donde vemos todo el tiempo a los personajes
        let screenOffset = camera.x;
        
        ctx.save();
        // Hack visual para centrar personajes en pantalla mientras el fondo se mueve
        // Simulando que la cámara los sigue perfectamente
        // Pero dibujamos el MAPA también relativo a esto para que coincida con la colisión visual
        
        // Como drawMap usa coordenadas absolutas, limpiamos el área y redibujamos 
        // usando el offset de cámara para simular el scroll
        
        ctx.translate(0, 0); // Ya dibujamos el mapa "en el mundo" arriba? 
                             // No, arriba dibujamos mapa fijo en -camera.x.
                             // El problema es que el Player update cambia su X real.
        
        // RE-DIBUJO CORRECTO POR CAPAS:
        // Ya dibujamos el fondo. Ahora:
        
        ctx.save();
        ctx.translate(-camera.x + 200, 0); // Mover todo el mundo a la izquierda según la cámara
        
        // Plataformas (Detrás de personajes)
        drawMap(ctx); 
        
        // Partículas (Detrás de personajes)
        // (Ya implementado su propio draw con offset manual, lo llamamos aquí sin translate extra o ajustamos su draw)
        ctx.restore();
        
        particles.draw(ctx, camera.x); 

        ctx.save();
        ctx.translate(-camera.x + 200, 0); 
        // Personajes
        player.draw(ctx);
        walker.draw(ctx);
        flyer.draw(ctx);
        ctx.restore();

        // 3. Primer Plano (Foreground Layer)
        drawForeground(ctx, camera.x);

        // Efecto de neblina global suave (Atmósfera)
        let gradient = ctx.createRadialGradient(GAME_WIDTH/2, GAME_HEIGHT/2, 300, GAME_WIDTH/2, GAME_HEIGHT/2, 800);
        gradient.addColorStop(0, 'rgba(0,0,0,0)');
        gradient.addColorStop(1, 'rgba(50,10,0,0.4)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0,0,GAME_WIDTH, GAME_HEIGHT);

        ctx.restore();

        requestAnimationFrame(loop);
    }

    loop();

</script>
</body>
</html>