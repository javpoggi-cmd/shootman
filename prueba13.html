<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Shootman: High-Fidelity Visual Test</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #020202;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #game-container {
            position: relative;
            box-shadow: 0 0 80px rgba(0, 200, 255, 0.1);
            border: 1px solid #333;
            background: #000;
            width: 1280px;
            height: 720px;
        }
        canvas {
            display: block;
            background-color: #050508;
            width: 100%;
            height: 100%;
        }
        /* Efecto de viñeta y scanlines mejorados */
        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 100;
            background: 
                radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.8) 100%),
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.1) 3px);
            mix-blend-mode: overlay;
        }
        #noise {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 99;
            opacity: 0.05;
            background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMDAiIGhlaWdodD0iMjAwIj48ZmlsdGVyIGlkPSJnoiPjxmZVR1cmJ1bGVuY2UgdHlwZT0iZnJhY3RhbE5vaXNlIiBiYXNlRnJlcXVlbmN5PSIwLjY1IiBudW1PY3RhdmVzPSIzIiBzdGl0Y2hUaWxlcz0ic3RpdGNoIi8+PC9maWx0ZXI+PHJlY3Qgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgZmlsdGVyPSJ1cmwoI2cpIiBvcGFjaXR5PSIwLjUiLz48L3N2Zz4=');
        }
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 110;
            color: rgba(255, 255, 255, 0.8);
            text-transform: uppercase;
            letter-spacing: 2px;
            background: rgba(0, 10, 20, 0.8);
            border-left: 4px solid #00ffcc;
            padding: 15px;
            backdrop-filter: blur(4px);
        }
        h3 { margin: 0 0 5px 0; color: #00ffcc; font-size: 14px; }
        p { margin: 0; font-size: 11px; color: #aaa; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="mainCanvas"></canvas>
    <div id="noise"></div>
    <div id="overlay"></div>
    <div id="ui-layer">
        <h3>System Diagnostics</h3>
        <p>Render: High Fidelity</p>
        <p>Biome: Neo-Industrial Sector 7</p>
    </div>
</div>

<script>
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d', { alpha: false }); // Optimización
    const GAME_WIDTH = 1280; 
    const GAME_HEIGHT = 720;
    canvas.width = GAME_WIDTH; 
    canvas.height = GAME_HEIGHT;

    // --- PALETA DE COLORES "CYBER INDUSTRIAL" ---
    const PALETTE = {
        skyTop: '#020408',
        skyBottom: '#0e1521',
        neonBlue: '#00f3ff',
        neonRed: '#ff0055',
        neonOrange: '#ffaa00',
        metalDark: '#1a1c21',
        metalLight: '#3a3d45',
        fog: 'rgba(10, 15, 25, 0.4)'
    };

    // --- UTILIDADES GRÁFICAS ---
    function drawGlowingRect(ctx, x, y, w, h, color, blur = 10) {
        ctx.save();
        ctx.shadowBlur = blur;
        ctx.shadowColor = color;
        ctx.fillStyle = color;
        ctx.fillRect(x, y, w, h);
        ctx.restore();
    }

    // --- SISTEMA DE PARTÍCULAS ---
    class Particle {
        constructor(x, y, type) {
            this.x = x;
            this.y = y;
            this.type = type;
            this.life = 1.0;
            this.decay = Math.random() * 0.02 + 0.01;
            
            if (type === 'dust') {
                this.vx = Math.random() * 0.5 - 0.25;
                this.vy = Math.random() * 0.5 - 0.25;
                this.size = Math.random() * 2 + 1;
                this.color = 'rgba(200, 220, 255,';
            } else if (type === 'spark') {
                this.vx = Math.random() * 4 - 2;
                this.vy = Math.random() * -3 - 1;
                this.size = Math.random() * 2 + 1;
                this.color = 'rgba(255, 200, 50,';
                this.decay = 0.05;
            } else if (type === 'smoke') {
                this.vx = Math.random() * 1 - 0.5;
                this.vy = -1 - Math.random();
                this.size = Math.random() * 5 + 2;
                this.color = 'rgba(100, 100, 100,';
            }
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life -= this.decay;
        }
        draw(ctx) {
            ctx.fillStyle = this.color + this.life + ')';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    let particles = [];
    function spawnParticle(x, y, type, count = 1) {
        for(let i=0; i<count; i++) particles.push(new Particle(x, y, type));
    }

    // --- CLASES DEL JUEGO (REDDISEÑADAS) ---

    class MockPlayer {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 24; this.height = 40;
            this.vx = 0; 
            this.animTimer = 0;
            this.facingRight = true;
            this.state = 'wait';
            this.stateTimer = 0;
        }

        update() {
            this.animTimer++;
            this.stateTimer++;
            
            // Lógica simple original
            if (this.state === 'wait') {
                this.vx = 0;
                if (this.stateTimer > 60) {
                    this.state = Math.random() > 0.5 ? 'walk_right' : 'walk_left';
                    this.stateTimer = 0;
                }
            } else if (this.state === 'walk_right') {
                this.vx = 3; this.facingRight = true; this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
            } else if (this.state === 'walk_left') {
                this.vx = -3; this.facingRight = false; this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
            }
            if(this.x < 100) { this.x = 100; this.state = 'walk_right'; }
            if(this.x > 600) { this.x = 600; this.state = 'walk_left'; }

            // Partículas al caminar
            if (Math.abs(this.vx) > 0 && this.animTimer % 10 === 0) {
                spawnParticle(this.x + 12, this.y + 40, 'dust');
            }
        }

        draw(ctx) {
            ctx.save();
            // Transformación para dirección
            const centerX = this.x + this.width/2;
            ctx.translate(centerX, this.y);
            if (!this.facingRight) ctx.scale(-1, 1);
            ctx.translate(-12, 0); // Reset local coords centered

            // 1. Cuerpo / Armadura (Gradiente metálico)
            const bodyGrad = ctx.createLinearGradient(0, 0, 24, 40);
            bodyGrad.addColorStop(0, '#222');
            bodyGrad.addColorStop(0.5, '#444');
            bodyGrad.addColorStop(1, '#222');
            
            // Animación de bobbing
            const bob = Math.abs(this.vx) > 0 ? Math.sin(this.animTimer * 0.4) * 2 : 0;
            const legAngle = Math.abs(this.vx) > 0 ? Math.sin(this.animTimer * 0.4) * 0.5 : 0;

            // Pierna Trasera
            ctx.save();
            ctx.translate(8, 25);
            ctx.rotate(-legAngle);
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(-3, 0, 6, 15);
            ctx.fillStyle = '#555'; // Rodillera
            ctx.fillRect(-3, 5, 6, 2);
            ctx.restore();

            // Torso
            ctx.translate(0, bob);
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.moveTo(4, 5);
            ctx.lineTo(20, 5);
            ctx.lineTo(18, 25);
            ctx.lineTo(6, 25);
            ctx.fill();

            // Placas de armadura (Detalle)
            ctx.fillStyle = '#5a5e6b'; 
            ctx.fillRect(6, 8, 12, 6); // Pechera

            // Cabeza (Casco High Tech)
            ctx.fillStyle = '#333';
            ctx.fillRect(4, -2, 16, 14);
            // Visor Brillante
            ctx.shadowBlur = 10;
            ctx.shadowColor = PALETTE.neonOrange;
            ctx.fillStyle = PALETTE.neonOrange;
            ctx.fillRect(14, 2, 8, 3);
            ctx.shadowBlur = 0;

            // Arma (Futurista)
            ctx.fillStyle = '#111';
            ctx.fillRect(10, 12, 18, 6); // Main body
            ctx.fillStyle = '#444';
            ctx.fillRect(14, 11, 10, 2); // Top rail
            // Luz del arma
            ctx.fillStyle = PALETTE.neonBlue;
            ctx.fillRect(26, 13, 2, 4);

            // Pierna Delantera
            ctx.save();
            ctx.translate(16, 25); // Relativo al torso animado
            ctx.rotate(legAngle);
            ctx.fillStyle = '#333';
            ctx.fillRect(-3, 0, 6, 15);
            ctx.fillStyle = '#666'; // Rodillera
            ctx.fillRect(-3, 5, 6, 2);
            ctx.restore();

            // Mochila / Jetpack
            ctx.fillStyle = '#222';
            ctx.fillRect(-2, 2, 6, 12);
            // Luz de estatus
            ctx.fillStyle = PALETTE.neonBlue;
            ctx.fillRect(-1, 4, 2, 2);

            ctx.restore();
        }
    }

    class MockWalker {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 30; this.height = 30;
            this.vx = 2; this.dir = 1; this.timer = 0;
            this.state = 'walk'; this.startX = x;
            this.waitTimer = 0;
        }

        update() {
            this.timer++;
            if (this.state === 'walk') {
                this.x += this.vx;
                if (Math.abs(this.x - this.startX) > 150) {
                    this.state = 'wait'; this.waitTimer = 60;
                }
            } else if (this.state === 'wait') {
                this.waitTimer--;
                if (this.waitTimer <= 0) {
                    this.dir *= -1; this.vx = this.dir * 2; this.state = 'walk';
                }
            }
        }

        draw(ctx) {
            const centerX = this.x + 15;
            const centerY = this.y + 15;
            const anim = Math.sin(this.timer * 0.2);

            ctx.save();
            ctx.translate(centerX, centerY);
            
            // Cuerpo Principal (Bola mecánica)
            const grad = ctx.createRadialGradient(-5, -5, 2, 0, 0, 15);
            grad.addColorStop(0, '#555');
            grad.addColorStop(1, '#111');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(0, 0, 14, 0, Math.PI*2);
            ctx.fill();

            // Ojo de cíclope (Cylon style)
            ctx.fillStyle = '#000';
            ctx.fillRect(-10, -4, 20, 8);
            
            // Luz del ojo oscilante
            const eyeX = Math.sin(this.timer * 0.1) * 6;
            drawGlowingRect(ctx, eyeX - 2, -2, 4, 4, PALETTE.neonRed, 10);

            // Piernas mecánicas (Inverse Kinematics falsas)
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';

            // Pata 1
            ctx.beginPath();
            ctx.moveTo(-8, 8);
            ctx.lineTo(-12, 15 + anim * 3); // Rodilla
            ctx.lineTo(-15, 22); // Pie
            ctx.stroke();

            // Pata 2
            ctx.beginPath();
            ctx.moveTo(8, 8);
            ctx.lineTo(12, 15 - anim * 3); // Rodilla
            ctx.lineTo(15, 22); // Pie
            ctx.stroke();

            // Antena
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, -14);
            ctx.lineTo(0, -22);
            ctx.stroke();
            if (this.timer % 20 < 10) {
                ctx.fillStyle = PALETTE.neonRed;
                ctx.fillRect(-1, -24, 2, 2);
            }

            ctx.restore();
        }
    }

    class MockFlyer {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 30; this.height = 20;
            this.startX = x; this.timer = 0;
        }

        update() {
            this.timer++;
            this.x = this.startX + Math.sin(this.timer * 0.02) * 200;
            this.y += Math.cos(this.timer * 0.05) * 1;
            
            if (this.timer % 5 === 0) {
                spawnParticle(this.x + 15 + (Math.random()*10 - 5), this.y + 18, 'smoke');
            }
        }

        draw(ctx) {
            let hover = Math.sin(this.timer * 0.2) * 2;
            ctx.save();
            ctx.translate(this.x, this.y + hover);

            // Propulsores laterales
            ctx.fillStyle = '#222';
            ctx.fillRect(0, 5, 6, 10);
            ctx.fillRect(24, 5, 6, 10);

            // Llamas del motor (Oscilantes)
            ctx.fillStyle = 'rgba(0, 243, 255, 0.6)';
            let thrust = Math.random() * 5;
            ctx.fillRect(1, 15, 4, 5 + thrust);
            ctx.fillRect(25, 15, 4, 5 + thrust);

            // Cuerpo Central (Drone)
            ctx.fillStyle = '#4a4e59';
            ctx.beginPath();
            ctx.moveTo(6, 5);
            ctx.lineTo(24, 5);
            ctx.lineTo(20, 15);
            ctx.lineTo(10, 15);
            ctx.fill();

            // Cúpula superior
            ctx.fillStyle = '#111';
            ctx.beginPath();
            ctx.arc(15, 5, 6, Math.PI, 0);
            ctx.fill();

            // Luz de escáner
            drawGlowingRect(ctx, 13, 2, 4, 2, '#ff0055', 8);

            ctx.restore();
        }
    }

    // --- INSTANCIAS ---
    const player = new MockPlayer(200, 500);
    const walker = new MockWalker(800, 445);
    const flyer = new MockFlyer(600, 200);

    const platforms = [
        { x: -200, y: 540, width: 1800, height: 200 }, 
        { x: 750, y: 490, width: 400, height: 20 }
    ];

    // --- FONDO MEJORADO (PARALLAX COMPLEX) ---
    function drawBackground(ctx, cameraX, cameraY) {
        // Cielo degradado
        const grad = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
        grad.addColorStop(0, PALETTE.skyTop);
        grad.addColorStop(1, PALETTE.skyBottom);
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        // Estrellas / Polvo digital muy lejano
        ctx.fillStyle = '#fff';
        for(let i=0; i<50; i++) {
            if (i%3 === 0) { // Estáticas relativo al cielo
                ctx.fillRect(Math.random() * GAME_WIDTH, Math.random() * GAME_HEIGHT/2, 1, 1);
            }
        }

        const layers = [
            // Layer 0: Siluetas masivas lejanas (Casi negro)
            { speed: 0.05, color: '#05070a', heightMod: 600, width: 200, type: 'silhouette' },
            // Layer 1: Estructuras grandes con luces (Fábricas)
            { speed: 0.15, color: '#0f1218', heightMod: 450, width: 150, type: 'factory' },
            // Layer 2: Detalle medio (Tuberías y edificios)
            { speed: 0.30, color: '#161921', heightMod: 300, width: 250, type: 'pipes' },
            // Layer 3: Primer plano lejano (Estructuras oscuras)
            { speed: 0.50, color: '#1f232e', heightMod: 150, width: 300, type: 'structures' },
            // Layer 4: Postes o elementos muy cercanos pasando rápido
            { speed: 0.80, color: '#2a303d', heightMod: -50, width: 500, type: 'foreground' }
        ];

        layers.forEach((layer, index) => {
            ctx.save();
            
            // Neblina entre capas para profundidad (Volumetría)
            if (index > 0) {
                ctx.fillStyle = `rgba(5, 8, 15, ${0.1 + (index * 0.05)})`;
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            }

            let parallaxX = -cameraX * layer.speed;
            ctx.translate(parallaxX, 0);

            let totalW = layer.width;
            let startI = Math.floor(-parallaxX / totalW) - 1;
            let endI = startI + Math.ceil(GAME_WIDTH / totalW) + 2;

            for (let i = startI; i < endI; i++) {
                let seed = Math.sin(i * 452.1 + index * 92.2); // Semilla pseudo-aleatoria
                let h = layer.heightMod + (seed * 100);
                let x = i * totalW;
                let y = GAME_HEIGHT - h;

                ctx.fillStyle = layer.color;

                if (layer.type === 'silhouette') {
                    // Edificios monolíticos simples
                    ctx.beginPath();
                    ctx.moveTo(x, GAME_HEIGHT);
                    ctx.lineTo(x, y);
                    ctx.lineTo(x + totalW, y + (seed * 50));
                    ctx.lineTo(x + totalW, GAME_HEIGHT);
                    ctx.fill();
                } 
                else if (layer.type === 'factory') {
                    // Fábricas con chimeneas
                    ctx.fillRect(x + 10, y, totalW - 20, h);
                    // Chimeneas
                    if (seed > 0.5) {
                        ctx.fillRect(x + 20, y - 40, 10, 40);
                        // Humo de chimenea (simple visual)
                        ctx.fillStyle = 'rgba(255,255,255,0.05)';
                        ctx.beginPath(); ctx.arc(x+25, y-50, 10 + Math.random()*2, 0, Math.PI*2); ctx.fill();
                        ctx.fillStyle = layer.color;
                    }
                    // Luces rojas de advertencia
                    if (Math.abs(seed) > 0.7) {
                        ctx.fillStyle = `rgba(255, 0, 50, ${Math.abs(Math.sin(Date.now()*0.002))})`;
                        ctx.fillRect(x + totalW/2, y + 20, 4, 4);
                        ctx.fillStyle = layer.color;
                    }
                }
                else if (layer.type === 'pipes') {
                    // Bloques con tuberías conectadas
                    ctx.fillRect(x, y, totalW - 10, h);
                    ctx.strokeStyle = '#0a0c10';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(x - 20, y + 50);
                    ctx.lineTo(x + totalW + 20, y + 50); // Tubería horizontal
                    ctx.stroke();
                    // Ventanas industriales
                    ctx.fillStyle = '#080a0f';
                    ctx.fillRect(x + 20, y + 20, 20, 100);
                    ctx.fillStyle = layer.color;
                }
                else {
                    // Bloques genéricos detallados
                    ctx.fillRect(x, y, totalW, h);
                    // Grúas o antenas
                    if (seed > 0.8) {
                        ctx.strokeStyle = layer.color;
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(x + 20, y);
                        ctx.lineTo(x + 20, y - 50);
                        ctx.lineTo(x + 60, y - 80);
                        ctx.stroke();
                    }
                }
            }
            ctx.restore();
        });
    }

    function drawMap(ctx) {
        platforms.forEach(p => {
            // 1. Base Metálica
            const grad = ctx.createLinearGradient(p.x, p.y, p.x, p.y + p.height);
            grad.addColorStop(0, '#2a2d35');
            grad.addColorStop(1, '#15171c');
            ctx.fillStyle = grad;
            ctx.fillRect(p.x, p.y, p.width, p.height);

            // 2. Borde Superior (Hazard Stripes)
            ctx.save();
            ctx.beginPath();
            ctx.rect(p.x, p.y, p.width, 10);
            ctx.clip();
            ctx.fillStyle = '#222';
            ctx.fillRect(p.x, p.y, p.width, 10);
            
            // Franjas amarillas
            ctx.fillStyle = '#b8860b'; // Dark Gold
            for(let i=0; i<p.width; i+=20) {
                ctx.beginPath();
                ctx.moveTo(p.x + i, p.y + 10);
                ctx.lineTo(p.x + i + 10, p.y + 10);
                ctx.lineTo(p.x + i + 20, p.y);
                ctx.lineTo(p.x + i + 10, p.y);
                ctx.fill();
            }
            ctx.restore();

            // 3. Línea de neón bordeando la plataforma
            ctx.fillStyle = PALETTE.neonBlue;
            ctx.globalAlpha = 0.5;
            ctx.fillRect(p.x, p.y + 10, p.width, 1);
            ctx.globalAlpha = 1.0;

            // 4. Detalles de remaches y paneles
            ctx.fillStyle = '#111';
            for(let i=0; i<p.width; i+=50) {
                for(let j=20; j<p.height; j+=50) {
                   ctx.fillRect(p.x + i + 10, p.y + j, 4, 4); // Remaches
                   ctx.strokeStyle = '#222';
                   ctx.strokeRect(p.x + i, p.y + j - 10, 40, 40); // Paneles
                }
            }
        });
    }

    // --- VARIABLES DE CÁMARA & LOOP ---
    let gameTime = 0;
    let camera = { x: 0, y: 0 };

    function loop() {
        gameTime++;
        // Movimiento de cámara suave
        camera.x = Math.sin(gameTime * 0.005) * 300 + 100;
        
        // Updates
        player.update();
        walker.update();
        flyer.update();
        particles.forEach((p, index) => {
            p.update();
            if(p.life <= 0) particles.splice(index, 1);
        });
        
        // Spawn ambiente
        if(Math.random() > 0.9) spawnParticle(camera.x + Math.random()*GAME_WIDTH, Math.random()*GAME_HEIGHT, 'dust');

        // Render Background (Parallax real)
        drawBackground(ctx, camera.x, camera.y);

        // Render Escena de Juego
        ctx.save();
        
        // Truco visual del anterior: Entidades fijas en pantalla vs fondo móvil
        // En un juego real esto sería: ctx.translate(-camera.x, -camera.y);
        // Aquí mantenemos tu lógica de "personajes visibles siempre" pero ajustamos un poco
        // para que parezca que están en el escenario.
        
        let screenOffsetX = camera.x - 200; // Offset para centrar un poco

        // Dibujar mapa moviéndose (simulando que el jugador avanza)
        ctx.translate(-screenOffsetX, 0); 
        drawMap(ctx);
        
        // Dibujamos partículas en coordenadas del mundo
        particles.forEach(p => p.draw(ctx));

        // Para los personajes, como en tu ejemplo original los tenías fijos
        // vamos a dibujarlos en sus posiciones del mundo, que en este sistema coordinado
        // se moverán correctamente con el mapa.
        
        // SOMBRA DE PISO (Detalle extra)
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.beginPath();
        ctx.ellipse(player.x + 12, player.y + 38, 10, 3, 0, 0, Math.PI*2);
        ctx.fill();
        
        player.draw(ctx);
        walker.draw(ctx);
        flyer.draw(ctx);

        // Capa de neblina frontal (Atmósfera)
        ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform para overlay pantalla
        const fogGrad = ctx.createLinearGradient(0, GAME_HEIGHT-100, 0, GAME_HEIGHT);
        fogGrad.addColorStop(0, 'rgba(0,0,0,0)');
        fogGrad.addColorStop(1, 'rgba(0,10,20,0.3)');
        ctx.fillStyle = fogGrad;
        ctx.fillRect(0, GAME_HEIGHT-100, GAME_WIDTH, 100);

        ctx.restore();

        requestAnimationFrame(loop);
    }

    loop();

</script>
</body>
</html>