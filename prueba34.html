<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Shootman: Nivel Montañas Opresivas (Mejorado)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #020103;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #game-container {
            position: relative;
            box-shadow: 0 0 60px rgba(100, 0, 20, 0.3);
            border: 4px solid #2a1a1a;
            background: #000;
            width: 1280px;
            height: 720px;
        }
        canvas {
            display: block;
            background-color: #15051a;
            image-rendering: pixelated;
            width: 100%;
            height: 100%;
        }
        #scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(10, 0, 0, 0) 50%, rgba(0, 0, 0, 0.2) 50%);
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 100;
            opacity: 0.3;
            mix-blend-mode: overlay;
        }
        #vignette {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(0,0,0,0) 50%, rgba(20,5,10,0.8) 100%);
            pointer-events: none;
            z-index: 99;
        }
        #debug-ui {
            position: absolute; top: 10px; left: 10px; color: #cc8888; z-index: 101;
            background: rgba(0,0,0,0.8); padding: 15px;
            border-left: 4px solid #aa2222;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="scanlines"></div>
    <div id="vignette"></div>
    <div id="debug-ui">
        <h3>NIVEL 2: CUMBRES DE SANGRE</h3>
        <p>Personajes: Originales</p>
        <p>Fondo: Parallax Dinámico</p>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    const GAME_WIDTH = 1280; 
    const GAME_HEIGHT = 720;
    canvas.width = GAME_WIDTH; 
    canvas.height = GAME_HEIGHT;

    // --- PALETA DRAMÁTICA ---
    const PALETTE = {
        skyTop: '#1a0526',       
        skyBottom: '#6a1e2e',    
        sun: '#aa3333',          
        
        // Capas de fondo
        layer1: '#220a15',       
        layer2: '#331122',       
        layer3: '#441a2a',       
        
        // Terreno Jugable
        groundLight: '#5e4b35',  
        groundDark: '#0f0505',   
        grassBase: '#2d3e1e',    
        grassTip: '#5d6e38',     
        stone: '#4a4a55'         
    };

    // Colores para las entidades
    const COLORS = { 
        player: '#cccccc', 
        playerAccent: '#ffaa00', 
        bullet: '#00ffaa', 
        enemyBullet: '#ff4444', 
        weapon: '#00ff00',
        enemyBase: '#aa3333'
    };
    const ENEMY_COLOR = '#aa3333';

    // --- VARIABLES GLOBALES ---
    let gameTime = 0;
    let camera = { x: 0, y: 0 };

    // --- CLASES ---

    class MockPlayer {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 24; this.height = 40;
            this.vx = 0; 
            this.animTimer = 0;
            this.facingRight = true;
            this.state = 'wait'; 
            this.stateTimer = 0;
        }

        update() {
            this.animTimer++;
            this.stateTimer++;

            if (this.state === 'wait') {
                this.vx = 0;
                if (this.stateTimer > 60) { 
                    this.state = Math.random() > 0.5 ? 'walk_right' : 'walk_left';
                    this.stateTimer = 0;
                }
            } else if (this.state === 'walk_right') {
                this.vx = 3;
                this.facingRight = true;
                this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
            } else if (this.state === 'walk_left') {
                this.vx = -3;
                this.facingRight = false;
                this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
            }
            
            if(this.x < 100) { this.x = 100; this.state = 'walk_right'; }
            if(this.x > 800) { this.x = 800; this.state = 'walk_left'; }
        }

        draw(ctx) {
            ctx.save(); ctx.fillStyle = COLORS.player;
            let lean = 0; if (Math.abs(this.vx) > 1) lean = this.facingRight ? 3 : -3; 
            ctx.translate(lean, 0);
            
            if (Math.abs(this.vx) > 0.5) {
                let cycle = Math.sin(this.animTimer * 0.5);
                ctx.fillRect(this.x + 4, this.y + 25, 6, 15 + cycle * 3); 
                ctx.fillRect(this.x + 14, this.y + 25, 6, 15 - cycle * 3);
            } else { 
                ctx.fillRect(this.x + 4, this.y + 25, 6, 15); 
                ctx.fillRect(this.x + 14, this.y + 25, 6, 15); 
            }
            
            ctx.fillStyle = '#eee'; 
            ctx.fillRect(this.x, this.y + 10, this.width, 18);
            ctx.fillStyle = '#55a'; 
            ctx.fillRect(this.facingRight ? this.x - 4 : this.x + 20, this.y + 12, 4, 10); 
            ctx.fillStyle = '#222'; ctx.fillRect(this.x + 2, this.y, 20, 12); 
            ctx.fillStyle = COLORS.playerAccent; ctx.fillRect(this.facingRight ? this.x + 12 : this.x + 2, this.y + 3, 10, 4); 

            ctx.fillStyle = '#555';
            let gunX = this.facingRight ? this.x + 14 : this.x - 6; 
            let gunY = this.y + 14;
            ctx.fillRect(gunX, gunY, 16, 6);
            ctx.restore();
        }
    }

    class MockWalker {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 30; this.height = 30;
            this.vx = 2;
            this.dir = 1;
            this.timer = 0;
            this.state = 'walk';
            this.startX = x;
            this.waitTimer = 0;
        }

        update() {
            this.timer++;
            if (this.state === 'walk') {
                this.x += this.vx;
                if (Math.abs(this.x - this.startX) > 150) {
                    this.state = 'wait';
                    this.waitTimer = 60;
                }
            } else if (this.state === 'wait') {
                this.waitTimer--;
                if (this.waitTimer <= 0) {
                    this.dir *= -1;
                    this.vx = this.dir * 2;
                    this.state = 'walk';
                }
            }
        }

        draw(ctx) {
            ctx.fillStyle = ENEMY_COLOR;
            let anim = Math.sin(this.timer * 0.2);
            let drawY = this.y - 10; 
            
            ctx.fillRect(this.x, drawY, this.width, this.height);
            ctx.fillStyle = '#fff'; ctx.fillRect(this.x + 10, drawY + 5, 10, 10); 
            ctx.fillStyle = '#f00'; ctx.fillRect(this.x + 13, drawY + 8, 4, 4);
            
            ctx.fillStyle = ENEMY_COLOR; 
            ctx.save(); ctx.translate(this.x + 5, drawY + 15); ctx.rotate(anim); ctx.fillRect(0, 0, 5, 15); ctx.restore();
            ctx.save(); ctx.translate(this.x + 25, drawY + 15); ctx.rotate(-anim); ctx.fillRect(0, 0, 5, 15); ctx.restore();
            
            ctx.fillRect(this.x + 5, drawY + 30, 5, 10 + anim * 5); 
            ctx.fillRect(this.x + 20, drawY + 30, 5, 10 - anim * 5);
        }
    }

    class MockFlyer {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 30; this.height = 20;
            this.startX = x;
            this.timer = 0;
        }

        update() {
            this.timer++;
            this.x = this.startX + Math.sin(this.timer * 0.02) * 200;
            this.y += Math.cos(this.timer * 0.05) * 1; 
        }

        draw(ctx) {
            let flap = Math.sin(this.timer * 0.8) * 10;
            ctx.fillStyle = ENEMY_COLOR;
            ctx.fillRect(this.x, this.y, 30, 20); 
            
            ctx.fillStyle = '#777'; 
            ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x - 10, this.y - 10 + flap); ctx.lineTo(this.x + 10, this.y); ctx.fill();
            ctx.beginPath(); ctx.moveTo(this.x + 30, this.y); ctx.lineTo(this.x + 40, this.y - 10 + flap); ctx.lineTo(this.x + 20, this.y); ctx.fill(); 
            ctx.fillStyle = '#ff0'; ctx.fillRect(this.x + 10, this.y + 5, 10, 5);
        }
    }

    // --- GENERACIÓN DE TERRENO ---
    
    function createJaggedPlatform(x, y, w, h) {
        let points = [];
        let currentX = 0;
        let currentY = 0;
        points.push({x: 0, y: 0});

        while(currentX < w) {
            let segmentLen = 30 + Math.random() * 50;
            if (currentX + segmentLen > w) segmentLen = w - currentX;
            let type = Math.random();
            if (type > 0.6) {
                let slope = (Math.random() * 30) - 15; 
                currentX += segmentLen;
                currentY += slope;
            } else {
                currentX += segmentLen;
                currentY += (Math.random() * 4) - 2; 
            }
            points.push({x: currentX, y: currentY});
        }
        points.push({x: w, y: 0}); 
        points.push({x: w + (Math.random()*20 - 10), y: h/3});
        points.push({x: w - (Math.random()*30), y: h});
        let segmentsBot = 5;
        for(let i=segmentsBot-1; i>0; i--) {
            points.push({
                x: (w/segmentsBot)*i + (Math.random()*20), 
                y: h + (Math.random()*30)
            });
        }
        points.push({x: 0 + (Math.random()*20), y: h});
        return { x, y, w, h, points, type: 'ground' };
    }

    const platforms = [
        createJaggedPlatform(-100, 550, 1000, 300), 
        createJaggedPlatform(950, 480, 500, 400),   
        createJaggedPlatform(750, 400, 180, 150),   
        createJaggedPlatform(400, 250, 150, 100)    
    ];

    const bigStones = [
        { x: 150, y: 570, w: 60, h: 80, angle: -0.1 },
        { x: 800, y: 430, w: 40, h: 50, angle: 0.2 }, 
        { x: 1050, y: 530, w: 100, h: 120, angle: 0.05 } 
    ];

    const particles = Array.from({length: 60}, () => ({
        x: Math.random() * GAME_WIDTH,
        y: Math.random() * GAME_HEIGHT,
        speed: Math.random() * 0.5 + 0.2,
        size: Math.random() * 2,
        off: Math.random() * 100
    }));

    const player = new MockPlayer(200, 500);
    const walker = new MockWalker(900, 450);
    const flyer = new MockFlyer(600, 200);

    // --- RENDERIZADO ---

    function drawSky(ctx) {
        let grad = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
        grad.addColorStop(0, PALETTE.skyTop);
        grad.addColorStop(0.7, PALETTE.skyBottom);
        grad.addColorStop(1, '#220a11'); 
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        ctx.save();
        ctx.translate(GAME_WIDTH * 0.7, GAME_HEIGHT * 0.2);
        let sunGrad = ctx.createRadialGradient(0, 0, 20, 0, 0, 80);
        sunGrad.addColorStop(0, PALETTE.sun);
        sunGrad.addColorStop(0.4, 'rgba(170, 50, 50, 0.2)');
        sunGrad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = sunGrad;
        ctx.beginPath(); ctx.arc(0, 0, 80, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = PALETTE.sun;
        ctx.beginPath(); ctx.arc(0, 0, 25, 0, Math.PI*2); ctx.fill();
        ctx.restore();
    }

    // MODIFICADO: Añadido parámetro offsetRandom
    function drawParallaxLayer(ctx, camX, camY, color, speed, type, offsetRandom = 0) {
        ctx.save();
        
        // Aplicamos el offset al cálculo de la posición de cámara efectiva para esta capa
        let currentCamX = (camX * speed) + offsetRandom;
        
        // Translación inversa para dibujar
        ctx.translate(-currentCamX, -camY * speed * 0.2);
        
        ctx.fillStyle = color;
        
        const shapeWidth = 400; // Mantiene la forma original (no tocar para evitar deformación)
    const spacing = 380;    // DISTANCIA: 250px entre dibujos (antes era 400). 
                            // Pon un número MENOR para juntarlos más (ej. 150 para bosque denso).
                            // Pon un número MAYOR para separarlos.

    // Calculamos startI usando 'spacing' para saber cuántos entran en pantalla
    const startI = Math.floor(currentCamX / spacing) - 1;
    const endI = startI + (GAME_WIDTH / spacing) + 3;

    for (let i = startI; i < endI; i++) {
        let x = i * spacing; // La posición X depende del ESPACIADO
        
        // El resto de cálculos de altura se mantienen igual
        let h1 = Math.sin(i * 132.1) * 100 + 200; 
        let h2 = Math.sin(i * 45.6) * 80 + 200;
        
        if (type === 'forest') {
            let baseH = GAME_HEIGHT - 250; 
            if (type === 'front_forest') baseH = GAME_HEIGHT + 50;
            
            let isFlipped = (i % 2 !== 0);

            ctx.beginPath();
            ctx.moveTo(x, GAME_HEIGHT); 

            for (let t = 0; t < 10; t++) {
                let tParam = isFlipped ? (9 - t) : t; 
                
                // AQUÍ ES LA CLAVE: Usamos shapeWidth para dibujar el árbol
                // así mantiene su proporción independientemente de dónde esté posicionado
                let tx = x + (t * (shapeWidth/10)); 
                
                let th = (Math.sin(i * 99 + tParam * 12) * 40) + 80; 
                ctx.lineTo(tx + 10, baseH - th);
                ctx.lineTo(tx + 20, baseH + 10);
            }
            
            // Usamos shapeWidth para cerrar el dibujo
            ctx.lineTo(x + shapeWidth, GAME_HEIGHT); 
            ctx.fill();
        } else {
            // Montañas lejanas
            let baseH = GAME_HEIGHT - (type === 'far' ? 270 : 0);
            ctx.beginPath();
            ctx.moveTo(x, GAME_HEIGHT);
            
            // Usamos shapeWidth para dibujar la montaña
            ctx.lineTo(x, baseH - h1);
            ctx.lineTo(x + shapeWidth * 0.5, baseH - h2 - 50);
            ctx.lineTo(x + shapeWidth, baseH - (Math.sin((i+1)*132.1)*100 + 200));
            
            ctx.lineTo(x + shapeWidth, GAME_HEIGHT);
            ctx.fill();
        }
    }
        ctx.restore();
    }

    function drawPlatformShape(ctx, p) {
        ctx.translate(p.x, p.y);
        
        let grad = ctx.createLinearGradient(0, 0, 0, p.h);
        grad.addColorStop(0, PALETTE.groundLight);
        grad.addColorStop(0.5, PALETTE.groundDark);
        grad.addColorStop(1, '#000000');
        
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.moveTo(p.points[0].x, p.points[0].y);
        for(let pt of p.points) ctx.lineTo(pt.x, pt.y);
        ctx.closePath();
        ctx.fill();

        ctx.strokeStyle = 'rgba(0,0,0,0.4)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for(let i=0; i<p.w; i+=60) {
            ctx.moveTo(i, 30);
            ctx.lineTo(i + 20, 60 + Math.random()*10);
        }
        ctx.stroke();

        ctx.fillStyle = PALETTE.grassBase;
        for (let i = 0; i < p.points.length - 3; i++) {
            let p1 = p.points[i];
            let p2 = p.points[i+1];
            let dist = Math.abs(p2.x - p1.x);
            if (dist > 0) {
                for(let k=0; k<dist; k+=4) {
                    let t = k/dist;
                    let px = p1.x + (p2.x - p1.x) * t;
                    let py = p1.y + (p2.y - p1.y) * t;
                    
                    let grassH = (Math.sin(px * 0.5) * 4) + 8; 
                    let tipColor = Math.sin(px * 0.1) > 0 ? PALETTE.grassTip : PALETTE.grassBase;

                    ctx.fillStyle = PALETTE.grassBase;
                    ctx.fillRect(px, py - grassH + 2, 3, grassH);
                    ctx.fillStyle = tipColor;
                    ctx.fillRect(px, py - grassH, 3, 3);
                }
            }
        }
        ctx.translate(-p.x, -p.y);
    }

    function drawBigStone(ctx, s) {
        ctx.save();
        ctx.translate(s.x, s.y);
        ctx.rotate(s.angle);
        
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(-5, s.h-10, s.w+10, 15);

        ctx.fillStyle = PALETTE.stone;
        ctx.beginPath();
        ctx.moveTo(10, 0);
        ctx.lineTo(s.w-10, 5);
        ctx.lineTo(s.w, s.h);
        ctx.lineTo(0, s.h);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        ctx.beginPath();
        ctx.moveTo(0, s.h); ctx.lineTo(10, 0); ctx.lineTo(20, 0); ctx.lineTo(10, s.h);
        ctx.fill();
        
        ctx.fillStyle = '#222';
        ctx.fillRect(20, 30, s.w-40, 2);
        ctx.fillRect(30, 50, s.w-60, 2);

        ctx.restore();
    }

    function loop() {
        gameTime++;
        
        let cinematicCam = Math.sin(gameTime * 0.004) * 300 + 200;
        
        player.update();
        walker.update();
        flyer.update();

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 1. FONDO
        drawSky(ctx);
        // Capas con OFFSET RANDOM añadido al final (0, 120, 550, 900) para desincronizar
        drawParallaxLayer(ctx, cinematicCam, 0, PALETTE.layer1, 0.05, 'far', 0);
        drawParallaxLayer(ctx, cinematicCam, 5000, PALETTE.layer2, 0.15, 'mid', 120);
        // Capas Forest (las que pediste modificar)
        drawParallaxLayer(ctx, cinematicCam, 1250, '#260e17', 0.30, 'forest', 550);
        drawParallaxLayer(ctx, cinematicCam, 0, '#441a2a', 0.45, 'forest', 900);
        drawParallaxLayer(ctx, cinematicCam, - 500, '#752e49', 0.60, 'forest', 1200);
        

        ctx.fillStyle = 'rgba(50, 20, 30, 0.3)';
        ctx.fillRect(0, GAME_HEIGHT - 200, GAME_WIDTH, 200);

        // 2. MUNDO DE JUEGO
        ctx.save();
        ctx.translate(-cinematicCam + 200, 0); 

        bigStones.forEach(s => drawBigStone(ctx, s));
        platforms.forEach(p => drawPlatformShape(ctx, p));

        player.draw(ctx);
        walker.draw(ctx);
        flyer.draw(ctx);

        ctx.fillStyle = '#aa8888';
        particles.forEach(p => {
            p.x += p.speed;
            p.y += Math.sin((gameTime + p.off) * 0.05) * 0.5;
            if (p.x > GAME_WIDTH) p.x = -10;
            
            let screenX = p.x - (cinematicCam * 0.8 % GAME_WIDTH); 
            if (screenX < 0) screenX += GAME_WIDTH;
            
            ctx.globalAlpha = Math.abs(Math.sin(gameTime * 0.02 + p.off));
            ctx.fillRect(screenX, p.y, p.size, p.size);
        });
        ctx.globalAlpha = 1;

        ctx.restore(); 

        // 3. PRIMER PLANO (Siluetas)
        // También desfazado ligeramente
        drawParallaxLayer(ctx, cinematicCam, -600, '#1c0110', 1.2, 'forest', 230);
        drawParallaxLayer(ctx, cinematicCam, -700, '#050002', 1.6, 'forest', 0);  

        requestAnimationFrame(loop);
    }

    loop();

</script>
</body>
</html>