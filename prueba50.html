<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Shootman: Nivel 2 - Zona Industrial</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #game-container {
            position: relative;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.9);
            border: 4px solid #2a2a2a;
            background: #000;
            width: 1280px;
            height: 720px;
        }
        canvas {
            display: block;
            background-color: #0f1010;
            image-rendering: pixelated;
            width: 100%;
            height: 100%;
        }
        #scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(0, 0, 0, 0) 50%, rgba(0, 0, 0, 0.2) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03));
            background-size: 100% 4px, 6px 100%;
            pointer-events: none;
            z-index: 10;
            opacity: 0.6;
        }
        #vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(10, 8, 0, 0.6) 100%);
            pointer-events: none;
            z-index: 11;
        }
        #debug-ui {
            position: absolute; top: 10px; left: 10px; color: #ffcc00; z-index: 20;
            background: rgba(20, 15, 0, 0.8); padding: 10px;
            border: 1px solid #554400;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="testCanvas"></canvas>
    <div id="scanlines"></div>
    <div id="vignette"></div>
    <div id="debug-ui">
        <h3>NIVEL 2: ZONA PESADA</h3>
        <p>Bioma: CIUDAD INDUSTRIAL</p>
        <p>Clima: LLUVIA ÁCIDA</p>
    </div>
</div>

<script>
    const canvas = document.getElementById('testCanvas');
    const ctx = canvas.getContext('2d');
    const GAME_WIDTH = 1280; 
    const GAME_HEIGHT = 720;
    canvas.width = GAME_WIDTH; 
    canvas.height = GAME_HEIGHT;

    // --- PALETA DE COLORES (Evolución de la original: Más óxido, menos negro absoluto) ---
    const COLORS = { 
        player: '#e0e0e0', 
        playerAccent: '#ffaa00', 
        bullet: '#00ffaa', 
        enemyBullet: '#ff4444', 
        weapon: '#00ff00' 
    };
    
    const BIOME = { 
        skyTop: '#050505',
        skyBot: '#1a1815', // Horizonte marrón sucio
        fog: 'rgba(20, 18, 15, 0.5)', // Niebla marrón/gris
        // Capas de fondo: Degradado de negros a grises oxidados
        layers: ['#080808', '#101010', '#181616', '#201e1e', '#292624', '#332f2d'], 
        ground: '#2a2826', 
        groundTop: '#4a443e',
        windowOn: '#ffcc66', // Luz de sodio (amarilla)
        windowDim: '#cc8844', // Luz tenue
        windowOff: '#151210'
    };
    
    const ENEMY_COLOR = '#cc4444';

    // --- CLASES SIMULADAS (ORIGINALES INTACTAS) ---
    class MockPlayer {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 24; this.height = 40;
            this.vx = 0; this.animTimer = 0;
            this.facingRight = true; this.state = 'wait'; this.stateTimer = 0;
        }
        update() {
            this.animTimer++; this.stateTimer++;
            if (this.state === 'wait') {
                this.vx = 0;
                if (this.stateTimer > 60) { this.state = Math.random() > 0.5 ? 'walk_right' : 'walk_left'; this.stateTimer = 0; }
            } else if (this.state === 'walk_right') {
                this.vx = 3; this.facingRight = true; this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
            } else if (this.state === 'walk_left') {
                this.vx = -3; this.facingRight = false; this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
            }
            if(this.x < 100) { this.x = 100; this.state = 'walk_right'; }
            if(this.x > 600) { this.x = 600; this.state = 'walk_left'; }
        }
        draw(ctx) {
            ctx.save(); ctx.fillStyle = COLORS.player;
            let lean = 0; if (Math.abs(this.vx) > 1) lean = this.facingRight ? 3 : -3; 
            ctx.translate(lean, 0);
            if (Math.abs(this.vx) > 0.5) {
                let cycle = Math.sin(this.animTimer * 0.5);
                ctx.fillRect(this.x + 4, this.y + 25, 6, 15 + cycle * 3); 
                ctx.fillRect(this.x + 14, this.y + 25, 6, 15 - cycle * 3);
            } else { 
                ctx.fillRect(this.x + 4, this.y + 25, 6, 15); ctx.fillRect(this.x + 14, this.y + 25, 6, 15); 
            }
            ctx.fillStyle = '#fff'; ctx.fillRect(this.x, this.y + 10, this.width, 18);
            ctx.fillStyle = '#55f'; ctx.fillRect(this.facingRight ? this.x - 4 : this.x + 20, this.y + 12, 4, 10); 
            ctx.fillStyle = '#333'; ctx.fillRect(this.x + 2, this.y, 20, 12); 
            ctx.fillStyle = COLORS.playerAccent; ctx.fillRect(this.facingRight ? this.x + 12 : this.x + 2, this.y + 3, 10, 4); 
            ctx.fillStyle = '#555';
            let gunX = this.facingRight ? this.x + 14 : this.x - 6; let gunY = this.y + 14;
            ctx.fillRect(gunX, gunY, 16, 6);
            ctx.restore();
        }
    }

    class MockWalker {
        constructor(x, y) {
            this.x = x; this.y = y; this.width = 30; this.height = 30;
            this.vx = 2; this.dir = 1; this.timer = 0; this.state = 'walk'; this.startX = x;
        }
        update() {
            this.timer++;
            if (this.state === 'walk') {
                this.x += this.vx;
                if (Math.abs(this.x - this.startX) > 150) { this.state = 'wait'; this.waitTimer = 60; }
            } else if (this.state === 'wait') {
                this.waitTimer--;
                if (this.waitTimer <= 0) { this.dir *= -1; this.vx = this.dir * 2; this.state = 'walk'; }
            }
        }
        draw(ctx) {
            ctx.fillStyle = ENEMY_COLOR;
            let anim = Math.sin(this.timer * 0.2);
            let drawY = this.y - 10; 
            ctx.fillRect(this.x, drawY, this.width, this.height);
            ctx.fillStyle = '#fff'; ctx.fillRect(this.x + 10, drawY + 5, 10, 10); 
            ctx.fillStyle = '#f00'; ctx.fillRect(this.x + 13, drawY + 8, 4, 4);
            ctx.fillStyle = ENEMY_COLOR; 
            ctx.save(); ctx.translate(this.x + 5, drawY + 15); ctx.rotate(anim); ctx.fillRect(0, 0, 5, 15); ctx.restore();
            ctx.save(); ctx.translate(this.x + 25, drawY + 15); ctx.rotate(-anim); ctx.fillRect(0, 0, 5, 15); ctx.restore();
            ctx.fillRect(this.x + 5, drawY + 30, 5, 10 + anim * 5); 
            ctx.fillRect(this.x + 20, drawY + 30, 5, 10 - anim * 5);
        }
    }

    class MockFlyer {
        constructor(x, y) {
            this.x = x; this.y = y; this.width = 30; this.height = 20; this.startX = x; this.timer = 0;
        }
        update() {
            this.timer++;
            this.x = this.startX + Math.sin(this.timer * 0.02) * 200;
            this.y += Math.cos(this.timer * 0.05) * 1; 
        }
        draw(ctx) {
            let flap = Math.sin(this.timer * 0.8) * 10;
            ctx.fillStyle = ENEMY_COLOR;
            ctx.fillRect(this.x, this.y, 30, 20); 
            ctx.fillStyle = '#777'; 
            ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x - 10, this.y - 10 + flap); ctx.lineTo(this.x + 10, this.y); ctx.fill();
            ctx.beginPath(); ctx.moveTo(this.x + 30, this.y); ctx.lineTo(this.x + 40, this.y - 10 + flap); ctx.lineTo(this.x + 20, this.y); ctx.fill(); 
            ctx.fillStyle = '#ff0'; ctx.fillRect(this.x + 10, this.y + 5, 10, 5);
        }
    }

    // --- PARTICULAS SIMPLES (LLUVIA SUITL) ---
    let rain = [];
    for(let i=0; i<100; i++) {
        rain.push({ x: Math.random() * GAME_WIDTH, y: Math.random() * GAME_HEIGHT, s: 2 + Math.random() * 4 });
    }

    // --- ESCENARIO ---
    const player = new MockPlayer(200, 500);
    const walker = new MockWalker(800, 450);
    const flyer = new MockFlyer(600, 200);

    const platforms = [
        { x: 0, y: 540, width: 800, height: 200 },
        { x: 750, y: 490, width: 400, height: 20 }
    ];

    // --- DIBUJO DE FONDO (Mejorado pero fiel al algoritmo original) ---
    function drawBackground(ctx, cameraX, cameraY) {
        // Cielo degradado sucio
        let skyGrad = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
        skyGrad.addColorStop(0, BIOME.skyTop);
        skyGrad.addColorStop(1, BIOME.skyBot);
        ctx.fillStyle = skyGrad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // CONFIGURACIÓN DE LAS 6 CAPAS DE PARALLAX
        // Mismo algoritmo de "bucle" que el original, pero con 6 capas ajustadas
        const layersConfig = [
            { speed: 0.02, color: BIOME.layers[0], heightMod: 600, width: 400, gap: 0, type: 'skyline' }, 
            { speed: 0.05, color: BIOME.layers[1], heightMod: 500, width: 200, gap: 10, type: 'buildings_far' }, 
            { speed: 0.10, color: BIOME.layers[2], heightMod: 400, width: 150, gap: 20, type: 'buildings_mid' }, 
            { speed: 0.20, color: BIOME.layers[3], heightMod: 300, width: 180, gap: 30, type: 'buildings_mid' },
            { speed: 0.40, color: BIOME.layers[4], heightMod: 150, width: 220, gap: 50, type: 'industrial_close' },
            { speed: 0.60, color: BIOME.layers[5], heightMod: 50, width: 250, gap: 80, type: 'industrial_very_close' }
        ];
        
        layersConfig.forEach((layer, index) => {
            ctx.save(); 
            let parallaxX = -cameraX * layer.speed; 
            ctx.translate(parallaxX, 0);
            
            let totalW = layer.width + layer.gap; 
            let startI = Math.floor(-parallaxX / totalW) - 2; 
            let endI = startI + Math.ceil(GAME_WIDTH / totalW) + 5;
            
            for (let i = startI; i < endI; i++) {
                let pseudoRandom = Math.sin(i * 134.5 + index * 12.1); 
                let h = layer.heightMod + (pseudoRandom * 150 + 100); 
                let x = i * totalW; 
                let y = GAME_HEIGHT - h;
                
                // Base del edificio
                ctx.fillStyle = layer.color; 
                ctx.fillRect(x, y, layer.width, h + 1000);

                // Textura sutil en edificio (Ruido)
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                if (i % 2 === 0) ctx.fillRect(x, y, layer.width/2, h+1000);

                // --- VENTANAS (ALGORITMO ORIGINAL MEJORADO) ---
                // Usamos la misma lógica de distribución para que "parezca el mismo juego"
                // Solo agregamos ventanas en capas medias y cercanas
                if (index > 1 && Math.abs(pseudoRandom) > 0.2) {
                    let wins = Math.abs(Math.floor(pseudoRandom * 5)) + 1;
                    for (let w = 0; w < wins; w++) {
                        for (let wh = 0; wh < 20; wh++) { // Más altura
                            if ((i + wh) % 3 === 0) continue; // Espaciado original
                            
                            // Calculamos estado de la ventana
                            let winState = Math.sin(i * 45.5 + w * 12.1 + wh * 6.7);
                            
                            if (winState > 0.3) { 
                                // Colores ajustados a la paleta industrial (amarillo/naranja)
                                if (winState > 0.8) ctx.fillStyle = BIOME.windowOn; 
                                else if (winState > 0.6) ctx.fillStyle = BIOME.windowDim; 
                                else ctx.fillStyle = BIOME.windowOff; 
                                
                                // Dibujar Ventana
                                let wx = x + 10 + w * 20;
                                let wy = y + 50 + wh * 30;
                                
                                // Marco de ventana (detalle extra sutil)
                                ctx.fillRect(wx, wy, 8, 14);
                                
                                // Brillo bajo la ventana (efecto de luz en la pared)
                                if(winState > 0.8) {
                                    ctx.fillStyle = 'rgba(255, 200, 100, 0.05)';
                                    ctx.fillRect(wx - 2, wy + 14, 12, 10);
                                }
                            }
                        }
                    }
                }

                // --- DETALLES INDUSTRIALES EXTRA (Solo capas cercanas) ---
                if (index >= 4) {
                    // Tuberías laterales
                    ctx.fillStyle = '#111';
                    ctx.fillRect(x - 5, y + 20, 10, h);
                    
                    // Luces rojas de balizamiento aéreo
                    if (i % 3 === 0) {
                        ctx.fillStyle = '#aa0000';
                        let blink = Math.sin(gameTime * 0.1 + i) > 0 ? 1 : 0.3;
                        ctx.globalAlpha = blink;
                        ctx.fillRect(x + layer.width/2 - 2, y - 4, 4, 4);
                        ctx.globalAlpha = 1.0;
                    }
                }
            }
            ctx.restore();
        });
    }

    // --- NUEVA FUNCIÓN DE MAPA CON DECORACIÓN DETALLADA ---
    function drawMap(ctx) {
        platforms.forEach(p => {
            // 1. Cuerpo Principal (Textura metálica pesada)
            let grad = ctx.createLinearGradient(p.x, p.y, p.x, p.y + p.height);
            grad.addColorStop(0, BIOME.groundTop);
            grad.addColorStop(1, BIOME.ground);
            ctx.fillStyle = grad; 
            ctx.fillRect(p.x, p.y, p.width, p.height);
            
            // 2. Borde superior reforzado
            ctx.fillStyle = '#5a544e'; 
            ctx.fillRect(p.x, p.y, p.width, 8);
            
            // 3. Patrón de rayas de advertencia (Industrial) en el borde
            ctx.fillStyle = '#111';
            for(let sx = p.x; sx < p.x + p.width; sx += 20) {
                ctx.beginPath();
                ctx.moveTo(sx, p.y);
                ctx.lineTo(sx + 5, p.y);
                ctx.lineTo(sx - 5, p.y + 8);
                ctx.lineTo(sx - 10, p.y + 8);
                ctx.fill();
            }

            // 4. OBJETOS DECORATIVOS (Sobre la plataforma)
            
            // A. Barandillas de seguridad (Fondo)
            ctx.fillStyle = '#333';
            for(let bx = p.x + 10; bx < p.x + p.width - 10; bx += 40) {
                // Postes
                ctx.fillRect(bx, p.y - 25, 4, 25);
            }
            // Baranda horizontal
            ctx.fillRect(p.x + 10, p.y - 22, p.width - 20, 3);

            // B. Ventiladores / Cajas de control
            // Colocamos uno cada 150px aprox
            for(let dx = p.x + 50; dx < p.x + p.width - 50; dx += 150) {
                let type = (dx % 3); 
                if (type === 0) {
                    // Unidad de ventilación cuadrada
                    ctx.fillStyle = '#222';
                    ctx.fillRect(dx, p.y - 20, 30, 20);
                    // Rejilla
                    ctx.fillStyle = '#111';
                    ctx.fillRect(dx + 5, p.y - 15, 20, 10);
                    // Fan girando
                    let spin = Math.sin(gameTime * 0.5 + dx);
                    ctx.fillStyle = '#444';
                    ctx.fillRect(dx + 14 + spin*5, p.y - 15, 2, 10);
                } else if (type === 1) {
                    // Tubería saliendo del suelo
                    ctx.strokeStyle = '#443';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(dx, p.y);
                    ctx.lineTo(dx, p.y - 30);
                    ctx.lineTo(dx + 20, p.y - 30);
                    ctx.lineTo(dx + 20, p.y - 25); // Goteo
                    ctx.stroke();
                    
                    // Gota (partícula simulada local)
                    if (gameTime % 60 < 10) {
                        ctx.fillStyle = '#adff2f'; // Gota tóxica
                        ctx.fillRect(dx + 19, p.y - 25 + (gameTime % 20), 2, 3);
                    }
                } else {
                    // Pilas de chatarra
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.moveTo(dx, p.y);
                    ctx.lineTo(dx + 10, p.y - 15);
                    ctx.lineTo(dx + 25, p.y - 5);
                    ctx.lineTo(dx + 40, p.y);
                    ctx.fill();
                }
            }

            // 5. Textura interna de la plataforma (Vigas, remaches)
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            if (p.height > 50) { // Solo si es gruesa
                for (let i = 0; i < p.width; i += 100) {
                    // Viga de soporte vertical
                    ctx.fillRect(p.x + i, p.y + 8, 10, p.height - 8);
                    // Remaches
                    ctx.fillStyle = '#151515';
                    ctx.beginPath(); ctx.arc(p.x + i + 5, p.y + 20, 2, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(p.x + i + 5, p.y + p.height - 20, 2, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = 'rgba(0,0,0,0.2)';
                }
            }
        });
    }

    function drawForegroundLayers(ctx, cameraX) {
        // CAPA 1: Niebla baja (Humo industrial)
        let fogOffset = (gameTime * 0.5) % GAME_WIDTH;
        ctx.fillStyle = BIOME.fog;
        for(let i = -1; i < 2; i++) {
            let x = i * GAME_WIDTH - fogOffset;
            // Dibujar ondas de humo simples
            ctx.beginPath();
            ctx.ellipse(x + 600, GAME_HEIGHT + 50, 700, 200, 0, 0, Math.PI*2);
            ctx.fill();
        }

        // CAPA 2: Estructuras muy cercanas (Pasan rápido - desenfoque simulado)
        // Usamos alpha para simular desenfoque
        let speed = 1.5;
        let pX = -(cameraX * speed) % 2000;
        if(pX > 0) pX -= 2000;
        
        ctx.fillStyle = 'rgba(5, 5, 5, 0.9)';
        for(let i = 0; i < 3; i++) {
            let x = pX + i * 800 + 2000; // Espaciado amplio
            // Viga vertical grande
            ctx.fillRect(x, 0, 60, GAME_HEIGHT);
            // Cables cruzando
            ctx.beginPath();
            ctx.moveTo(x, 100);
            ctx.bezierCurveTo(x+200, 300, x+400, 300, x+800, 50);
            ctx.strokeStyle = 'rgba(0,0,0,0.8)';
            ctx.lineWidth = 5;
            ctx.stroke();
        }
    }

    // --- BUCLE PRINCIPAL ---
    let gameTime = 0;
    let camera = { x: 0, y: 0 };

    function loop() {
        gameTime++;
        
        // Movimiento de cámara igual al original
        camera.x = Math.sin(gameTime * 0.01) * 200;
        
        // Update Lluvia
        rain.forEach(r => {
            r.y += r.s + 2; // Cae más rápido
            r.x -= 1; // Viento
            if(r.y > GAME_HEIGHT) { r.y = -10; r.x = Math.random() * GAME_WIDTH + camera.x; } // Reciclar y seguir camara
        });

        player.update();
        walker.update();
        flyer.update();

        // RENDER
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 1. Fondo Parallax (6 capas, estilo original)
        drawBackground(ctx, camera.x, camera.y);
        
        // 2. Juego (Mapa y Entidades)
        ctx.save();
        ctx.translate(-camera.x + 200, 0); // Offset visual para mantener jugabilidad en pantalla

        drawMap(ctx);
        
        ctx.restore();

        // 3. Entidades (Renderizadas fijas para la demo, igual que original)
        ctx.save();
        ctx.shadowColor = "rgba(0,0,0,0.5)"; ctx.shadowBlur = 10; // Sombra para integrar personajes
        player.draw(ctx);
        walker.draw(ctx);
        flyer.draw(ctx);
        ctx.shadowBlur = 0;
        ctx.restore();
        
        // 4. Lluvia (Delante de personajes)
        ctx.strokeStyle = 'rgba(150, 160, 150, 0.2)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        rain.forEach(r => {
            ctx.moveTo(r.x, r.y);
            ctx.lineTo(r.x - 2, r.y + 10);
        });
        ctx.stroke();

        // 5. Foreground (2 Capas enfrente de la plataforma)
        drawForegroundLayers(ctx, camera.x);

        requestAnimationFrame(loop);
    }

    loop();

</script>
</body>
</html>