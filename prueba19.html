<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Abstract Poly - Visual Testbed</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #game-container {
            position: relative;
            box-shadow: 0 0 50px rgba(255, 80, 0, 0.3);
            border: 2px solid #222;
            background: #110805;
            width: 1280px;
            height: 720px;
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        /* UI Overlay moderna */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            background: radial-gradient(circle at center, transparent 60%, rgba(0,0,0,0.6) 100%); /* Viñeta */
        }
        #debug-info {
            position: absolute; top: 20px; left: 20px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            background: rgba(0,0,0,0.4);
            padding: 15px;
            border-left: 3px solid #00bcd4;
            backdrop-filter: blur(4px);
        }
        .scanlines {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%);
            background-size: 100% 4px;
            pointer-events: none;
            opacity: 0.3;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div class="scanlines"></div>
    <div id="ui-layer"></div>
    <div id="debug-info">
        <h2 style="margin:0 0 5px 0; font-weight:300; letter-spacing: 2px;">POLY VERSE</h2>
        <div style="font-size: 12px; opacity: 0.7;">HIGH FIDELITY RENDER</div>
        <p>FPS: <span id="fps-counter">60</span></p>
        <p>Partículas: <span id="particle-counter">0</span></p>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false }); // Optimización
    const GAME_WIDTH = 1280;
    const GAME_HEIGHT = 720;
    canvas.width = GAME_WIDTH;
    canvas.height = GAME_HEIGHT;

    // --- PALETA DE COLORES E INSPIRACIÓN (Basado en la imagen) ---
    // Naranjas profundos, Rojos oxidados, Cyans brillantes, Amarillos
    const PALETTE = {
        bgStart: '#2d140e',
        bgEnd: '#5e2a18',
        grid: 'rgba(255, 255, 255, 0.03)',
        orb: ['#ff9800', '#f44336', '#ff5722'], // Colores cálidos de fondo
        platformBase: '#1a1a1a',
        platformHighlight: '#ffcc80',
        player: '#ffffff',
        playerAccent: '#00e5ff', // Cyan neón
        enemyWalker: '#00bcd4',   // Teal
        enemyFlyer: '#ffeb3b',    // Amarillo eléctrico
        particles: ['#ffeb3b', '#ff9800', '#00bcd4']
    };

    // --- UTILIDADES GRÁFICAS (Low Poly & Effects) ---

    // Función para dibujar un polígono irregular (shard)
    function drawShard(ctx, x, y, width, height, colorBase, variation = 20) {
        // Dividimos el rectángulo en 4 triángulos (estilo sobre) para dar volumen
        const cx = x + width / 2;
        const cy = y + height / 2;
        
        const baseHSL = hexToHSL(colorBase); 

        // Triángulo Superior (Más luz)
        ctx.fillStyle = hslToHex(baseHSL.h, baseHSL.s, baseHSL.l + 10);
        ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + width, y); ctx.lineTo(cx, cy); ctx.fill();

        // Triángulo Inferior (Sombra)
        ctx.fillStyle = hslToHex(baseHSL.h, baseHSL.s, baseHSL.l - 10);
        ctx.beginPath(); ctx.moveTo(x, y + height); ctx.lineTo(x + width, y + height); ctx.lineTo(cx, cy); ctx.fill();

        // Izquierda
        ctx.fillStyle = hslToHex(baseHSL.h, baseHSL.s, baseHSL.l - 5);
        ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y + height); ctx.lineTo(cx, cy); ctx.fill();

        // Derecha
        ctx.fillStyle = hslToHex(baseHSL.h, baseHSL.s, baseHSL.l + 5);
        ctx.beginPath(); ctx.moveTo(x + width, y); ctx.lineTo(x + width, y + height); ctx.lineTo(cx, cy); ctx.fill();
        
        // Brillo borde
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.strokeRect(x,y,width,height);
    }

    // Dibujar forma de cristal/polígono
    function drawPolyShape(ctx, x, y, radius, sides, color, rotation = 0) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotation);
        ctx.beginPath();
        for (let i = 0; i < sides; i++) {
            const angle = (i * 2 * Math.PI) / sides;
            ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
        }
        ctx.closePath();
        ctx.fillStyle = color;
        // Gradiente interno simulado
        ctx.shadowBlur = 10;
        ctx.shadowColor = color;
        ctx.fill();
        ctx.restore();
    }

    // Convertidores rápidos de color para efectos
    function hexToHSL(H) {
        // Conversión simplificada para efectos
        let r = 0, g = 0, b = 0;
        if (H.length == 4) {
            r = "0x" + H[1] + H[1]; g = "0x" + H[2] + H[2]; b = "0x" + H[3] + H[3];
        } else if (H.length == 7) {
            r = "0x" + H[1] + H[2]; g = "0x" + H[3] + H[4]; b = "0x" + H[5] + H[6];
        }
        r /= 255; g /= 255; b /= 255;
        let cmin = Math.min(r,g,b), cmax = Math.max(r,g,b), delta = cmax - cmin;
        let h = 0, s = 0, l = 0;
        if (delta == 0) h = 0;
        else if (cmax == r) h = ((g - b) / delta) % 6;
        else if (cmax == g) h = (b - r) / delta + 2;
        else h = (r - g) / delta + 4;
        h = Math.round(h * 60);
        if (h < 0) h += 360;
        l = (cmax + cmin) / 2;
        s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
        s = +(s * 100).toFixed(1);
        l = +(l * 100).toFixed(1);
        return { h, s, l };
    }
    function hslToHex(h, s, l) {
        l /= 100; const a = s * Math.min(l, 1 - l) / 100;
        const f = n => {
            const k = (n + h / 30) % 12;
            const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
            return Math.round(255 * color).toString(16).padStart(2, '0');
        };
        return `#${f(0)}${f(8)}${f(4)}`;
    }

    // --- SISTEMA DE PARTÍCULAS ---
    const particles = [];
    class Particle {
        constructor(x, y, type) {
            this.x = x; this.y = y;
            this.type = type; // 'dust', 'spark', 'smoke', 'thruster'
            this.life = 1.0;
            this.decay = Math.random() * 0.02 + 0.01;
            
            if (type === 'dust') {
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                this.size = Math.random() * 2 + 1;
                this.color = 'rgba(255, 255, 255, 0.2)';
            } else if (type === 'thruster') {
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = Math.random() * 2 + 1; // Hacia abajo
                this.size = Math.random() * 4 + 2;
                this.color = `hsla(${Math.random()*40 + 10}, 100%, 60%, 1)`; // Naranja/Rojo fuego
                this.decay = 0.08;
            } else if (type === 'glow') {
                this.vx = (Math.random() - 0.5);
                this.vy = (Math.random() - 0.5);
                this.size = Math.random() * 10 + 5;
                this.color = 'rgba(0, 255, 255, 0.1)';
            }
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life -= this.decay;
        }
        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            if(this.type === 'thruster') {
                // Dibujar cuadrado rotado para estilo pixel/poly
                ctx.translate(this.x, this.y);
                ctx.rotate(Math.PI / 4);
                ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
            } else {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }
    }

    function spawnParticles(x, y, count, type) {
        for(let i=0; i<count; i++) particles.push(new Particle(x, y, type));
    }

    // --- LOGICA DE JUEGO (MOCKS) ---
    // Mantenemos la lógica de tamaños y movimiento original, cambiamos solo el DRAW

    let gameTime = 0;
    let camera = { x: 0, y: 0 };
    let fps = 60;

    class MockPlayer {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 24; this.height = 40;
            this.vx = 0; 
            this.animTimer = 0;
            this.facingRight = true;
            this.state = 'wait';
            this.stateTimer = 0;
            this.bobY = 0; // Flotación sutil
        }

        update() {
            this.animTimer++;
            this.stateTimer++;
            
            // Flotación idle
            this.bobY = Math.sin(this.animTimer * 0.1) * 2;

            // IA Simple (Original)
            if (this.state === 'wait') {
                this.vx = 0;
                if (this.stateTimer > 60) {
                    this.state = Math.random() > 0.5 ? 'walk_right' : 'walk_left';
                    this.stateTimer = 0;
                }
            } else if (this.state === 'walk_right') {
                this.vx = 3;
                this.facingRight = true;
                this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
                // Emitir partículas al caminar
                if (gameTime % 5 === 0) spawnParticles(this.x, this.y + 40, 1, 'dust');
            } else if (this.state === 'walk_left') {
                this.vx = -3;
                this.facingRight = false;
                this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
                if (gameTime % 5 === 0) spawnParticles(this.x + 24, this.y + 40, 1, 'dust');
            }
            
            if(this.x < 100) { this.x = 100; this.state = 'walk_right'; }
            if(this.x > 600) { this.x = 600; this.state = 'walk_left'; }
        }

        draw(ctx) {
            // Diseño High Fidelity Low Poly Player
            ctx.save();
            ctx.translate(this.x + this.width/2, this.y + this.height/2 + this.bobY);
            if (!this.facingRight) ctx.scale(-1, 1);
            
            // Sombra
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.beginPath(); ctx.ellipse(0, 25 - this.bobY, 15, 4, 0, 0, Math.PI*2); ctx.fill();

            // Cuerpo (Hexagono estilizado)
            ctx.fillStyle = PALETTE.player;
            // Torso
            ctx.beginPath();
            ctx.moveTo(-8, -10); ctx.lineTo(8, -10); ctx.lineTo(12, 10); ctx.lineTo(-12, 10);
            ctx.fill();
            // Detalle armadura (gradiente)
            let grd = ctx.createLinearGradient(-10, -10, 10, 10);
            grd.addColorStop(0, '#ddd'); grd.addColorStop(1, '#999');
            ctx.fillStyle = grd;
            ctx.fill();

            // Cabeza (Casco moderno)
            ctx.fillStyle = '#333';
            ctx.fillRect(-8, -22, 16, 12);
            // Visor (Brillante)
            ctx.shadowBlur = 10;
            ctx.shadowColor = PALETTE.playerAccent;
            ctx.fillStyle = PALETTE.playerAccent;
            ctx.fillRect(0, -20, 8, 6); // Ojo visor
            ctx.shadowBlur = 0;

            // Jetpack / Mochila
            ctx.fillStyle = '#555';
            ctx.fillRect(-14, -8, 6, 14);
            // Fuego Jetpack (pequeño)
            if (this.vx !== 0) {
                 spawnParticles(this.facingRight ? this.x - 5 : this.x + this.width + 5, this.y + 15, 1, 'thruster');
            }

            // Piernas (Geométricas independientes)
            let legOffset = Math.sin(this.animTimer * 0.4) * 5;
            if (Math.abs(this.vx) < 0.1) legOffset = 0;
            
            ctx.fillStyle = '#888';
            // Pierna trasera
            ctx.beginPath(); ctx.moveTo(-6, 10); ctx.lineTo(-8 + legOffset, 22); ctx.lineTo(-4 + legOffset, 22); ctx.fill();
            // Pierna delantera
            ctx.fillStyle = '#aaa';
            ctx.beginPath(); ctx.moveTo(6, 10); ctx.lineTo(4 - legOffset, 22); ctx.lineTo(8 - legOffset, 22); ctx.fill();

            // Arma (Rifle futurista)
            ctx.fillStyle = '#222';
            ctx.fillRect(4, -2, 20, 6);
            ctx.fillStyle = PALETTE.playerAccent;
            ctx.fillRect(20, -1, 3, 3); // Punta brillante

            ctx.restore();
        }
    }

    class MockWalker {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 30; this.height = 30;
            this.vx = 2;
            this.dir = 1;
            this.timer = 0;
            this.state = 'walk';
            this.startX = x;
        }

        update() {
            this.timer++;
            if (this.state === 'walk') {
                this.x += this.vx;
                if (Math.abs(this.x - this.startX) > 150) {
                    this.state = 'wait';
                    this.waitTimer = 60;
                }
            } else if (this.state === 'wait') {
                this.waitTimer--;
                if (this.waitTimer <= 0) {
                    this.dir *= -1;
                    this.vx = this.dir * 2;
                    this.state = 'walk';
                }
            }
        }

        draw(ctx) {
            // Diseño: Robot Araña Cristalino
            ctx.save();
            ctx.translate(this.x + this.width/2, this.y + this.height/2);
            
            let anim = Math.sin(this.timer * 0.2);
            let color = PALETTE.enemyWalker;

            // Cuerpo Central (Rombo flotante)
            ctx.shadowBlur = 15;
            ctx.shadowColor = color;
            ctx.fillStyle = color;
            
            ctx.beginPath();
            ctx.moveTo(0, -15 + anim*2);
            ctx.lineTo(10, 0 + anim*2);
            ctx.lineTo(0, 15 + anim*2);
            ctx.lineTo(-10, 0 + anim*2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Núcleo brillante
            ctx.fillStyle = '#fff';
            ctx.beginPath(); ctx.arc(0, anim*2, 4, 0, Math.PI*2); ctx.fill();

            // Patas Mecánicas (Lineas gruesas con articulaciones)
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            
            // 4 Patas
            for(let i=0; i<4; i++) {
                let angle = (Math.PI / 4) + (i * Math.PI/2);
                let legX = Math.cos(angle + (anim*0.1)) * 20;
                let legY = Math.sin(angle) * 15;
                
                // Efecto IK simple
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(legX * 0.5, legY * 0.5 - 5); // Rodilla arriba
                ctx.lineTo(legX, legY + 15); // Pie abajo
                ctx.stroke();
                
                // Pie brillante
                ctx.fillStyle = color;
                ctx.fillRect(legX - 2, legY + 13, 4, 4);
            }
            ctx.restore();
            
            // Partículas ocasionales
            if(Math.random() > 0.9) spawnParticles(this.x + 15, this.y + 15, 1, 'glow');
        }
    }

    class MockFlyer {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 30; this.height = 20;
            this.startX = x;
            this.timer = 0;
        }

        update() {
            this.timer++;
            this.x = this.startX + Math.sin(this.timer * 0.02) * 200;
            this.y += Math.cos(this.timer * 0.05) * 1; 
        }

        draw(ctx) {
            // Diseño: Dron Triangular
            ctx.save();
            ctx.translate(this.x + 15, this.y + 10);
            
            let bank = Math.cos(this.timer * 0.02) * 0.3; // Inclinación al girar
            ctx.rotate(bank);

            // Forma base triangular
            ctx.fillStyle = PALETTE.enemyFlyer;
            ctx.beginPath();
            ctx.moveTo(15, 0); // Punta
            ctx.lineTo(-10, -10); // Ala arr
            ctx.lineTo(-5, 0); // Centro cola
            ctx.lineTo(-10, 10); // Ala abj
            ctx.closePath();
            ctx.fill();

            // Detalle oscuro
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.moveTo(5, 0); ctx.lineTo(-5, -4); ctx.lineTo(-5, 4); ctx.fill();

            // Propulsor
            ctx.fillStyle = '#ff5722';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ff5722';
            ctx.beginPath(); ctx.arc(-8, 0, 3, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0;
            
            // Estela
            if (gameTime % 3 === 0) spawnParticles(this.x, this.y + 10, 1, 'thruster');

            ctx.restore();
        }
    }

    const player = new MockPlayer(200, 500);
    const walker = new MockWalker(800, 440); // Ajuste altura por el diseño
    const flyer = new MockFlyer(600, 200);

    const platforms = [
        { x: 0, y: 540, width: 800, height: 200 },
        { x: 750, y: 490, width: 400, height: 20 }
    ];

    // --- FONDO PARALLAX MODERNO ---
    
    // Generamos nubes/formas de fondo procedurally
    const bgShapes = [];
    for(let i=0; i<20; i++) {
        bgShapes.push({
            x: Math.random() * 2000,
            y: Math.random() * 720,
            size: Math.random() * 100 + 50,
            layer: Math.floor(Math.random() * 3) + 1, // 1 a 3
            sides: Math.floor(Math.random() * 3) + 3, // 3 a 6 lados
            color: PALETTE.orb[Math.floor(Math.random() * PALETTE.orb.length)],
            rotationSpeed: (Math.random() - 0.5) * 0.01
        });
    }

    // Elementos del Foreground (Capa frontal muy rápida)
    const fgShapes = [];
    for(let i=0; i<5; i++) {
        fgShapes.push({
            x: Math.random() * 3000,
            y: Math.random() * 720,
            w: Math.random() * 100 + 50,
            h: Math.random() * 400 + 100,
            speed: 1.5
        });
    }

    function drawBackground(ctx, cameraX) {
        // 1. Fondo Color Solido Gradiente
        const grd = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
        grd.addColorStop(0, PALETTE.bgStart);
        grd.addColorStop(1, PALETTE.bgEnd);
        ctx.fillStyle = grd;
        ctx.fillRect(0,0, GAME_WIDTH, GAME_HEIGHT);

        // 2. Rejilla de Fondo (Layer 0 - Muy lento)
        ctx.save();
        ctx.strokeStyle = PALETTE.grid;
        ctx.lineWidth = 1;
        let gridParallax = -(cameraX * 0.05) % 100;
        
        ctx.beginPath();
        // Lineas verticales
        for(let i=gridParallax; i<GAME_WIDTH; i+=100) {
            ctx.moveTo(i, 0); ctx.lineTo(i - 200, GAME_HEIGHT); // Inclinadas
        }
        // Lineas horizontales
        for(let j=0; j<GAME_HEIGHT; j+=100) {
            ctx.moveTo(0, j); ctx.lineTo(GAME_WIDTH, j);
        }
        ctx.stroke();
        ctx.restore();

        // 3. Formas Geométricas Flotantes (Capas 1, 2, 3)
        // Simulamos profundidad cambiando opacidad y velocidad
        bgShapes.forEach(shape => {
            let speed = shape.layer * 0.1;
            let renderX = (shape.x - cameraX * speed) % (GAME_WIDTH + 500);
            if (renderX < -200) renderX += (GAME_WIDTH + 500);

            ctx.globalAlpha = shape.layer * 0.15; // Más lejos, más transparente
            
            // Dibujamos formas abstractas rotando
            drawPolyShape(ctx, renderX, shape.y, shape.size, shape.sides, shape.color, gameTime * shape.rotationSpeed);
        });
        ctx.globalAlpha = 1.0;

        // 4. Montañas/Estructuras lejanas (Capa 4 - Más cerca)
        ctx.fillStyle = '#22110c'; // Sombra silueta
        let mountainSpeed = 0.4;
        let mx = -(cameraX * mountainSpeed);
        ctx.beginPath();
        ctx.moveTo(0, GAME_HEIGHT);
        for(let i=0; i<=GAME_WIDTH/50 + 2; i++) {
            let wx = (i * 100) + (mx % 100);
            // Usamos seno para generar picos "low poly"
            let hy = GAME_HEIGHT - 100 - Math.abs(Math.sin(i * 132 + 10) * 150);
            ctx.lineTo(wx, hy);
        }
        ctx.lineTo(GAME_WIDTH, GAME_HEIGHT);
        ctx.fill();

        // 5. Niebla atmosférica (Gradiente abajo arriba)
        const fog = ctx.createLinearGradient(0, GAME_HEIGHT - 300, 0, GAME_HEIGHT);
        fog.addColorStop(0, 'rgba(94, 42, 24, 0)');
        fog.addColorStop(1, 'rgba(94, 42, 24, 0.8)');
        ctx.fillStyle = fog;
        ctx.fillRect(0, GAME_HEIGHT - 300, GAME_WIDTH, 300);
    }

    function drawForeground(ctx, cameraX) {
        // Capa delante de todo (Borrosa y rápida)
        ctx.fillStyle = '#000';
        fgShapes.forEach(shape => {
            let renderX = (shape.x - cameraX * shape.speed) % (GAME_WIDTH + 1000);
            if (renderX < -500) renderX += (GAME_WIDTH + 1000);
            
            // Desenfoque simulado con alpha
            ctx.fillStyle = 'rgba(0,0,0,0.8)'; 
            // Formas grandes oscuras que pasan rápido
            ctx.beginPath();
            ctx.moveTo(renderX, GAME_HEIGHT);
            ctx.lineTo(renderX + shape.w/2, GAME_HEIGHT - shape.h);
            ctx.lineTo(renderX + shape.w, GAME_HEIGHT);
            ctx.fill();
        });
    }

    function drawMap(ctx) {
        platforms.forEach(p => {
            // Cuerpo de la plataforma (Cristal oscuro facetado)
            // Dividimos el ancho en segmentos para dibujar "shards"
            let segmentSize = 40;
            let segments = Math.ceil(p.width / segmentSize);

            for(let i=0; i<segments; i++) {
                let sx = p.x + (i * segmentSize);
                let sw = Math.min(segmentSize, p.x + p.width - sx);
                let sy = p.y;
                let sh = p.height;
                
                // Variación de color basada en posición para textura
                let noise = Math.sin(sx * 0.1) * 20; 
                let baseColor = i % 2 === 0 ? '#263238' : '#37474f'; // Tonos oscuros
                
                drawShard(ctx, sx, sy, sw, sh, baseColor);
            }

            // Borde superior brillante (Neon)
            ctx.shadowBlur = 10;
            ctx.shadowColor = PALETTE.orb[0];
            ctx.strokeStyle = PALETTE.platformHighlight;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p.x + p.width, p.y);
            ctx.stroke();
            ctx.shadowBlur = 0;
        });
    }

    // --- BUCLE PRINCIPAL ---
    function loop() {
        let start = performance.now();
        gameTime++;
        
        // Simular movimiento de cámara (Senoide suave)
        camera.x = Math.sin(gameTime * 0.005) * 400 + 400; // Desplazamiento más largo
        
        // --- UPDATES ---
        player.update();
        walker.update();
        flyer.update();
        
        // Partículas
        for(let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            if(particles[i].life <= 0) particles.splice(i, 1);
        }
        
        // Generar polvo ambiental
        if (gameTime % 20 === 0) spawnParticles(Math.random()*GAME_WIDTH, Math.random()*GAME_HEIGHT, 1, 'dust');

        // --- RENDER ---
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 1. Fondo Parallax
        drawBackground(ctx, camera.x);
        
        // 2. Escena del Juego
        ctx.save();
        
        // Truco visual del testbed original:
        // Movemos el contexto opuesto a la cámara, PERO centramos los objetos en pantalla
        // para que no se vayan.
        // En un juego real: ctx.translate(-camera.x, 0);
        // Aquí simulamos que los objetos "siguen" para verlos siempre, pero el fondo se mueve.
        
        // Para respetar la petición de "cambiar diseños pero mantener tamaños",
        // dibujamos las plataformas relativas a la cámara simulada para este demo visual.
        
        // Offset para centrar la acción visualmente
        let viewOffset = -camera.x + 200; 

        // Dibujar elementos del mundo
        ctx.save();
        // Mover el mundo "ficticiamente" para que el parallax tenga sentido visual
        // pero reseteamos la X de los objetos para que estén en el centro de la demo.
        
        // En este demo, vamos a dejar los objetos fijos en X relativa a la pantalla
        // pero el fondo se mueve, creando la ilusión de viaje.
        
        // Mapa
        drawMap(ctx); // Plataformas estáticas en pantalla para el test
        
        // Entidades
        player.draw(ctx);
        walker.draw(ctx);
        flyer.draw(ctx);

        // Partículas (Renderizamos en espacio global de pantalla para este demo)
        particles.forEach(p => p.draw(ctx));

        ctx.restore();

        // 3. Iluminación Global (Overlay)
        ctx.globalCompositeOperation = 'overlay'; // O 'soft-light'
        const lightGrad = ctx.createRadialGradient(GAME_WIDTH/2, GAME_HEIGHT/2, 100, GAME_WIDTH/2, GAME_HEIGHT/2, 600);
        lightGrad.addColorStop(0, 'rgba(255, 152, 0, 0.1)'); // Centro cálido
        lightGrad.addColorStop(1, 'rgba(0, 188, 212, 0.1)'); // Bordes frios
        ctx.fillStyle = lightGrad;
        ctx.fillRect(0,0, GAME_WIDTH, GAME_HEIGHT);
        ctx.globalCompositeOperation = 'source-over';

        // 4. Capa Frontal (Adelante de plataformas)
        drawForeground(ctx, camera.x);

        ctx.restore();
        
        // Debug info
        document.getElementById('particle-counter').innerText = particles.length;
        
        requestAnimationFrame(loop);
    }

    // Inicializar partículas de ambiente
    spawnParticles(GAME_WIDTH/2, GAME_HEIGHT/2, 50, 'dust');

    loop();

</script>
</body>
</html>