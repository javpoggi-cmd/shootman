<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Shootman: High-Production Visual Test</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #game-container {
            position: relative;
            box-shadow: 0 0 60px rgba(0, 100, 255, 0.2);
            border: 2px solid #1a1a1a;
            background: #000;
            width: 1280px;
            height: 720px;
        }
        canvas {
            display: block;
            background-color: #050505;
            /* Quitamos pixelated para permitir gradientes y brillos suaves */
            /* image-rendering: pixelated; */ 
            width: 100%;
            height: 100%;
        }
        /* Scanlines más sutiles y modernas */
        #scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: repeating-linear-gradient(
                to bottom,
                rgba(0, 0, 0, 0.1) 0px,
                rgba(0, 0, 0, 0.2) 2px,
                rgba(0, 0, 0, 0.0) 4px
            );
            pointer-events: none;
            z-index: 30;
            opacity: 0.6;
            mix-blend-mode: overlay;
        }
        /* Viñeta para oscurecer esquinas y centrar la atención */
        #vignette {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.8) 100%);
            pointer-events: none;
            z-index: 25;
        }
        #debug-ui {
            position: absolute; top: 20px; left: 20px; 
            color: #00eaff; 
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            text-transform: uppercase;
            letter-spacing: 1px;
            z-index: 40;
            background: rgba(0, 20, 40, 0.8); 
            border-left: 4px solid #00eaff;
            padding: 15px;
            box-shadow: 0 0 20px rgba(0, 234, 255, 0.2);
        }
        #debug-ui h3 { margin: 0 0 10px 0; font-size: 1.2em; }
        #debug-ui p { margin: 5px 0; font-size: 0.9em; color: #aaddff; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="testCanvas"></canvas>
    <div id="scanlines"></div>
    <div id="vignette"></div>
    <div id="debug-ui">
        <h3>VISUAL TARGET: NEO-INDUSTRIAL</h3>
        <p>Atmosphere: Heavy Rain / Fog</p>
        <p>Lighting: Dynamic Glow</p>
    </div>
</div>

<script>
    const canvas = document.getElementById('testCanvas');
    const ctx = canvas.getContext('2d');
    const GAME_WIDTH = 1280; 
    const GAME_HEIGHT = 720;
    canvas.width = GAME_WIDTH; 
    canvas.height = GAME_HEIGHT;

    // --- NUEVA PALETA DE COLORES "SERIA" ---
    const PALETTE = {
        skyTop: '#020508',
        skyBottom: '#0a121a',
        fog: 'rgba(10, 20, 30, 0.7)',
        
        // Capas de fondo (más oscuras y azuladas con la distancia)
        layer5: '#080a0c', // Más lejana
        layer4: '#0d1114',
        layer3: '#141a20',
        layer2: '#1c242e',
        layer1: '#252e38', // Más cercana

        // Luces
        neonBlue: '#00eaff',
        neonRed: '#ff3333',
        neonOrange: '#ffaa00',
        windowWarm: 'rgba(255, 200, 100, 0.6)',
        windowCold: 'rgba(100, 200, 255, 0.5)',

        // Materiales
        metalDark: '#1a1a1a',
        metalMid: '#333a42',
        metalLight: '#55606d',
        rust: '#4a332a',
        concrete: '#2a3035'
    };

    // --- SISTEMA DE LLUVIA ---
    const rainDrops = [];
    for(let i = 0; i < 300; i++) {
        rainDrops.push({
            x: Math.random() * GAME_WIDTH,
            y: Math.random() * GAME_HEIGHT,
            length: Math.random() * 20 + 10,
            speed: Math.random() * 10 + 15,
            opacity: Math.random() * 0.4 + 0.1
        });
    }

    function drawRain(ctx) {
        ctx.strokeStyle = PALETTE.neonBlue;
        ctx.lineWidth = 1;
        ctx.beginPath();
        for(let drop of rainDrops) {
            ctx.globalAlpha = drop.opacity;
            ctx.moveTo(drop.x, drop.y);
            ctx.lineTo(drop.x - 2, drop.y + drop.length); // Lluvia inclinada
            drop.y += drop.speed;
            drop.x -= 2;
            if (drop.y > GAME_HEIGHT) {
                drop.y = -drop.length;
                drop.x = Math.random() * GAME_WIDTH + 200; // Reset arriba y un poco a la derecha
            }
        }
        ctx.stroke();
        ctx.globalAlpha = 1.0;
    }

    // --- FUNCIONES DE AYUDA PARA DIBUJO DETALLADO ---
    function setGlow(ctx, color, blur) {
        ctx.shadowColor = color;
        ctx.shadowBlur = blur;
    }
    function clearGlow(ctx) {
        ctx.shadowBlur = 0;
    }

    // --- CLASES REDISEÑADAS (Manteniendo tamaños y lógica) ---

    class MockPlayer {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 24; this.height = 40;
            this.vx = 0; 
            this.animTimer = 0;
            this.facingRight = true;
            this.state = 'wait'; 
            this.stateTimer = 0;
        }
        // MISMOS MÉTODOS UPDATE QUE EL ORIGINAL
        update() {
            this.animTimer++; this.stateTimer++;
            if (this.state === 'wait') {
                this.vx = 0;
                if (this.stateTimer > 60) { this.state = Math.random() > 0.5 ? 'walk_right' : 'walk_left'; this.stateTimer = 0; }
            } else if (this.state === 'walk_right') {
                this.vx = 3; this.facingRight = true; this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
            } else if (this.state === 'walk_left') {
                this.vx = -3; this.facingRight = false; this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
            }
            if(this.x < 100) { this.x = 100; this.state = 'walk_right'; }
            if(this.x > 600) { this.x = 600; this.state = 'walk_left'; }
        }

        draw(ctx) {
            ctx.save(); 
            let lean = 0; if (Math.abs(this.vx) > 1) lean = this.facingRight ? 3 : -3; 
            ctx.translate(lean, 0);
            
            let cycle = Math.sin(this.animTimer * 0.5);
            let legH1 = 15, legH2 = 15;
            if (Math.abs(this.vx) > 0.5) {
                legH1 = 15 + cycle * 3;
                legH2 = 15 - cycle * 3;
            }

            // Sombra en el suelo
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.beginPath(); ctx.ellipse(this.x + 12, this.y + 38, 14, 4, 0, 0, Math.PI*2); ctx.fill();

            // --- DISEÑO TÁCTICO MODERNO ---
            // Piernas (Armadura oscura)
            ctx.fillStyle = '#222';
            ctx.fillRect(this.x + 4, this.y + 25, 6, legH1); 
            ctx.fillRect(this.x + 14, this.y + 25, 6, legH2);
            // Rodilleras / Botas
            ctx.fillStyle = '#333';
            ctx.fillRect(this.x + 3, this.y + 25 + legH1 - 5, 8, 5);
            ctx.fillRect(this.x + 13, this.y + 25 + legH2 - 5, 8, 5);
            
            // Torso (Chaleco táctico)
            let torsoGrad = ctx.createLinearGradient(this.x, this.y + 10, this.x + this.width, this.y + 28);
            torsoGrad.addColorStop(0, '#3a3a3a'); torsoGrad.addColorStop(1, '#1a1a1a');
            ctx.fillStyle = torsoGrad;
            ctx.fillRect(this.x, this.y + 10, this.width, 18);
            // Detalles del chaleco
            ctx.fillStyle = '#111'; ctx.fillRect(this.x + 4, this.y + 14, this.width - 8, 2);
            ctx.fillRect(this.x + 4, this.y + 20, this.width - 8, 2);

            // Mochila de energía (con brillo)
            setGlow(ctx, PALETTE.neonBlue, 10);
            ctx.fillStyle = '#224'; 
            let packX = this.facingRight ? this.x - 5 : this.x + 19;
            ctx.fillRect(packX, this.y + 12, 6, 14);
            // Núcleo brillante de la mochila
            ctx.fillStyle = PALETTE.neonBlue;
            ctx.fillRect(packX + 2, this.y + 15, 2, 8);
            clearGlow(ctx);

            // Casco
            ctx.fillStyle = '#333'; ctx.fillRect(this.x + 2, this.y, 20, 12);
            ctx.fillStyle = '#222'; ctx.fillRect(this.x + 4, this.y + 2, 16, 8);
            
            // Visor Táctico Brillante
            setGlow(ctx, PALETTE.neonOrange, 15);
            ctx.fillStyle = PALETTE.neonOrange;
            ctx.fillRect(this.facingRight ? this.x + 12 : this.x + 2, this.y + 4, 10, 3);
            clearGlow(ctx);

            // Arma (Rifle moderno)
            ctx.fillStyle = '#111';
            let gunX = this.facingRight ? this.x + 12 : this.x - 14; 
            let gunY = this.y + 16;
            ctx.fillRect(gunX, gunY, 24, 5); // Cuerpo principal
            ctx.fillStyle = '#333';
            ctx.fillRect(gunX + (this.facingRight ? 20 : -2), gunY + 1, 6, 3); // Cañón
            // Luz táctica en el arma
            setGlow(ctx, PALETTE.neonBlue, 5);
            ctx.fillStyle = '#aaf';
            ctx.fillRect(gunX + (this.facingRight ? 22 : 0), gunY + 5, 3, 2);
            clearGlow(ctx);

            ctx.restore();
        }
    }

    class MockWalker {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 30; this.height = 30;
            this.vx = 2; this.dir = 1; this.timer = 0;
            this.state = 'walk'; this.startX = x;
        }
        // MISMOS MÉTODOS UPDATE
        update() {
            this.timer++;
            if (this.state === 'walk') {
                this.x += this.vx;
                if (Math.abs(this.x - this.startX) > 150) { this.state = 'wait'; this.waitTimer = 60; }
            } else if (this.state === 'wait') {
                this.waitTimer--;
                if (this.waitTimer <= 0) { this.dir *= -1; this.vx = this.dir * 2; this.state = 'walk'; }
            }
        }

        draw(ctx) {
            let anim = Math.sin(this.timer * 0.2);
            let drawY = this.y - 10; 
            let centerX = this.x + this.width / 2;
            let centerY = drawY + this.height / 2;

             // Sombra mecánica
             ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.beginPath(); ctx.ellipse(centerX, drawY + this.height + 10, 20, 6, 0, 0, Math.PI*2); ctx.fill();

            // --- DISEÑO ROBOT INDUSTRIAL ---
            // Cuerpo principal (Metal oxidado)
            let bodyGrad = ctx.createLinearGradient(this.x, drawY, this.x, drawY + this.height);
            bodyGrad.addColorStop(0, PALETTE.rust); bodyGrad.addColorStop(1, PALETTE.metalDark);
            ctx.fillStyle = bodyGrad;
            ctx.fillRect(this.x, drawY, this.width, this.height);
            // Remaches y paneles
            ctx.fillStyle = PALETTE.metalMid;
            ctx.fillRect(this.x, drawY + 10, this.width, 2);
            ctx.fillRect(this.x + 5, drawY + 5, 2, 2); ctx.fillRect(this.x + 23, drawY + 5, 2, 2);

            // Ojo/Reflector (Brillante y amenazante)
            setGlow(ctx, PALETTE.neonRed, 20);
            ctx.fillStyle = '#500'; ctx.fillRect(this.x + 10, drawY + 5, 10, 10); // Carcasa ojo
            ctx.fillStyle = '#fbb'; ctx.fillRect(this.x + 12, drawY + 7, 6, 6); // Lente brillante
            clearGlow(ctx);
            // Cono de luz sutil
            let lightGrad = ctx.createRadialGradient(centerX, centerY, 5, centerX, centerY, 60);
            lightGrad.addColorStop(0, 'rgba(255, 50, 50, 0.2)');
            lightGrad.addColorStop(1, 'rgba(255, 0, 0, 0)');
            ctx.fillStyle = lightGrad;
            ctx.beginPath(); ctx.moveTo(this.x + 15, drawY + 10);
            ctx.lineTo(this.x - 20, drawY + 80); ctx.lineTo(this.x + 50, drawY + 80); ctx.fill();

            
            // Brazos mecánicos rotatorios
            ctx.fillStyle = PALETTE.metalLight; 
            ctx.save(); ctx.translate(this.x + 2, drawY + 15); ctx.rotate(anim); 
            ctx.fillRect(-2, 0, 4, 15); // Brazo superior
            ctx.fillStyle = PALETTE.rust; ctx.fillRect(-3, 12, 6, 6); // "Mano" pesada
            ctx.restore();

            ctx.save(); ctx.translate(this.x + 28, drawY + 15); ctx.rotate(-anim); 
            ctx.fillStyle = PALETTE.metalLight; ctx.fillRect(-2, 0, 4, 15);
            ctx.fillStyle = PALETTE.rust; ctx.fillRect(-3, 12, 6, 6);
            ctx.restore();
            
            // Piernas pistón
            ctx.fillStyle = PALETTE.metalDark;
            let leg1H = 10 + anim * 5;
            let leg2H = 10 - anim * 5;
            ctx.fillRect(this.x + 5, drawY + 30, 5, leg1H); // Pistón superior
            ctx.fillRect(this.x + 20, drawY + 30, 5, leg2H);
            // Pies
            ctx.fillStyle = PALETTE.metalMid;
            ctx.fillRect(this.x + 3, drawY + 30 + leg1H, 9, 4);
            ctx.fillRect(this.x + 18, drawY + 30 + leg2H, 9, 4);
        }
    }

    class MockFlyer {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 30; this.height = 20;
            this.startX = x; this.timer = 0;
        }
        // MISMOS MÉTODOS UPDATE
        update() {
            this.timer++;
            this.x = this.startX + Math.sin(this.timer * 0.02) * 200;
            this.y += Math.cos(this.timer * 0.05) * 1; 
        }

        draw(ctx) {
            let flap = Math.sin(this.timer * 0.8) * 5;
            let flicker = Math.random() > 0.5 ? 0.8 : 1.0;

            // --- DISEÑO DRON VIGILANCIA ---
            
            // Estela de motor (Fuego azul)
            setGlow(ctx, PALETTE.neonBlue, 15 * flicker);
            let thrusterGrad = ctx.createLinearGradient(this.x + 10, this.y + 5, this.x - 20, this.y + 10);
            thrusterGrad.addColorStop(0, 'rgba(100, 200, 255, 0.8)');
            thrusterGrad.addColorStop(1, 'rgba(0, 100, 255, 0)');
            ctx.fillStyle = thrusterGrad;
            // Dibujar estela detrás
            ctx.beginPath(); ctx.moveTo(this.x+10, this.y+5); ctx.lineTo(this.x-15 - flicker*5, this.y+15); ctx.lineTo(this.x+20, this.y+18); ctx.fill();
            clearGlow(ctx);

            // Cuerpo (Metal oscuro y elegante)
            ctx.fillStyle = PALETTE.metalDark;
            ctx.beginPath();
            ctx.moveTo(this.x, this.y + 5);
            ctx.lineTo(this.x + 15, this.y); // Nariz
            ctx.lineTo(this.x + 30, this.y + 5);
            ctx.lineTo(this.x + 25, this.y + 20);
            ctx.lineTo(this.x + 5, this.y + 20);
            ctx.closePath(); ctx.fill();

            // Paneles y detalles
            ctx.fillStyle = PALETTE.metalMid;
            ctx.fillRect(this.x + 10, this.y + 2, 10, 18);
            
            // "Alas" / Estabilizadores con movimiento
            ctx.fillStyle = PALETTE.metalLight; 
            ctx.beginPath(); ctx.moveTo(this.x + 5, this.y+5); ctx.lineTo(this.x - 8, this.y - 5 + flap); ctx.lineTo(this.x + 5, this.y+15); ctx.fill();
            ctx.beginPath(); ctx.moveTo(this.x + 25, this.y+5); ctx.lineTo(this.x + 38, this.y - 5 + flap); ctx.lineTo(this.x + 25, this.y+15); ctx.fill(); 
            
            // Motor/Ojo central brillante
            setGlow(ctx, PALETTE.neonOrange, 10 * flicker);
            ctx.fillStyle = '#fa0'; ctx.fillRect(this.x + 12, this.y + 8, 6, 4);
            clearGlow(ctx);
        }
    }

    const player = new MockPlayer(200, 500);
    const walker = new MockWalker(800, 450);
    const flyer = new MockFlyer(600, 200);

    const platforms = [
        { x: -100, y: 540, width: 1480, height: 200 }, // Suelo extendido
        { x: 750, y: 490, width: 400, height: 30 } 
    ];

    // --- FONDO REVISADO (5 CAPAS + CIELO) ---
    // Definición de capas con más detalle y colores atmosféricos
    const bgLayersDef = [
        // Capa 5 (Más lejana) - Siluetas masivas, casi negras por la distancia
        { speed: 0.02, colorTop: PALETTE.layer5, colorBot: PALETTE.skyBottom, heightBase: 600, heightVar: 80, width: 250, density: 0.7, details: 'cranes' }, 
        // Capa 4
        { speed: 0.08, colorTop: PALETTE.layer4, colorBot: PALETTE.layer5, heightBase: 500, heightVar: 120, width: 200, density: 0.8, details: 'pipes' }, 
        // Capa 3
        { speed: 0.20, colorTop: PALETTE.layer3, colorBot: PALETTE.layer4, heightBase: 400, heightVar: 150, width: 180, density: 0.9, details: 'windows' }, 
        // Capa 2
        { speed: 0.40, colorTop: PALETTE.layer2, colorBot: PALETTE.layer3, heightBase: 250, heightVar: 200, width: 220, density: 1.0, details: 'complex' },
        // Capa 1 (Más cercana) - Más detalle, más oscura y contrastada
        { speed: 0.75, colorTop: PALETTE.layer1, colorBot: PALETTE.layer2, heightBase: 100, heightVar: 250, width: 300, density: 1.0, details: 'complex_foreground' }
    ];

    function drawBackground(ctx, cameraX, cameraY) {
        // Cielo degradado
        let skyGrad = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
        skyGrad.addColorStop(0, PALETTE.skyTop);
        skyGrad.addColorStop(1, PALETTE.skyBottom);
        ctx.fillStyle = skyGrad; 
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        bgLayersDef.forEach((layer, index) => {
            ctx.save(); 
            let parallaxX = -cameraX * layer.speed; 
            let parallaxY = -cameraY * (layer.speed * 0.3); // Menos movimiento vertical
            ctx.translate(parallaxX, parallaxY);
            
            let totalW = layer.width; 
            let startI = Math.floor(-parallaxX / totalW) - 3; 
            let endI = startI + Math.ceil(GAME_WIDTH / totalW) + 6;
            
            for (let i = startI; i < endI; i++) {
                let pseudoRandom = Math.sin(i * 134.5 + index * 12.1);
                if (pseudoRandom > layer.density) continue; // Espacios vacíos

                let h = layer.heightBase + (pseudoRandom * layer.heightVar); 
                let x = i * totalW; 
                let y = GAME_HEIGHT - h;
                let w = layer.width + Math.cos(i)*50;

                // Edificio con gradiente vertical para volumen
                let buildGrad = ctx.createLinearGradient(x, y, x, GAME_HEIGHT);
                buildGrad.addColorStop(0, layer.colorTop);
                buildGrad.addColorStop(1, layer.colorBot);
                ctx.fillStyle = buildGrad;
                ctx.fillRect(x, y, w, h + 1000);

                // Detalles procedurales según el tipo de capa
                if (layer.details === 'cranes' && pseudoRandom > 0.5) {
                    ctx.fillStyle = layer.colorTop;
                    ctx.fillRect(x + w/2, y - 100, 10, 100); // Torre grúa
                    ctx.fillRect(x + w/2 - 50, y - 90, 120, 5); // Brazo
                }
                
                if (layer.details === 'pipes' || layer.details.includes('complex')) {
                     // Tuberías externas
                     ctx.strokeStyle = PALETTE.metalDark; ctx.lineWidth = 5;
                     ctx.beginPath(); ctx.moveTo(x-10, y+50); ctx.lineTo(x+w+10, y+50); ctx.stroke();
                     ctx.beginPath(); ctx.moveTo(x+20, y+20); ctx.lineTo(x+20, y+h); ctx.stroke();
                }

                if (layer.details.includes('windows') || layer.details.includes('complex')) {
                    if (Math.abs(pseudoRandom) > 0.2) {
                        let wins = Math.abs(Math.floor(pseudoRandom * 4)) + 2;
                        for (let winCol = 0; winCol < wins; winCol++) {
                             // Ventanas altas y estrechas
                            for (let winRow = 0; winRow < 8; winRow++) {
                                let winState = Math.sin(i * 45.5 + winCol * 12.1 + winRow * 7.7 + gameTime * 0.01); // Parpadeo lento
                                if (winState > 0.6) { 
                                    // Ventana iluminada con glow
                                    let winColor = winState > 0.85 ? PALETTE.windowWarm : PALETTE.windowCold;
                                    setGlow(ctx, winColor, 10);
                                    ctx.fillStyle = winColor;
                                    ctx.fillRect(x + 20 + winCol * 30, y + 80 + winRow * 50, 12, 25);
                                    clearGlow(ctx);
                                } else { 
                                    // Ventana apagada (reflejo oscuro)
                                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                                    ctx.fillRect(x + 20 + winCol * 30, y + 80 + winRow * 50, 12, 25);
                                }
                            }
                        }
                    }
                }
            }
             // Niebla atmosférica entre capas (más densa lejos)
             let fogDensity = (4 - index) * 0.15;
             ctx.fillStyle = PALETTE.fog;
             ctx.globalAlpha = fogDensity;
             ctx.fillRect(startI * totalW, GAME_HEIGHT - layer.heightBase - 200, (endI-startI)*totalW, layer.heightBase + 400);
             ctx.globalAlpha = 1.0;

            ctx.restore();
        });
        
        // Niebla de suelo global
        let groundFog = ctx.createLinearGradient(0, GAME_HEIGHT - 300, 0, GAME_HEIGHT);
        groundFog.addColorStop(0, 'rgba(10, 20, 30, 0)');
        groundFog.addColorStop(1, 'rgba(10, 20, 30, 0.8)');
        ctx.fillStyle = groundFog;
        ctx.fillRect(0, GAME_HEIGHT - 300, GAME_WIDTH, 300);
    }

    // --- DIBUJO DEL MAPA REDISEÑADO ---
    function drawMap(ctx) {
        platforms.forEach(p => {
            // Cuerpo de la plataforma (Hormigón y metal sucio)
            let platGrad = ctx.createLinearGradient(p.x, p.y, p.x, p.y + p.height);
            platGrad.addColorStop(0, PALETTE.metalMid);
            platGrad.addColorStop(1, PALETTE.concrete);
            ctx.fillStyle = platGrad;
            ctx.fillRect(p.x, p.y, p.width, p.height);
            
            // Textura de vigas de soporte (rayas diagonales oscuras)
            ctx.save(); ctx.beginPath(); ctx.rect(p.x, p.y + 15, p.width, p.height - 15); ctx.clip();
            ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 4;
            for(let i = -p.height; i < p.width; i+=20) {
                 ctx.beginPath(); ctx.moveTo(p.x + i, p.y); ctx.lineTo(p.x + i + p.height, p.y + p.height); ctx.stroke();
            }
            ctx.restore();

            // Borde superior (Rejilla metálica iluminada)
            ctx.fillStyle = PALETTE.metalDark;
            ctx.fillRect(p.x, p.y, p.width, 15);
            
            ctx.fillStyle = '#555';
            for(let i=0; i < p.width; i+=5) { // Patrón de rejilla
                ctx.fillRect(p.x + i, p.y, 2, 15);
            }
            // Borde brillante de la rejilla
            ctx.fillStyle = 'rgba(200, 220, 255, 0.3)';
            ctx.fillRect(p.x, p.y, p.width, 2);
            
            // Sombras de contacto debajo de la plataforma superior
            if(p.y < 500) {
                 ctx.fillStyle = 'rgba(0,0,0,0.5)';
                 ctx.fillRect(p.x, p.y + p.height, p.width, 20);
            }
        });
    }

    // --- BUCLE PRINCIPAL (Lógica intacta, solo renderizado mejorado) ---
    let gameTime = 0;
    let camera = { x: 0, y: 0 };

    function loop() {
        gameTime++;
        camera.x = Math.sin(gameTime * 0.01) * 200;
        
        player.update(); walker.update(); flyer.update();

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        drawBackground(ctx, camera.x, camera.y);
        
        // Dibujar Lluvia (detrás de los objetos)
        drawRain(ctx);

        // Dibujar Mapa y Personajes (Estáticos en pantalla como en el original)
        ctx.save();
        // Pequeño ajuste vertical para centrar mejor la acción
        ctx.translate(0, 50);

        drawMap(ctx);
        // Sombra de contacto para los personajes
        ctx.fillStyle = "rgba(0,0,0,0.4)";
        
        player.draw(ctx);
        walker.draw(ctx);
        flyer.draw(ctx);
        
        ctx.restore();

        // Capa final de atmósfera delantera (Niebla sutil sobre todo)
        ctx.fillStyle = 'rgba(0, 10, 20, 0.1)';
        ctx.fillRect(0,0,GAME_WIDTH, GAME_HEIGHT);

        requestAnimationFrame(loop);
    }

    loop();

</script>
</body>
</html>