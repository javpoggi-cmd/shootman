<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Shootman: Level 2 - Toxic Refinery</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #game-container {
            position: relative;
            box-shadow: 0 0 60px rgba(100, 255, 0, 0.15); /* Glow tóxico leve alrededor */
            border: 4px solid #222;
            background: #000;
            width: 1280px;
            height: 720px;
        }
        canvas {
            display: block;
            background-color: #0f1210;
            image-rendering: pixelated; /* Importante para el pixel art */
            width: 100%;
            height: 100%;
        }
        /* Scanlines mejorados con un tono verdoso sutil para la atmósfera tóxica */
        #scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 20, 0, 0.15) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.03), rgba(0, 0, 255, 0.03));
            background-size: 100% 4px, 6px 100%;
            pointer-events: none;
            z-index: 50;
            mix-blend-mode: overlay;
        }
        /* Viñeta para oscurecer esquinas y dar atmósfera opresiva */
        #vignette {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 60%, rgba(0,0,0,0.85) 100%);
            pointer-events: none;
            z-index: 40;
        }
        #debug-ui {
            position: absolute; top: 10px; left: 10px; color: #aaff00; z-index: 60;
            background: rgba(0,0,0,0.8); padding: 15px;
            border: 1px solid #333;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        h3 { margin: 0 0 5px 0; font-size: 16px; text-transform: uppercase; letter-spacing: 2px;}
        p { margin: 2px 0; font-size: 12px; color: #88aa88; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="testCanvas"></canvas>
    <div id="scanlines"></div>
    <div id="vignette"></div>
    <div id="debug-ui">
        <h3>NIVEL 2: REFINERÍA</h3>
        <p>Bioma: TOXIC WASTE</p>
        <p>Fondo: 6 Capas Parallax</p>
        <p>Frente: 2 Capas + Clima</p>
    </div>
</div>

<script>
    const canvas = document.getElementById('testCanvas');
    const ctx = canvas.getContext('2d');
    const GAME_WIDTH = 1280; 
    const GAME_HEIGHT = 720;
    canvas.width = GAME_WIDTH; 
    canvas.height = GAME_HEIGHT;

    // --- PALETA DE COLORES "TOXIC REFINERY" ---
    // Mantenemos los colores del PJ y enemigos para consistencia
    const COLORS = { 
        player: '#e0e0e0', 
        playerAccent: '#ffaa00', 
        bullet: '#00ffaa', 
        enemyBullet: '#ff4444', 
        weapon: '#00ff00' 
    };

    const ENEMY_COLOR = '#cc4444';

    // Nueva paleta ambiental: Óxido, Verde Ácido, Oscuridad Púrpura
    const BIOME = {
        skyTop: '#020005',
        skyBottom: '#1a0b14', // Degradado hacia un tono rojizo contaminado
        fog: 'rgba(10, 30, 15, 0.4)', // Niebla verde tóxica
        acidGlow: '#33ff00',
        platformBase: '#2b2424',
        platformRust: '#5e3e33',
        platformHighlight: '#444',
        bgLayers: [
            '#080508', // Layer 1 (Más lejos - Siluetas gigantes)
            '#110d11', // Layer 2
            '#1a1418', // Layer 3
            '#241c20', // Layer 4
            '#2d2626', // Layer 5
            '#383030'  // Layer 6 (Más cerca)
        ]
    };

    // --- SISTEMA DE PARTICULAS (CLIMA) ---
    const particles = [];
    function createParticles() {
        if(particles.length < 150) { // Mantener 150 partículas de ceniza
            particles.push({
                x: Math.random() * GAME_WIDTH,
                y: Math.random() * GAME_HEIGHT,
                size: Math.random() * 2 + 0.5,
                speedX: (Math.random() - 0.5) * 0.5 - 0.5, // Viento suave izquierda
                speedY: Math.random() * 1 + 0.2, // Caída lenta
                opacity: Math.random() * 0.5 + 0.1
            });
        }
    }
    
    function updateAndDrawParticles(ctx) {
        createParticles();
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        for (let i = 0; i < particles.length; i++) {
            let p = particles[i];
            p.x += p.speedX;
            p.y += p.speedY;
            
            // Reset si sale de pantalla
            if(p.y > GAME_HEIGHT || p.x < 0) {
                p.y = -10;
                p.x = Math.random() * GAME_WIDTH + 50;
            }

            ctx.globalAlpha = p.opacity;
            ctx.fillRect(p.x, p.y, p.size, p.size);
        }
        ctx.globalAlpha = 1.0;
        ctx.fill();
    }

    // --- VARIABLES DE SIMULACIÓN ---
    let gameTime = 0;
    let camera = { x: 0, y: 0 };
    
    // --- CLASES DE PERSONAJES (INTACTAS - NO MODIFICADAS) ---
    // Mantenemos la lógica exacta del archivo original como se solicitó

    class MockPlayer {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 24; this.height = 40;
            this.vx = 0; this.animTimer = 0; this.facingRight = true;
            this.state = 'wait'; this.stateTimer = 0;
        }
        update() {
            this.animTimer++; this.stateTimer++;
            if (this.state === 'wait') {
                this.vx = 0;
                if (this.stateTimer > 60) { this.state = Math.random() > 0.5 ? 'walk_right' : 'walk_left'; this.stateTimer = 0; }
            } else if (this.state === 'walk_right') {
                this.vx = 3; this.facingRight = true; this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
            } else if (this.state === 'walk_left') {
                this.vx = -3; this.facingRight = false; this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
            }
            if(this.x < 100) { this.x = 100; this.state = 'walk_right'; }
            if(this.x > 600) { this.x = 600; this.state = 'walk_left'; }
        }
        draw(ctx) {
            ctx.save(); ctx.fillStyle = COLORS.player;
            let lean = 0; if (Math.abs(this.vx) > 1) lean = this.facingRight ? 3 : -3; 
            ctx.translate(lean, 0);
            if (Math.abs(this.vx) > 0.5) {
                let cycle = Math.sin(this.animTimer * 0.5);
                ctx.fillRect(this.x + 4, this.y + 25, 6, 15 + cycle * 3); 
                ctx.fillRect(this.x + 14, this.y + 25, 6, 15 - cycle * 3);
            } else { ctx.fillRect(this.x + 4, this.y + 25, 6, 15); ctx.fillRect(this.x + 14, this.y + 25, 6, 15); }
            ctx.fillStyle = '#fff'; ctx.fillRect(this.x, this.y + 10, this.width, 18);
            ctx.fillStyle = '#55f'; ctx.fillRect(this.facingRight ? this.x - 4 : this.x + 20, this.y + 12, 4, 10); 
            ctx.fillStyle = '#333'; ctx.fillRect(this.x + 2, this.y, 20, 12); 
            ctx.fillStyle = COLORS.playerAccent; ctx.fillRect(this.facingRight ? this.x + 12 : this.x + 2, this.y + 3, 10, 4); 
            ctx.fillStyle = '#555';
            let gunX = this.facingRight ? this.x + 14 : this.x - 6; let gunY = this.y + 14;
            ctx.fillRect(gunX, gunY, 16, 6);
            ctx.restore();
        }
    }

    class MockWalker {
        constructor(x, y) {
            this.x = x; this.y = y; this.width = 30; this.height = 30;
            this.vx = 2; this.dir = 1; this.timer = 0; this.state = 'walk'; this.startX = x;
        }
        update() {
            this.timer++;
            if (this.state === 'walk') {
                this.x += this.vx;
                if (Math.abs(this.x - this.startX) > 150) { this.state = 'wait'; this.waitTimer = 60; }
            } else if (this.state === 'wait') {
                this.waitTimer--;
                if (this.waitTimer <= 0) { this.dir *= -1; this.vx = this.dir * 2; this.state = 'walk'; }
            }
        }
        draw(ctx) {
            ctx.fillStyle = ENEMY_COLOR;
            let anim = Math.sin(this.timer * 0.2); let drawY = this.y - 10; 
            ctx.fillRect(this.x, drawY, this.width, this.height);
            ctx.fillStyle = '#fff'; ctx.fillRect(this.x + 10, drawY + 5, 10, 10); 
            ctx.fillStyle = '#f00'; ctx.fillRect(this.x + 13, drawY + 8, 4, 4);
            ctx.fillStyle = ENEMY_COLOR; 
            ctx.save(); ctx.translate(this.x + 5, drawY + 15); ctx.rotate(anim); ctx.fillRect(0, 0, 5, 15); ctx.restore();
            ctx.save(); ctx.translate(this.x + 25, drawY + 15); ctx.rotate(-anim); ctx.fillRect(0, 0, 5, 15); ctx.restore();
            ctx.fillRect(this.x + 5, drawY + 30, 5, 10 + anim * 5); ctx.fillRect(this.x + 20, drawY + 30, 5, 10 - anim * 5);
        }
    }

    class MockFlyer {
        constructor(x, y) {
            this.x = x; this.y = y; this.width = 30; this.height = 20; this.startX = x; this.timer = 0;
        }
        update() {
            this.timer++;
            this.x = this.startX + Math.sin(this.timer * 0.02) * 200;
            this.y += Math.cos(this.timer * 0.05) * 1; 
        }
        draw(ctx) {
            let flap = Math.sin(this.timer * 0.8) * 10;
            ctx.fillStyle = ENEMY_COLOR; ctx.fillRect(this.x, this.y, 30, 20); 
            ctx.fillStyle = '#777'; 
            ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x - 10, this.y - 10 + flap); ctx.lineTo(this.x + 10, this.y); ctx.fill();
            ctx.beginPath(); ctx.moveTo(this.x + 30, this.y); ctx.lineTo(this.x + 40, this.y - 10 + flap); ctx.lineTo(this.x + 20, this.y); ctx.fill(); 
            ctx.fillStyle = '#ff0'; ctx.fillRect(this.x + 10, this.y + 5, 10, 5);
        }
    }

    // --- SETUP DEL NIVEL ---
    const player = new MockPlayer(200, 500);
    const walker = new MockWalker(800, 450);
    const flyer = new MockFlyer(600, 200);

    const platforms = [
        { x: 0, y: 540, width: 800, height: 200 }, 
        { x: 750, y: 490, width: 400, height: 30 }  // Altura ajustada para mejor estética
    ];

    // --- FUNCIÓN DE DIBUJO: FONDO COMPLEJO (6 CAPAS) ---
    function drawRefineryBackground(ctx, cameraX, cameraY) {
        // Cielo con degradado
        let grad = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
        grad.addColorStop(0, BIOME.skyTop);
        grad.addColorStop(1, BIOME.skyBottom);
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Luna / Sol tóxico lejano
        ctx.save();
        ctx.fillStyle = '#331111';
        ctx.beginPath(); ctx.arc(900, 200, 60, 0, Math.PI*2); ctx.fill();
        ctx.restore();

        const layers = [
            // Layer 1: Siluetas de montañas industriales muy lejanas
            { speed: 0.02, color: BIOME.bgLayers[0], type: 'mountains' },
            // Layer 2: Estructuras masivas (Chimeneas gigantes)
            { speed: 0.05, color: BIOME.bgLayers[1], type: 'chimneys' },
            // Layer 3: Edificios de refinería bloque
            { speed: 0.10, color: BIOME.bgLayers[2], type: 'buildings' },
            // Layer 4: Tuberías gruesas y tanques
            { speed: 0.25, color: BIOME.bgLayers[3], type: 'pipes' },
            // Layer 5: Detalles mecánicos, grúas
            { speed: 0.40, color: BIOME.bgLayers[4], type: 'mechanical' },
            // Layer 6: Cercas y estructuras cercanas
            { speed: 0.65, color: BIOME.bgLayers[5], type: 'fences' }
        ];

        layers.forEach((layer, index) => {
            ctx.save();
            let parallaxX = -cameraX * layer.speed;
            let parallaxY = -cameraY * (layer.speed * 0.3);
            ctx.translate(parallaxX, parallaxY);

            // Generación procedural determinista basada en la posición X
            // "Tileamos" el dibujo cada 800px (ancho de patrón)
            let patternWidth = 800;
            let startTile = Math.floor(-parallaxX / patternWidth);
            let tilesNeeded = Math.ceil(GAME_WIDTH / patternWidth) + 1;

            for (let i = startTile; i < startTile + tilesNeeded; i++) {
                let x = i * patternWidth;
                let baseX = x;
                
                ctx.fillStyle = layer.color;

                // Semilla pseudo-aleatoria para este tile y layer
                let seed = (i * 132.5 + index * 33.1);
                let pseudoRandom = Math.sin(seed);

                if(layer.type === 'mountains') {
                    ctx.beginPath();
                    ctx.moveTo(x, GAME_HEIGHT);
                    ctx.lineTo(x, GAME_HEIGHT - 500 + pseudoRandom * 370);
                    ctx.lineTo(x + patternWidth/2, GAME_HEIGHT - 350 - pseudoRandom * 30);
                    ctx.lineTo(x + patternWidth, GAME_HEIGHT - 300 + pseudoRandom * 50);
                    ctx.lineTo(x + patternWidth, GAME_HEIGHT);
                    ctx.fill();
                }
                else if(layer.type === 'chimneys') {
                    let h = 300 + pseudoRandom * 100;
                    ctx.fillRect(x + 100, GAME_HEIGHT - h, 60, h);
                    ctx.fillRect(x + 90, GAME_HEIGHT - h - 10, 80, 10); // Borde arriba
                    
                    // Humo estático (o nubes lentas)
                    ctx.fillStyle = 'rgba(20, 20, 20, 0.5)';
                    ctx.beginPath(); ctx.arc(x + 130, GAME_HEIGHT - h - 30, 30, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = layer.color; // Restaurar color
                }
                else if(layer.type === 'pipes') {
                    // Tuberias horizontales y verticales
                    ctx.fillRect(x, GAME_HEIGHT - 250, patternWidth, 20);
                    ctx.fillRect(x + 200, GAME_HEIGHT - 350, 40, 350);
                    
                    // Juntas de tubería
                    ctx.fillStyle = '#111';
                    ctx.fillRect(x + 195, GAME_HEIGHT - 250, 50, 10);
                    ctx.fillStyle = layer.color;
                }
                else if(layer.type === 'mechanical') {
                    // Dientes de engranaje o estructuras complejas
                    for(let j=0; j<10; j++) {
                        let h = 50 + Math.sin(seed + j)*30;
                        ctx.fillRect(x + j*80, GAME_HEIGHT - h - 170, 40, h + 100);
                        // Luz de advertencia roja pequeña en algunas
                        if(j % 3 === 0) {
                            ctx.fillStyle = '#ff0000';
                            ctx.fillRect(x + j*80 + 15, GAME_HEIGHT - h - 160, 4, 4);
                            ctx.fillStyle = layer.color;
                        }
                    }
                }
                else {
                    // Relleno genérico irregular para otras capas
                    ctx.fillRect(x, GAME_HEIGHT - 120 - Math.abs(pseudoRandom)*100, patternWidth, 400);
                }
            }
            ctx.restore();
        });
    }

    // --- FUNCIÓN DE DIBUJO: MAPA DETALLADO (TEXTURIZADO) ---
    function drawDetailedMap(ctx) {
        platforms.forEach(p => {
            // 1. Base Metálica
            ctx.fillStyle = BIOME.platformBase; 
            ctx.fillRect(p.x, p.y, p.width, p.height);
            
            // 2. Textura (Rayas de peligro o rejilla)
            ctx.save();
            ctx.beginPath();
            ctx.rect(p.x, p.y, p.width, p.height);
            ctx.clip(); // Recortar para dibujar textura solo dentro

            // Dibujar rejilla
            ctx.strokeStyle = 'rgba(0,0,0,0.3)';
            ctx.lineWidth = 2;
            for(let i=0; i<p.width; i+=20) {
                ctx.beginPath(); ctx.moveTo(p.x + i, p.y); ctx.lineTo(p.x + i, p.y + p.height); ctx.stroke();
            }
            for(let j=0; j<p.height; j+=20) {
                ctx.beginPath(); ctx.moveTo(p.x, p.y + j); ctx.lineTo(p.x + p.width, p.y + j); ctx.stroke();
            }

            // Manchas de óxido aleatorias (deterministas)
            ctx.fillStyle = BIOME.platformRust;
            for(let k=0; k<10; k++) {
                let rx = (p.x * k * 13) % p.width;
                let ry = (p.y * k * 7) % p.height;
                ctx.fillRect(p.x + rx, p.y + ry, 30, 30);
            }
            ctx.restore();

            // 3. Borde superior (Superficie)
            ctx.fillStyle = '#111';
            ctx.fillRect(p.x, p.y, p.width, 4);
            
            // Rayas amarillas de precaución en los bordes
            ctx.fillStyle = '#aa8800';
            for(let i=0; i<p.width; i+=40) {
                ctx.fillRect(p.x + i, p.y + 4, 20, 4);
            }

            // 4. Decoración inferior (Tuberías y Goteo)
            // Dibujamos tuberias colgando debajo de las plataformas si hay espacio
            if(p.y + p.height < GAME_HEIGHT - 50) {
                ctx.fillStyle = '#222';
                ctx.fillRect(p.x + 50, p.y + p.height, 10, 20);
                ctx.fillRect(p.x + p.width - 50, p.y + p.height, 10, 30);
                
                // Goteo ácido
                let drip = (gameTime % 60) / 60; // 0 a 1
                ctx.fillStyle = BIOME.acidGlow;
                ctx.globalAlpha = 1 - drip;
                ctx.fillRect(p.x + 53, p.y + p.height + 20 + (drip * 30), 4, 6);
                ctx.globalAlpha = 1;
            }
        });
    }

    // --- FUNCIÓN DE DIBUJO: FOREGROUND (2 CAPAS FRENTE) ---
    function drawForeground(ctx, cameraX) {
        // Capa 1: Niebla baja
        let fogX = (gameTime * 2) % GAME_WIDTH;
        let gradFog = ctx.createLinearGradient(0, GAME_HEIGHT - 150, 0, GAME_HEIGHT);
        gradFog.addColorStop(0, 'transparent');
        gradFog.addColorStop(1, BIOME.fog);
        
        ctx.fillStyle = gradFog;
        ctx.fillRect(0, GAME_HEIGHT - 100, GAME_WIDTH, 100);

        // Capa 2: Objetos que pasan MUY rápido por delante (Columnas, Cables)
        // Parallax factor muy alto (1.2x o 1.5x)
        const fgSpeed = 1.2;
        let parallaxFG = -cameraX * fgSpeed;
        let patternW = 1000;
        let start = Math.floor(-parallaxFG / patternW);
        
        ctx.save();
        ctx.translate(parallaxFG, 0);
        ctx.fillStyle = '#000'; // Siluetas negras puras borrosas
        // Filtro de blur para dar sensacion de desenfoque (costoso, simulamos con transparencia)
        ctx.globalAlpha = 0.9;
        
        for(let i=start; i < start + 3; i++) {
            let x = i * patternW;
            // Columna grande que tapa la vista
            if (i % 2 === 0) {
                ctx.fillRect(x + 200, 0, 80, GAME_HEIGHT);
                // Detalles en la columna (Luz roja)
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                ctx.beginPath(); ctx.arc(x + 240, 100, 10, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#000';
            }
            // Cables colgando
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.quadraticCurveTo(x + 500, 300, x + 1000, 0);
            ctx.lineWidth = 5;
            ctx.strokeStyle = '#000';
            ctx.stroke();
        }
        ctx.restore();
    }

    // --- BUCLE PRINCIPAL ---
    function loop() {
        gameTime++;
        
        // Simular movimiento de cámara suave (Auto-Scroll lento + Sinusoidal)
        // Hemos hecho que la cámara avance un poco para mostrar el nivel
        camera.x = (gameTime * 0.5) + Math.sin(gameTime * 0.01) * 50;
        
        // Actualizar entidades
        player.update();
        walker.update();
        flyer.update();

        // Renderizar
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 1. Fondo Parallax (6 Capas)
        drawRefineryBackground(ctx, camera.x, camera.y);
        
        // Configuración de cámara para el mundo de juego
        ctx.save();
        // Ajuste de cámara: mantenemos al jugador visible relativo al scroll
        // Para este test visual, centramos en pantalla pero movemos el mundo
        let screenCenter = GAME_WIDTH / 2;
        let worldOffset = -camera.x + 200; // Offset visual
        
        ctx.translate(worldOffset, 0); 

        // 2. Mapa (Plataformas detalladas)
        drawDetailedMap(ctx);
        
        // 3. Entidades
        // Truco visual: Para el test, movemos las entidades con la cámara para que no se queden atrás
        // En un juego real, esto no se haría así, pero aquí es para ver el arte.
        // Calculamos una posición 'falsa' para que se mantengan en cuadro
        
        let renderPlayerX = player.x + camera.x; // Hack para mantenerlo en pantalla
        let renderWalkerX = walker.x + camera.x;
        let renderFlyerX = flyer.x + camera.x;

        // Restauramos el contexto para dibujar entidades "fijas" en pantalla relativa (truco visual del test)
        ctx.restore();
        ctx.save();
        // Dibujamos entidades relativas a la pantalla pero sobre el fondo movil
        // (Ignora la logica de posicion real para este demo artistico, priorizamos visualizacion)
        
        // Dibujar PJ
        ctx.save(); ctx.translate(200, 0); // Posicion fija en pantalla para el player
        player.draw(ctx);
        ctx.restore();

        // Dibujar Enemigos (simulando que están en el mundo)
        // Usamos una formula simple para que se muevan con el parallax pero vuelvan
        let screenWalkerX = walker.x + Math.sin(gameTime * 0.01) * 50; 
        let screenFlyerX = flyer.x + Math.sin(gameTime * 0.02) * 30;
        
        ctx.save(); ctx.translate(screenWalkerX, 0); walker.draw(ctx); ctx.restore();
        ctx.save(); ctx.translate(screenFlyerX, 0); flyer.draw(ctx); ctx.restore();

        ctx.restore();

        // 4. Efectos Globales y Foreground
        drawForeground(ctx, camera.x);
        updateAndDrawParticles(ctx);

        // 5. Overlay de iluminación final (Luz ambiental verde/toxica)
        ctx.fillStyle = BIOME.acidGlow;
        ctx.globalCompositeOperation = 'overlay'; // Mezcla de luz
        ctx.globalAlpha = 0.1;
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1.0;

        requestAnimationFrame(loop);
    }

    // Iniciar
    loop();

</script>
</body>
</html>