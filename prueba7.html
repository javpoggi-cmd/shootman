<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Shootman: High Fidelity Testbed</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #020205; /* Fondo de seguridad por si falla el canvas */
            font-family: 'Consolas', monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: white;
        }
        #game-container {
            position: relative;
            box-shadow: 0 0 50px rgba(0, 100, 255, 0.2);
            border: 2px solid #222;
            background: #000;
            width: 1280px;
            height: 720px;
        }
        canvas {
            display: block;
            background-color: #05070a;
            width: 100%;
            height: 100%;
        }
        /* UI y Efectos */
        #scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: repeating-linear-gradient(
                to bottom,
                transparent 0px,
                transparent 2px,
                rgba(0, 0, 0, 0.3) 3px,
                rgba(0, 0, 0, 0.3) 4px
            );
            pointer-events: none;
            z-index: 10;
            opacity: 0.6;
        }
        #vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, transparent 40%, rgba(0,0,0,0.9) 100%);
            pointer-events: none; z-index: 11;
        }
        #debug-ui {
            position: absolute; top: 10px; left: 10px; color: #00ddee; z-index: 20;
            background: rgba(0,0,0,0.8); padding: 15px; border-left: 3px solid #00ddee;
            text-transform: uppercase; letter-spacing: 1px;
        }
        h3 { margin: 0 0 10px 0; font-size: 16px; }
        p { margin: 5px 0; font-size: 12px; color: #8899aa; }
        #error-log { color: #ff3333; font-weight: bold; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="testCanvas"></canvas>
    <div id="scanlines"></div>
    <div id="vignette"></div>
    <div id="debug-ui">
        <h3>TEST DE DISEÑO: Hi-Fi</h3>
        <p>Bioma: CIUDAD INDUSTRIAL NOIR</p>
        <p>Estado: <span id="status">EJECUTANDO</span></p>
        <div id="error-log"></div>
    </div>
</div>

<script>
    // Bloque try-catch principal para capturar errores y no dejar la pantalla en blanco
    try {
        const canvas = document.getElementById('testCanvas');
        const ctx = canvas.getContext('2d');
        const GAME_WIDTH = 1280; 
        const GAME_HEIGHT = 720;
        canvas.width = GAME_WIDTH; 
        canvas.height = GAME_HEIGHT;

        // --- PALETA DE COLORES ---
        const PALETTE = { 
            metalDark: '#1a1a20',
            metalLight: '#3a3a45',
            rust: '#4a3020',
            hazardOrange: '#cc6600',
            lightCyan: '#00ffee',
            lightRed: '#ff3333',
            shadow: 'rgba(0,0,0,0.7)',
            fog: 'rgba(5, 7, 10, 0.8)'
        };

        // --- UTILIDADES GRÁFICAS ---
        function createMetalGradient(ctx, x, y, height, color1, color2) {
            let grd = ctx.createLinearGradient(x, y, x, y + height);
            grd.addColorStop(0, color1);
            grd.addColorStop(0.5, color2);
            grd.addColorStop(1, color1);
            return grd;
        }
        
        function drawGlow(ctx, x, y, radius, color) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            let grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
            grd.addColorStop(0, color);
            grd.addColorStop(1, 'transparent');
            ctx.fillStyle = grd;
            ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
            ctx.restore();
        }

        // Configuración del bioma
        const currentBiome = { 
            name: "INDUSTRIAL_NOIR", 
            skyTop: '#020305', skyBottom: '#0a0e14',
            layers: [
                { color: '#090a0c', detail: '#0f1116' },
                { color: '#0e1015', detail: '#161820' },
                { color: '#14171f', detail: '#1f2430' },
                { color: '#1c202b', detail: '#2a3040' },
                { color: '#262b38', detail: '#353d50' }
            ]
        };
        
        // --- SISTEMA DE LLUVIA ---
        let rainDrops = [];
        for(let i=0; i<300; i++) {
            rainDrops.push({
                x: Math.random() * GAME_WIDTH,
                y: Math.random() * GAME_HEIGHT,
                length: Math.random() * 20 + 10,
                speed: Math.random() * 10 + 15,
                opacity: Math.random() * 0.3 + 0.1
            });
        }

        function updateAndDrawRain(ctx, cameraX) {
            ctx.save();
            ctx.strokeStyle = PALETTE.lightCyan;
            ctx.lineWidth = 1;
            ctx.beginPath();
            rainDrops.forEach(drop => {
                drop.y += drop.speed;
                // Parallax en la lluvia
                drop.x -= (camera.x - (camera.prevX || camera.x)) * 0.2; 

                if (drop.y > GAME_HEIGHT) {
                    drop.y = -drop.length;
                    drop.x = Math.random() * GAME_WIDTH - cameraX; // Reciclar
                }
                // Dibujo
                ctx.globalAlpha = drop.opacity;
                ctx.moveTo(drop.x, drop.y);
                ctx.lineTo(drop.x - 2, drop.y + drop.length);
            });
            ctx.stroke();
            ctx.restore();
        }

        // --- VARIABLES DE SIMULACIÓN ---
        let gameTime = 0;
        let camera = { x: 0, y: 0, prevX: 0 };
        
        // --- CLASES (PERSONAJES) ---

        class MockPlayer {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.width = 24; this.height = 40;
                this.vx = 0; 
                this.animTimer = 0;
                this.facingRight = true;
                this.state = 'wait'; 
                this.stateTimer = 0;
            }

            update() {
                this.animTimer++;
                this.stateTimer++;
                if (this.state === 'wait') {
                    this.vx = 0;
                    if (this.stateTimer > 60) {
                        this.state = Math.random() > 0.5 ? 'walk_right' : 'walk_left';
                        this.stateTimer = 0;
                    }
                } else if (this.state === 'walk_right') {
                    this.vx = 3; this.facingRight = true; this.x += this.vx;
                    if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
                } else if (this.state === 'walk_left') {
                    this.vx = -3; this.facingRight = false; this.x += this.vx;
                    if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
                }
                // Límites
                if(this.x < 100) { this.x = 100; this.state = 'walk_right'; }
                if(this.x > 600) { this.x = 600; this.state = 'walk_left'; }
            }

            draw(ctx) {
                ctx.save();
                
                // Sombra (Dibujada en coordenadas globales antes de transformar)
                ctx.fillStyle = PALETTE.shadow;
                ctx.beginPath(); ctx.ellipse(this.x + this.width/2, this.y + this.height - 2, 15, 4, 0, 0, Math.PI*2); ctx.fill();

                // Transformación segura para espejar el sprite
                // Trasladamos al punto de pivote (centro-abajo del personaje)
                ctx.translate(this.x + this.width/2, this.y);
                
                let lean = 0; 
                if (Math.abs(this.vx) > 1) lean = 3;
                
                if (!this.facingRight) ctx.scale(-1, 1); // Voltear eje X
                ctx.rotate(lean * 0.05); // Rotar un poco al correr
                
                // Dibujamos relativo al 0,0 (que ahora es la posición del jugador)
                // Restamos width/2 para centrar el dibujo en X
                let dx = -this.width/2;
                let dy = 0;

                const armorDark = '#2a2a35';
                const armorLight = '#5a5a68';
                const accent = PALETTE.lightCyan;

                // Piernas
                let cycle = Math.sin(this.animTimer * 0.5);
                let legOffset = (Math.abs(this.vx) > 0.5) ? cycle * 3 : 0;
                
                ctx.fillStyle = createMetalGradient(ctx, dx+14, dy+25, 15, armorDark, armorLight);
                ctx.fillRect(dx + 14, dy + 25, 6, 15 - legOffset);
                ctx.fillStyle = createMetalGradient(ctx, dx+4, dy+25, 15, armorLight, armorDark);
                ctx.fillRect(dx + 4, dy + 25, 6, 15 + legOffset);

                // Torso
                let torsoGrd = ctx.createLinearGradient(dx, dy + 10, dx + this.width, dy + 28);
                torsoGrd.addColorStop(0, armorLight); torsoGrd.addColorStop(1, armorDark);
                ctx.fillStyle = torsoGrd;
                ctx.beginPath();
                ctx.moveTo(dx, dy+10); ctx.lineTo(dx+this.width, dy+12);
                ctx.lineTo(dx+this.width-2, dy+28); ctx.lineTo(dx+2, dy+28);
                ctx.fill();
                
                // Mochila
                ctx.fillStyle = '#222'; ctx.fillRect(dx - 5, dy + 12, 6, 14);
                drawGlow(ctx, dx - 2, dy + 19, 8, accent); 

                // Casco
                ctx.fillStyle = createMetalGradient(ctx, dx+2, dy, 12, armorLight, armorDark);
                ctx.beginPath();
                ctx.moveTo(dx+2, dy); ctx.lineTo(dx+22, dy+1);
                ctx.lineTo(dx+20, dy+12); ctx.lineTo(dx+4, dy+12);
                ctx.fill();
                
                // Visor
                ctx.fillStyle = accent; ctx.fillRect(dx + 12, dy + 4, 10, 3);
                drawGlow(ctx, dx + 17, dy + 5, 10, accent);

                // Arma
                ctx.fillStyle = '#111';
                let gunX = dx + 12; let gunY = dy + 16;
                ctx.fillRect(gunX, gunY, 18, 5);
                drawGlow(ctx, gunX + 16, gunY + 2, 5, accent);
                ctx.fillStyle = accent; ctx.fillRect(gunX+14, gunY+1, 3, 2);

                ctx.restore();
            }
        }

        class MockWalker {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.width = 30; this.height = 30;
                this.vx = 2; this.dir = 1; this.timer = 0;
                this.state = 'walk'; this.startX = x; this.waitTimer = 0;
            }

            update() {
                this.timer++;
                if (this.state === 'walk') {
                    this.x += this.vx;
                    if (Math.abs(this.x - this.startX) > 150) {
                        this.state = 'wait'; this.waitTimer = 60;
                    }
                } else if (this.state === 'wait') {
                    this.waitTimer--;
                    if (this.waitTimer <= 0) {
                        this.dir *= -1; this.vx = this.dir * 2; this.state = 'walk';
                    }
                }
            }

            draw(ctx) {
                let anim = Math.sin(this.timer * 0.2);
                let drawY = this.y - 10;
                
                ctx.save();
                // Sombra
                ctx.fillStyle = PALETTE.shadow;
                ctx.beginPath(); ctx.ellipse(this.x + this.width/2, drawY + this.height + 10, 20, 5, 0, 0, Math.PI*2); ctx.fill();

                const hullColor = '#502020'; 
                const mechRust = PALETTE.rust;
                const eyeColor = PALETTE.lightRed;

                // Piernas
                ctx.fillStyle = '#222';
                ctx.fillRect(this.x + 5, drawY + 28, 6, 12 + anim * 5);
                ctx.fillStyle = mechRust; ctx.fillRect(this.x + 4, drawY + 38 + anim * 5, 8, 4);
                ctx.fillStyle = '#222';
                ctx.fillRect(this.x + 20, drawY + 28, 6, 12 - anim * 5);
                ctx.fillStyle = mechRust; ctx.fillRect(this.x + 19, drawY + 38 - anim * 5, 8, 4);

                // Cuerpo
                let hullGrd = createMetalGradient(ctx, this.x, drawY, this.height, hullColor, '#301010');
                ctx.fillStyle = hullGrd;
                ctx.beginPath();
                ctx.moveTo(this.x - 2, drawY + 5); ctx.lineTo(this.x + this.width + 2, drawY + 5);
                ctx.lineTo(this.x + this.width, drawY + this.height - 2); ctx.lineTo(this.x, drawY + this.height - 2);
                ctx.fill();
                
                // Detalles
                ctx.fillStyle = mechRust; ctx.fillRect(this.x, drawY+15, this.width, 2);
                
                // Ojo
                ctx.fillStyle = '#000'; ctx.fillRect(this.x + 10, drawY + 8, 12, 8);
                drawGlow(ctx, this.x + 16, drawY + 12, 8, eyeColor);
                ctx.fillStyle = '#fff'; ctx.fillRect(this.x + 14, drawY + 10, 4, 4);

                // Brazos
                let armColor = '#444';
                ctx.save(); ctx.translate(this.x + 2, drawY + 18); ctx.rotate(anim*0.5); 
                ctx.fillStyle = armColor; ctx.fillRect(-2, -2, 6, 14);
                ctx.restore();

                ctx.save(); ctx.translate(this.x + 28, drawY + 18); ctx.rotate(-anim*0.5); 
                ctx.fillStyle = armColor; ctx.fillRect(-2, -2, 6, 14);
                ctx.restore();

                ctx.restore();
            }
        }

        class MockFlyer {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.width = 30; this.height = 20;
                this.startX = x; this.timer = 0;
            }

            update() {
                this.timer++;
                this.x = this.startX + Math.sin(this.timer * 0.02) * 200;
                this.y += Math.cos(this.timer * 0.05) * 1; 
            }

            draw(ctx) {
                let hover = Math.sin(this.timer * 0.1) * 2;
                let drawY = this.y + hover;
                
                const droneMetal = PALETTE.metalLight;
                const engineGlow = PALETTE.hazardOrange;

                ctx.save();
                // Cuerpo
                let bodyGrd = createMetalGradient(ctx, this.x, drawY, 20, droneMetal, '#222');
                ctx.fillStyle = bodyGrd;
                ctx.beginPath();
                ctx.moveTo(this.x, drawY+5); ctx.lineTo(this.x+this.width, drawY+5); 
                ctx.lineTo(this.x+this.width-5, drawY+15); ctx.lineTo(this.x+5, drawY+15); 
                ctx.fill();

                // Rotores
                ctx.fillStyle = '#1a1a1a';
                ctx.beginPath(); ctx.moveTo(this.x+2, drawY+5); ctx.lineTo(this.x-8, drawY); ctx.lineTo(this.x-8, drawY+10); ctx.fill();
                ctx.beginPath(); ctx.moveTo(this.x+this.width-2, drawY+5); ctx.lineTo(this.x+this.width+8, drawY); ctx.lineTo(this.x+this.width+8, drawY+10); ctx.fill();

                // Motores
                drawGlow(ctx, this.x, drawY + 10, 10, engineGlow);
                drawGlow(ctx, this.x + this.width, drawY + 10, 10, engineGlow);

                ctx.restore();
            }
        }

        // --- INICIALIZACIÓN ---
        const player = new MockPlayer(200, 500);
        const walker = new MockWalker(800, 450);
        const flyer = new MockFlyer(600, 200);

        const platforms = [
            { x: 0, y: 540, width: 800, height: 200, type: 'floor' }, 
            { x: 750, y: 490, width: 400, height: 20, type: 'plat' }
        ];

        // --- FONDO ---
        function drawBackground(ctx, cameraX, cameraY) {
            let skyGrd = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
            skyGrd.addColorStop(0, currentBiome.skyTop);
            skyGrd.addColorStop(1, currentBiome.skyBottom);
            ctx.fillStyle = skyGrd;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const layersConfig = [
                { speed: 0.02, colors: currentBiome.layers[0], baseHeight: 200, density: 0.3, fog: 0.9 },
                { speed: 0.1, colors: currentBiome.layers[1], baseHeight: 300, density: 0.5, fog: 0.7 },
                { speed: 0.25, colors: currentBiome.layers[2], baseHeight: 400, density: 0.6, fog: 0.5 },
                { speed: 0.5, colors: currentBiome.layers[3], baseHeight: 550, density: 0.7, fog: 0.3 },
                { speed: 0.8, colors: currentBiome.layers[4], baseHeight: 650, density: 0.8, fog: 0.1 }
            ];
            
            layersConfig.forEach((layer, index) => {
                ctx.save(); 
                let parallaxX = -cameraX * layer.speed; 
                let parallaxY = -cameraY * (layer.speed * 0.2) + (GAME_HEIGHT - layer.baseHeight); 
                
                ctx.translate(parallaxX, parallaxY);

                let seed = index * 134.5; 
                let totalW = 200; 
                let startI = Math.floor(-parallaxX / totalW) - 2; 
                let endI = startI + Math.ceil(GAME_WIDTH / totalW) + 4;
                
                for (let i = startI; i < endI; i++) {
                    let posX = i * totalW;
                    let hRandom = Math.sin(seed + i * 12.1) * 0.5 + 0.5; 
                    let height = 100 + hRandom * 300; 
                    let shapeType = Math.floor(Math.cos(seed + i * 45.3) * 3) + 3;

                    let bldgGrd = ctx.createLinearGradient(posX, 0, posX, height);
                    bldgGrd.addColorStop(0, layer.colors.color);
                    bldgGrd.addColorStop(1, layer.colors.detail);
                    ctx.fillStyle = bldgGrd;

                    if (shapeType % 3 === 0) { 
                        ctx.fillRect(posX, -height, totalW - 10, height + 800);
                    } else if (shapeType % 3 === 1) { 
                         ctx.fillRect(posX + 20, -height, totalW - 40, height + 800);
                    } else { 
                        ctx.fillRect(posX, -height, 20, height + 800);
                        ctx.fillRect(posX + totalW - 30, -height, 20, height + 800);
                    }
                    
                    if (index > 1 && layer.density > 0.5 && hRandom > 0.3) {
                        ctx.fillStyle = (Math.random() > 0.8) ? PALETTE.hazardOrange : PALETTE.lightCyan;
                        ctx.globalAlpha = 0.3;
                        for(let w=0; w<5; w++) {
                            if(Math.random() > 0.6) continue;
                             ctx.fillRect(posX + 20 + (w%3)*30, -height + 50 + Math.floor(w/3)*40, 15, 3);
                        }
                        ctx.globalAlpha = 1.0;
                    }
                }
                ctx.restore();

                if (layer.fog > 0) {
                    ctx.fillStyle = PALETTE.fog;
                    ctx.globalAlpha = layer.fog;
                    ctx.fillRect(0,0,GAME_WIDTH, GAME_HEIGHT);
                    ctx.globalAlpha = 1.0;
                }
            });
        }

        // --- MAPA ---
        function drawMap(ctx) {
            platforms.forEach(p => {
                ctx.save();
                ctx.fillStyle = PALETTE.shadow;
                ctx.fillRect(p.x + 10, p.y + p.height, p.width - 20, 20);

                let baseGrd = createMetalGradient(ctx, p.x, p.y, p.height, '#22222a', '#111115');
                ctx.fillStyle = baseGrd;
                ctx.fillRect(p.x, p.y, p.width, p.height);
                
                let topGrd = createMetalGradient(ctx, p.x, p.y, 10, '#555566', '#333344');
                ctx.fillStyle = topGrd;
                ctx.fillRect(p.x, p.y, p.width, 12);

                ctx.beginPath();
                ctx.strokeStyle = 'rgba(0,0,0,0.4)'; ctx.lineWidth = 2;
                for(let i=0; i < p.width; i+=10) {
                    ctx.moveTo(p.x + i, p.y); ctx.lineTo(p.x + i - 5, p.y + 12);
                }
                ctx.stroke();

                if (p.type === 'floor') {
                    ctx.fillStyle = PALETTE.hazardOrange;
                    for(let i=0; i < p.width; i+=60) ctx.fillRect(p.x + i, p.y + 12, 30, 4);
                } else {
                    for(let i=40; i < p.width; i+=100) {
                        drawGlow(ctx, p.x + i, p.y + p.height - 5, 15, PALETTE.lightCyan);
                        ctx.fillStyle = '#fff'; ctx.fillRect(p.x + i - 5, p.y + p.height - 8, 10, 4);
                    }
                }
                ctx.restore();
            });
        }

        // --- BUCLE PRINCIPAL ---
        function loop() {
            try {
                gameTime++;
                camera.prevX = camera.x;
                camera.x = Math.sin(gameTime * 0.005) * 300;
                
                player.update(); walker.update(); flyer.update();

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                drawBackground(ctx, camera.x, camera.y);
                updateAndDrawRain(ctx, camera.x);

                ctx.save();
                let screenOffsetX = camera.x - GAME_WIDTH/2 + 200;
                ctx.translate(-screenOffsetX, 0); 

                drawMap(ctx);
                
                // Entidades
                // Para dibujar entidades que "siguen" la cámara en esta demo (para que no se vayan de pantalla)
                ctx.save();
                ctx.translate(screenOffsetX, 0); 
                player.draw(ctx);
                walker.draw(ctx);
                flyer.draw(ctx);
                ctx.restore();
                
                ctx.restore();

                // Overlay final
                ctx.globalCompositeOperation = 'overlay';
                ctx.fillStyle = 'rgba(0, 10, 30, 0.3)';
                ctx.fillRect(0,0,GAME_WIDTH, GAME_HEIGHT);
                ctx.globalCompositeOperation = 'source-over';

                requestAnimationFrame(loop);
            } catch (err) {
                console.error(err);
                document.getElementById('error-log').innerText = "Error en Loop: " + err.message;
            }
        }

        // Iniciar
        loop();
    } catch (e) {
        document.getElementById('debug-ui').innerHTML += `<br><span style="color:red">CRITICAL ERROR: ${e.message}</span>`;
    }
</script>
</body>
</html>