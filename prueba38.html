<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shootman: Alien Mothership v2</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000508;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #game-container {
            position: relative;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.1); /* Glow cian sutil */
            border: 4px solid #002233;
            background: #000;
            width: 100%;
            max-width: 1280px;
            aspect-ratio: 16/9;
        }
        canvas {
            display: block;
            background-color: #000;
            image-rendering: pixelated;
            width: 100%;
            height: 100%;
        }
        /* Efecto CRT/Holograma */
        #scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: 
                linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%),
                linear-gradient(90deg, rgba(0, 255, 255, 0.03), rgba(255, 0, 255, 0.03));
            background-size: 100% 3px, 4px 100%;
            pointer-events: none;
            z-index: 100;
        }
        #vignette {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,20,30,0.8) 100%);
            pointer-events: none;
            z-index: 101;
        }
        #debug-ui {
            position: absolute; top: 10px; left: 10px; color: #00ffff; z-index: 120;
            background: rgba(0, 10, 20, 0.9); 
            border-left: 3px solid #00ffff;
            padding: 10px 20px;
            font-size: 14px;
            text-shadow: 0 0 5px #00ffff;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="testCanvas"></canvas>
    <div id="scanlines"></div>
    <div id="vignette"></div>
    <div id="debug-ui">
        <h3>NIVEL 4: CUBIERTA DE OBSERVACIÓN</h3>
        <p>SECTOR: ESPACIO PROFUNDO</p>
        <p>ESTADO: BIO-CONTAMINACIÓN</p>
    </div>
</div>

<script>
    const canvas = document.getElementById('testCanvas');
    const ctx = canvas.getContext('2d');
    
    const GAME_WIDTH = 1280; 
    const GAME_HEIGHT = 720;
    canvas.width = GAME_WIDTH; 
    canvas.height = GAME_HEIGHT;

    // --- PALETA DE COLORES ALIEN ---
    const COLORS = { 
        player: '#e0e0e0', 
        playerAccent: '#00ffff', // Acento cambiado a cian para encajar mejor
        
        bgSpace: '#020205',
        star: '#ffffff',
        
        alienDark: '#050a0f',
        alienMid: '#0f1a25',
        alienLight: '#1f3a4a',
        
        neonCyan: '#00ffee',
        neonGreen: '#00ff44',
        neonPurple: '#aa00ff',
        
        cable: '#112233'
    };
    
    const ENEMY_COLOR = '#ff3366'; // Rosado neón para enemigos

    // --- VARIABLES DE SIMULACIÓN ---
    let gameTime = 0;
    let camera = { x: 0, y: 0 };
    
    // --- SISTEMA DE PARTÍCULAS ---
    const particles = [];

    class Particle {
        constructor(x, y, type) {
            this.x = x; this.y = y;
            this.type = type; 
            this.life = 1.0;
            
            if (type === 'spark') {
                this.vx = (Math.random() - 0.5) * 5;
                this.vy = (Math.random() - 0.5) * 5;
                this.decay = 0.05;
                this.color = COLORS.neonCyan;
                this.size = Math.random() * 2 + 1;
            } else if (type === 'dust') {
                this.vx = (Math.random() - 0.5) * 0.2;
                this.vy = (Math.random() - 0.5) * 0.2;
                this.decay = 0.002;
                this.color = 'rgba(200, 255, 255, 0.5)';
                this.size = Math.random() * 1.5;
            }
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life -= this.decay;
        }
        draw(ctx) {
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, this.size, this.size);
            ctx.globalAlpha = 1.0;
        }
    }

    function spawnParticles() {
        if (Math.random() < 0.4) { // Polvo espacial constante
            particles.push(new Particle(Math.random() * GAME_WIDTH, Math.random() * GAME_HEIGHT, 'dust'));
        }
        // Chispas aleatorias de cables en el techo
        if (Math.random() < 0.05) {
            let sparkX = Math.random() * GAME_WIDTH;
            for(let i=0; i<5; i++) particles.push(new Particle(sparkX, 50, 'spark'));
        }
    }

    // --- ENTIDADES (MANTENEMOS LÓGICA Y TAMAÑOS) ---
    class MockPlayer {
        constructor(x, y) {
            this.x = x; this.y = y; this.width = 24; this.height = 40;
            this.vx = 0; this.animTimer = 0; this.facingRight = true; this.state = 'wait'; this.stateTimer = 0;
        }
        update() {
            this.animTimer++; this.stateTimer++;
            if (this.state === 'wait') {
                this.vx = 0;
                if (this.stateTimer > 60) { this.state = Math.random() > 0.5 ? 'walk_right' : 'walk_left'; this.stateTimer = 0; }
            } else if (this.state === 'walk_right') {
                this.vx = 3; this.facingRight = true; this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
            } else if (this.state === 'walk_left') {
                this.vx = -3; this.facingRight = false; this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
            }
            if(this.x < 100) { this.x = 100; this.state = 'walk_right'; }
            if(this.x > 600) { this.x = 600; this.state = 'walk_left'; }
        }
        draw(ctx) {
            ctx.save(); 
            ctx.translate(Math.round(this.x), Math.round(this.y));
            
            // Glow tecno
            ctx.shadowColor = COLORS.neonCyan; ctx.shadowBlur = 5;

            let lean = 0; if (Math.abs(this.vx) > 1) lean = this.facingRight ? 3 : -3; 
            ctx.translate(lean, 0);
            
            ctx.fillStyle = COLORS.player;
            if (Math.abs(this.vx) > 0.5) {
                let cycle = Math.sin(this.animTimer * 0.5);
                ctx.fillRect(4, 25, 6, 15 + cycle * 3); ctx.fillRect(14, 25, 6, 15 - cycle * 3);
            } else { 
                ctx.fillRect(4, 25, 6, 15); ctx.fillRect(14, 25, 6, 15); 
            }
            ctx.fillStyle = '#fff'; ctx.fillRect(0, 10, this.width, 18);
            ctx.fillStyle = '#55f'; ctx.fillRect(this.facingRight ? -4 : 20, 12, 4, 10);
            ctx.fillStyle = '#333'; ctx.fillRect(2, 0, 20, 12);
            ctx.fillStyle = COLORS.playerAccent; ctx.fillRect(this.facingRight ? 12 : 2, 3, 10, 4);
            ctx.fillStyle = '#555';
            let gunX = this.facingRight ? 14 : -6; 
            ctx.fillRect(gunX, 14, 16, 6);
            ctx.restore();
        }
    }

    class MockWalker {
        constructor(x, y) {
            this.x = x; this.y = y; this.width = 30; this.height = 30; this.vx = 2; this.dir = 1; this.timer = 0; this.state = 'walk'; this.startX = x;
        }
        update() {
            this.timer++;
            if (this.state === 'walk') {
                this.x += this.vx;
                if (Math.abs(this.x - this.startX) > 150) { this.state = 'wait'; this.waitTimer = 60; }
            } else if (this.state === 'wait') {
                this.waitTimer--;
                if (this.waitTimer <= 0) { this.dir *= -1; this.vx = this.dir * 2; this.state = 'walk'; }
            }
        }
        draw(ctx) {
            ctx.save(); ctx.translate(this.x, this.y - 10);
            ctx.shadowColor = ENEMY_COLOR; ctx.shadowBlur = 8;
            ctx.fillStyle = ENEMY_COLOR;
            let anim = Math.sin(this.timer * 0.2);
            ctx.fillRect(0, 0, this.width, this.height);
            ctx.fillStyle = '#fff'; ctx.fillRect(10, 5, 10, 10); ctx.fillStyle = '#f00'; ctx.fillRect(13, 8, 4, 4);
            ctx.fillStyle = ENEMY_COLOR; 
            ctx.save(); ctx.translate(5, 15); ctx.rotate(anim); ctx.fillRect(0, 0, 5, 15); ctx.restore();
            ctx.save(); ctx.translate(25, 15); ctx.rotate(-anim); ctx.fillRect(0, 0, 5, 15); ctx.restore();
            ctx.fillRect(5, 30, 5, 10 + anim * 5); ctx.fillRect(20, 30, 5, 10 - anim * 5);
            ctx.restore();
        }
    }

    class MockFlyer {
        constructor(x, y) {
            this.x = x; this.y = y; this.width = 30; this.height = 20; this.startX = x; this.timer = 0;
        }
        update() {
            this.timer++;
            this.x = this.startX + Math.sin(this.timer * 0.02) * 200;
            this.y += Math.cos(this.timer * 0.05) * 1; 
        }
        draw(ctx) {
            let flap = Math.sin(this.timer * 0.8) * 10;
            ctx.save(); ctx.translate(this.x, this.y);
            ctx.shadowColor = ENEMY_COLOR; ctx.shadowBlur = 8;
            ctx.fillStyle = ENEMY_COLOR;
            ctx.fillRect(0, 0, 30, 20); 
            ctx.fillStyle = '#777'; 
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-10, -10 + flap); ctx.lineTo(10, 0); ctx.fill();
            ctx.beginPath(); ctx.moveTo(30, 0); ctx.lineTo(40, -10 + flap); ctx.lineTo(20, 0); ctx.fill(); 
            ctx.fillStyle = '#ff0'; ctx.fillRect(10, 5, 10, 5);
            ctx.restore();
        }
    }

    // --- INSTANCIAS ---
    const player = new MockPlayer(200, 500);
    const walker = new MockWalker(800, 450);
    const flyer = new MockFlyer(600, 200);

    const platforms = [
        { x: 0, y: 540, width: 800, height: 200 },
        { x: 750, y: 490, width: 400, height: 20 }
    ];

    // --- DIBUJADO DE FONDO (5 CAPAS) ---
    // Estrategia: "Sándwich". Estrellas al fondo, ventanal en medio, estructura arriba y abajo.

    function drawAlienBackground(ctx, camX, camY) {
        
        // --- 0. FONDO BASE (Espacio) ---
        ctx.fillStyle = COLORS.bgSpace;
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        // --- 1. ESTRELLAS Y NEBULOSAS LEJANAS ---
        ctx.save();
        ctx.translate(-camX * 0.02, -camY * 0.02);
        
        // Nebulosa procedural simple (gradientes grandes)
        let grad = ctx.createRadialGradient(GAME_WIDTH/2, GAME_HEIGHT/2, 100, GAME_WIDTH/2, GAME_HEIGHT/2, 800);
        grad.addColorStop(0, 'rgba(0, 50, 80, 0.2)');
        grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        // Estrellas
        ctx.fillStyle = COLORS.star;
        for(let i=0; i<150; i++) {
            // Posiciones deterministas para que no parpadeen al moverse
            let sx = (i * 913.5) % (GAME_WIDTH * 2); 
            let sy = (i * 123.4) % GAME_HEIGHT;
            let size = (i % 7 === 0) ? 2 : 1;
            let alpha = 0.3 + Math.abs(Math.sin(gameTime * 0.01 + i)); // Twinkle
            
            ctx.globalAlpha = alpha;
            ctx.fillRect(sx, sy, size, size);
        }
        ctx.globalAlpha = 1;
        ctx.restore();

        // --- 2. NAVES/ESTRUCTURAS EXTERIORES (Siluetas en el ventanal) ---
        ctx.save();
        ctx.translate(-camX * 0.05, -camY * 0.05);
        ctx.fillStyle = '#08111a';
        // Una gran nave pasando lejos
        let shipX = (gameTime * 0.2) % (GAME_WIDTH + 500) - 200;
        ctx.beginPath();
        ctx.moveTo(shipX, 300);
        ctx.lineTo(shipX + 200, 280);
        ctx.lineTo(shipX + 180, 320);
        ctx.fill();
        // Luz parpadeante en la nave
        if (Math.floor(gameTime / 20) % 2 === 0) {
            ctx.fillStyle = 'red';
            ctx.fillRect(shipX + 190, 298, 4, 4);
        }
        ctx.restore();

        // --- 3. ESTRUCTURA PRINCIPAL (VENTANAL) ---
        // Aquí dibujamos las partes de arriba y abajo que tapan el espacio,
        // dejando el hueco central (el ventanal).
        
        ctx.save();
        ctx.translate(-camX * 0.2, -camY * 0.2);
        
        // Color base de la pared interior
        ctx.fillStyle = COLORS.alienDark;
        
        // TECHO DENSO (Hasta Y=150 aprox)
        ctx.fillRect(-100, -100, GAME_WIDTH + 200, 250); // Bloque sólido arriba
        
        // SUELO DENSO (Desde Y=550 aprox)
        ctx.fillRect(-100, 550, GAME_WIDTH + 200, 300); // Bloque sólido abajo

        // MARCOS DEL VENTANAL (Verticales que se repiten)
        let pillarGap = 600;
        let startP = Math.floor((-camX * 0.2) / pillarGap) - 1;
        
        for(let i = startP; i < startP + 5; i++) {
            let px = i * pillarGap;
            
            // Columna gruesa
            let colGrad = ctx.createLinearGradient(px, 0, px+100, 0);
            colGrad.addColorStop(0, COLORS.alienDark);
            colGrad.addColorStop(0.5, COLORS.alienMid);
            colGrad.addColorStop(1, COLORS.alienDark);
            ctx.fillStyle = colGrad;
            
            // Forma de soporte en I
            ctx.fillRect(px, 0, 80, GAME_HEIGHT);
            
            // Detalles tecnológicos en la columna
            ctx.fillStyle = '#000';
            ctx.fillRect(px + 20, 100, 40, 520); // Hueco interior columna
            
            // Luces de estado verticales
            ctx.fillStyle = COLORS.neonGreen;
            let lightY = (gameTime * 2) % 500 + 100;
            ctx.fillRect(px + 35, lightY, 10, 5);
        }
        ctx.restore();

        // --- 4. CABLES Y TUBERÍAS (COLGANDO Y EN SUELO) ---
        ctx.save();
        ctx.translate(-camX * 0.4, -camY * 0.4);
        
        // Cables procedurales (curvas bezier)
        ctx.lineWidth = 3;
        ctx.strokeStyle = '#1a2a3a';
        
        for(let i = -1; i < 6; i++) {
            let cx = i * 300;
            
            // Mazo de cables techo
            ctx.beginPath();
            ctx.moveTo(cx, 0);
            ctx.bezierCurveTo(cx, 150, cx+100, 150, cx+100, 0);
            ctx.stroke();
            
            // Cables sueltos colgando
            if (i % 2 === 0) {
                ctx.strokeStyle = '#2a3a4a';
                ctx.beginPath();
                ctx.moveTo(cx + 50, 0);
                // Oscilación
                let swing = Math.sin(gameTime * 0.02 + i) * 10;
                ctx.quadraticCurveTo(cx + 50, 100, cx + 50 + swing, 180);
                ctx.stroke();
                
                // Luz en la punta del cable
                ctx.fillStyle = COLORS.neonPurple;
                ctx.fillRect(cx + 48 + swing, 180, 4, 4);
            }
        }
        ctx.restore();

        // --- 5. DETALLES FINOS DE ESTRUCTURA (Paneles, Rejillas) ---
        ctx.save();
        ctx.translate(-camX * 0.6, -camY * 0.6);
        
        let panelSize = 200;
        let startPanel = Math.floor((-camX * 0.6) / panelSize) - 1;
        
        for(let i = startPanel; i < startPanel + 10; i++) {
            let pnx = i * panelSize;
            // Solo dibujamos detalles en las franjas superior e inferior (no en el ventanal)
            
            // Detalle Techo
            ctx.fillStyle = COLORS.alienMid;
            ctx.fillRect(pnx + 10, 20, 180, 50);
            // Rejilla
            ctx.fillStyle = '#000';
            for(let r=0; r<180; r+=20) ctx.fillRect(pnx + 10 + r, 30, 10, 30);
            
            // Detalle Suelo (Debajo de la línea de visión)
            ctx.fillStyle = COLORS.alienMid;
            ctx.fillRect(pnx + 50, 600, 100, 50);
            // Luz roja pequeña
            ctx.fillStyle = 'red';
            ctx.fillRect(pnx + 60, 620, 5, 5);
        }
        ctx.restore();
    }

    // --- DIBUJADO DE PLATAFORMAS TECH ---
    function drawTechPlatforms(ctx) {
        platforms.forEach(p => {
            ctx.save();
            ctx.translate(p.x, p.y);

            // 1. Estructura principal (Metálica oscura)
            let grad = ctx.createLinearGradient(0, 0, 0, p.height);
            grad.addColorStop(0, COLORS.alienLight);
            grad.addColorStop(1, COLORS.alienDark);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, p.width, p.height);

            // 2. Patrón de panal (Hexagon Grid Pattern simplificado)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            for(let i=0; i<p.width; i+=40) {
                ctx.fillRect(i, 0, 2, p.height);
            }
            
            // 3. Borde superior iluminado (Neon)
            ctx.shadowColor = COLORS.neonCyan;
            ctx.shadowBlur = 15;
            ctx.fillStyle = COLORS.neonCyan;
            ctx.fillRect(0, 0, p.width, 3);
            ctx.shadowBlur = 0;

            // 4. Detalles laterales (Antenas)
            if (p.height < 50) { // Plataformas flotantes
                ctx.fillStyle = '#555';
                // Antena abajo
                ctx.fillRect(20, p.height, 2, 20);
                ctx.fillStyle = 'red';
                // Luz parpadeante antena
                if (Math.sin(gameTime * 0.2) > 0) ctx.fillRect(19, p.height + 18, 4, 4);
                
                // Soporte diagonal
                ctx.strokeStyle = COLORS.alienLight;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(0, p.height);
                ctx.lineTo(20, p.height + 10);
                ctx.stroke();
            }

            // 5. Cables colgando de la plataforma
            if (p.height > 50) {
                ctx.strokeStyle = '#111';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(50, p.height);
                ctx.bezierCurveTo(50, p.height+50, 100, p.height+50, 100, p.height);
                ctx.stroke();
            }

            ctx.restore();
        });
    }

    // --- CAPAS FRONTALES (FOREGROUND) ---
    function drawForeground(ctx, camX, camY) {
        // Objetos muy cercanos y borrosos que dan profundidad
        
        ctx.save();
        let pXF = -camX * 1.3;
        ctx.translate(pXF, -camY * 1.3);
        
        // Grandes tuberías/cables verticales desenfocados
        ctx.fillStyle = 'rgba(0, 10, 15, 0.9)';
        for(let i=0; i<5; i++) {
            let off = i * 800 + 400;
            ctx.fillRect(off, 0, 80, GAME_HEIGHT);
            
            // Detalles luz (Blurred)
            ctx.fillStyle = 'rgba(0, 255, 255, 0.1)';
            ctx.fillRect(off + 20, 0, 10, GAME_HEIGHT);
            ctx.fillStyle = 'rgba(0, 10, 15, 0.9)'; // Reset color
        }
        
        ctx.restore();
    }

    function loop() {
        gameTime++;
        // Auto-scroll cámara
        camera.x = Math.sin(gameTime * 0.005) * 200 + 200; 
        camera.y = Math.cos(gameTime * 0.003) * 20; // Leve movimiento vertical para flotar

        spawnParticles();
        player.update();
        walker.update();
        flyer.update();
        particles.forEach((p, i) => {
            p.update();
            if(p.life <= 0) particles.splice(i, 1);
        });

        // --- RENDER ---
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 1. Fondo (Espacio + Estructura Ventanal)
        drawAlienBackground(ctx, camera.x, camera.y);
        
        // 2. Mundo Juego
        ctx.save();
        ctx.translate(-camera.x + 200, -camera.y); // Aplicamos también Y levemente

        drawTechPlatforms(ctx);
        
        // Entidades (Hack visual previo para demo)
        ctx.save();
        ctx.translate(camera.x - 200, camera.y); 
        ctx.restore();
        
        let sOffX = camera.x;
        let sOffY = camera.y;

        ctx.save();
        ctx.translate(sOffX - 200, sOffY); 
        ctx.translate(-sOffX + 200, -sOffY); 
            
            // Personajes
            player.draw(ctx);
            walker.draw(ctx);
            flyer.draw(ctx);
            
            // Partículas
            particles.forEach(p => p.draw(ctx));
            
        ctx.restore();
        ctx.restore();

        // 3. Primer Plano
        drawForeground(ctx, camera.x, camera.y);

        requestAnimationFrame(loop);
    }

    loop();

</script>
</body>
</html>