<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Shootman: Alien Mothership Level Test</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #020205;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #game-container {
            position: relative;
            box-shadow: 0 0 60px rgba(0, 255, 255, 0.1); /* Glow externo sutil */
            border: 2px solid #1a1a2e;
            background: #000;
            width: 1280px;
            height: 720px;
        }
        canvas {
            display: block;
            background-color: #050508;
            width: 100%;
            height: 100%;
        }
        /* Scanlines mejoradas para estilo sci-fi */
        #scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 255, 255, 0.05) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 3px, 3px 100%;
            pointer-events: none;
            z-index: 10;
            opacity: 0.6;
        }
        /* Vignette para oscurecer bordes */
        #vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.8) 100%);
            pointer-events: none;
            z-index: 11;
        }
        #debug-ui {
            position: absolute; top: 20px; left: 20px; 
            color: #00ffff; 
            text-shadow: 0 0 5px #00ffff;
            z-index: 20;
            background: rgba(0, 10, 20, 0.8); 
            border: 1px solid #00ffff;
            padding: 15px;
            font-size: 12px;
            border-radius: 4px;
        }
        h3 { margin: 0 0 10px 0; letter-spacing: 2px; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="testCanvas"></canvas>
    <div id="scanlines"></div>
    <div id="vignette"></div>
    <div id="debug-ui">
        <h3>NIVEL 4: MOTHERSHIP</h3>
        <p>Bioma: ALIEN CORE</p>
        <p>Física de Partículas: ACTIVA</p>
        <p>Capas Parallax: 5 + FG</p>
    </div>
</div>

<script>
    const canvas = document.getElementById('testCanvas');
    const ctx = canvas.getContext('2d');
    const GAME_WIDTH = 1280; 
    const GAME_HEIGHT = 720;
    canvas.width = GAME_WIDTH; 
    canvas.height = GAME_HEIGHT;

    // --- NUEVA CONFIGURACIÓN DE COLORES (ALIEN TECH) ---
    const COLORS = { 
        player: '#c0c0e0',      // Plata azulado
        playerAccent: '#00ffff', // Luz Cian
        bullet: '#ff00ff',       // Magenta plasma
        enemy: '#ff4444',        // Rojo alerta
        metalDark: '#0a0a12',
        metalLight: '#1f1f2e',
        glow: '#00ddee'
    };

    // --- SISTEMA DE PARTÍCULAS ---
    class Particle {
        constructor(x, y, type) {
            this.x = x; this.y = y;
            this.type = type; // 'spark', 'dust', 'thrust'
            this.life = 1.0;
            
            if (type === 'spark') {
                this.vx = (Math.random() - 0.5) * 6;
                this.vy = (Math.random() - 0.5) * 6;
                this.size = Math.random() * 2 + 1;
                this.gravity = 0.2;
                this.color = '#00ffff';
            } else if (type === 'dust') {
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                this.size = Math.random() * 3;
                this.gravity = 0;
                this.color = `rgba(100, 200, 255, ${Math.random() * 0.3})`;
            } else if (type === 'thrust') {
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = Math.random() * 2;
                this.size = Math.random() * 4 + 2;
                this.gravity = -0.05;
                this.color = '#ff00ff';
            }
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += this.gravity;
            this.life -= 0.015;
            
            // Rebote simple en suelo (aprox Y=540)
            if (this.type === 'spark' && this.y > 540) {
                this.y = 540;
                this.vy *= -0.6; // Pérdida de energía
                this.vx *= 0.8;  // Fricción
            }
        }

        draw(ctx) {
            ctx.globalAlpha = Math.max(0, this.life);
            ctx.fillStyle = this.color;
            
            if (this.type === 'spark' || this.type === 'thrust') {
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
            } else {
                ctx.shadowBlur = 0;
            }
            
            ctx.fillRect(this.x, this.y, this.size, this.size);
            ctx.shadowBlur = 0; // Reset
            ctx.globalAlpha = 1;
        }
    }

    let particles = [];
    function spawnParticles(x, y, count, type) {
        for(let i=0; i<count; i++) particles.push(new Particle(x, y, type));
    }

    // --- CLASES DE ENTIDADES (Lógica mantenida, Visuales mejorados) ---

    class MockPlayer {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 24; this.height = 40;
            this.vx = 0; 
            this.animTimer = 0;
            this.facingRight = true;
            this.state = 'wait';
            this.stateTimer = 0;
        }

        update() {
            this.animTimer++;
            this.stateTimer++;
            
            // IA Movimiento (Misma lógica original)
            if (this.state === 'wait') {
                this.vx = 0;
                if (this.stateTimer > 60) { 
                    this.state = Math.random() > 0.5 ? 'walk_right' : 'walk_left';
                    this.stateTimer = 0;
                }
            } else if (this.state === 'walk_right') {
                this.vx = 3; this.facingRight = true; this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
            } else if (this.state === 'walk_left') {
                this.vx = -3; this.facingRight = false; this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
            }
            if(this.x < 100) { this.x = 100; this.state = 'walk_right'; }
            if(this.x > 600) { this.x = 600; this.state = 'walk_left'; }

            // Efecto: Partículas al caminar
            if (Math.abs(this.vx) > 0 && this.animTimer % 10 === 0) {
                spawnParticles(this.x + 12, this.y + 40, 1, 'dust');
            }
        }

        draw(ctx) {
            ctx.save(); 
            // Sutil resplandor del traje
            ctx.shadowBlur = 5; ctx.shadowColor = COLORS.playerAccent;
            
            let lean = 0; if (Math.abs(this.vx) > 1) lean = this.facingRight ? 3 : -3; 
            ctx.translate(lean, 0);
            
            // Piernas (Traje espacial detallado)
            ctx.fillStyle = '#333344';
            if (Math.abs(this.vx) > 0.5) {
                let cycle = Math.sin(this.animTimer * 0.5);
                ctx.fillRect(this.x + 4, this.y + 25, 6, 15 + cycle * 3); 
                ctx.fillRect(this.x + 14, this.y + 25, 6, 15 - cycle * 3);
            } else { 
                ctx.fillRect(this.x + 4, this.y + 25, 6, 15); 
                ctx.fillRect(this.x + 14, this.y + 25, 6, 15); 
            }
            
            // Cuerpo (Armadura)
            ctx.fillStyle = COLORS.player; 
            ctx.fillRect(this.x, this.y + 10, this.width, 18);
            // Detalles Armadura
            ctx.fillStyle = '#666'; ctx.fillRect(this.x+4, this.y+12, 16, 14);

            // Mochila con luz de energía
            ctx.fillStyle = '#222'; ctx.fillRect(this.facingRight ? this.x - 4 : this.x + 20, this.y + 12, 4, 10);
            ctx.fillStyle = COLORS.playerAccent; ctx.fillRect(this.facingRight ? this.x - 5 : this.x + 21, this.y + 13, 2, 8);

            // Casco
            ctx.fillStyle = '#222'; ctx.fillRect(this.x + 2, this.y, 20, 12); 
            ctx.fillStyle = COLORS.playerAccent; // Visor brillante
            ctx.fillRect(this.facingRight ? this.x + 12 : this.x + 2, this.y + 3, 10, 4);

            // Arma (Rifle Sci-Fi)
            ctx.fillStyle = '#444';
            let gunX = this.facingRight ? this.x + 14 : this.x - 6; 
            let gunY = this.y + 14;
            ctx.fillRect(gunX, gunY, 16, 6);
            // Luz del arma
            ctx.fillStyle = '#ff00ff'; ctx.fillRect(this.facingRight ? gunX + 14 : gunX, gunY+1, 2, 4);
            
            ctx.restore();
        }
    }

    class MockWalker {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 30; this.height = 30;
            this.vx = 2; this.dir = 1; this.timer = 0; this.state = 'walk'; this.startX = x;
            this.waitTimer = 0;
        }

        update() {
            this.timer++;
            if (this.state === 'walk') {
                this.x += this.vx;
                if (Math.abs(this.x - this.startX) > 150) {
                    this.state = 'wait'; this.waitTimer = 60;
                }
            } else if (this.state === 'wait') {
                this.waitTimer--;
                if (this.waitTimer <= 0) {
                    this.dir *= -1; this.vx = this.dir * 2; this.state = 'walk';
                }
            }
        }

        draw(ctx) {
            // Robot Alienígena
            let anim = Math.sin(this.timer * 0.2);
            let drawY = this.y - 10; 

            // Cuerpo metálico con gradiente
            let grd = ctx.createLinearGradient(this.x, drawY, this.x, drawY+30);
            grd.addColorStop(0, "#602020");
            grd.addColorStop(1, "#200505");
            ctx.fillStyle = grd;
            
            // Sombra / Glow rojo
            ctx.shadowBlur = 10; ctx.shadowColor = '#ff0000';
            ctx.fillRect(this.x, drawY, this.width, this.height);
            ctx.shadowBlur = 0;

            // Ojo Cíclope
            ctx.fillStyle = '#000'; ctx.fillRect(this.x + 8, drawY + 5, 14, 10); 
            ctx.fillStyle = '#ff0000'; ctx.fillRect(this.x + 13, drawY + 8, 4, 4);
            
            // Brazos sierras giratorias
            ctx.fillStyle = '#888'; 
            ctx.save(); ctx.translate(this.x + 5, drawY + 15); ctx.rotate(anim * 2); ctx.fillRect(-2, -8, 4, 16); ctx.restore();
            ctx.save(); ctx.translate(this.x + 25, drawY + 15); ctx.rotate(-anim * 2); ctx.fillRect(-2, -8, 4, 16); ctx.restore();
            
            // Piernas mecánicas
            ctx.fillStyle = '#444';
            ctx.fillRect(this.x + 5, drawY + 30, 5, 10 + anim * 5); 
            ctx.fillRect(this.x + 20, drawY + 30, 5, 10 - anim * 5);
        }
    }

    class MockFlyer {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 30; this.height = 20;
            this.startX = x; this.timer = 0;
        }
        update() {
            this.timer++;
            this.x = this.startX + Math.sin(this.timer * 0.02) * 200;
            this.y += Math.cos(this.timer * 0.05) * 1; 
            
            // Emitir partículas de propulsión
            if(this.timer % 5 === 0) spawnParticles(this.x + 15, this.y + 10, 1, 'thrust');
        }
        draw(ctx) {
            let flap = Math.sin(this.timer * 0.8) * 5;
            // Drone orgánico
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.ellipse(this.x + 15, this.y + 10, 15, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // Alas / Estabilizadores de energía
            ctx.strokeStyle = '#ff00ff'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(this.x, this.y+5); ctx.lineTo(this.x - 10, this.y - 5 + flap); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(this.x + 30, this.y+5); ctx.lineTo(this.x + 40, this.y - 5 + flap); ctx.stroke(); 
            
            // Motor brillante
            ctx.shadowBlur = 10; ctx.shadowColor = '#ff00ff';
            ctx.fillStyle = '#ffccff'; ctx.fillRect(this.x + 10, this.y + 15, 10, 5);
            ctx.shadowBlur = 0;
        }
    }

    // --- INICIALIZACIÓN ---
    const player = new MockPlayer(200, 500);
    const walker = new MockWalker(800, 450);
    const flyer = new MockFlyer(600, 200);
    
    // Generamos algunas estrellas estáticas
    const stars = [];
    for(let i=0; i<100; i++) {
        stars.push({x: Math.random() * GAME_WIDTH, y: Math.random() * GAME_HEIGHT, size: Math.random() * 1.5});
    }

    const platforms = [
        { x: 0, y: 540, width: 800, height: 200 }, 
        { x: 750, y: 490, width: 400, height: 20 }
    ];

    let gameTime = 0;
    let camera = { x: 0, y: 0 };

    // --- DIBUJO DEL FONDO (Nave Espacial) ---
    function drawBackground(ctx, cameraX, cameraY) {
        // 1. Fondo base (Espacio profundo)
        let bgGrad = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
        bgGrad.addColorStop(0, "#000000");
        bgGrad.addColorStop(1, "#0b001a"); // Púrpura muy oscuro abajo
        ctx.fillStyle = bgGrad; 
        ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.fillRect(0, 0, canvas.width, canvas.height); 
        
        // Estrellas (Capa 0)
        ctx.fillStyle = "#fff";
        stars.forEach(s => {
            let twinkle = Math.random() > 0.95 ? 0 : 1;
            if(twinkle) ctx.fillRect(s.x, s.y, s.size, s.size);
        });
        ctx.restore();

        // --- PARALLAX LAYERS (Interior de la nave gigante) ---
        
        // Configuración de capas: Estructuras alienígenas
        const layers = [
            // Capa 1: Pilares Gigantes (Muy lejos)
            { speed: 0.1, type: 'pillars', color: '#11111a', width: 300, gap: 100 }, 
            // Capa 2: Maquinaria densa y oscura
            { speed: 0.25, type: 'machinery', color: '#161621', width: 150, gap: 50 }, 
            // Capa 3: Cables colgados
            { speed: 0.4, type: 'cables', color: '#1a1a2e', width: 200, gap: 0 }, 
            // Capa 4: Cables más cercanos y estructuras detalladas
            { speed: 0.65, type: 'tech_wall', color: '#222233', width: 400, gap: 0 }
        ];

        layers.forEach((layer, index) => {
            ctx.save(); 
            let parallaxX = -cameraX * layer.speed; 
            ctx.translate(parallaxX, 0);
            
            let totalW = layer.width + layer.gap; 
            let startI = Math.floor(-parallaxX / totalW) - 2; 
            let endI = startI + Math.ceil(GAME_WIDTH / totalW) + 4;
            
            for (let i = startI; i < endI; i++) {
                let x = i * totalW; 
                let seed = Math.sin(i * 123.45 + index * 55); // Pseudo-random consistente

                if (layer.type === 'pillars') {
                    // Grandes monolitos silueteados
                    ctx.fillStyle = layer.color;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x + layer.width, 0);
                    ctx.lineTo(x + layer.width - 40, GAME_HEIGHT);
                    ctx.lineTo(x + 40, GAME_HEIGHT);
                    ctx.fill();
                    // Ventanas rojas lejanas
                    if (seed > 0.5) {
                        ctx.fillStyle = '#330000';
                        ctx.fillRect(x + 60, 100 + seed * 200, 10, 50);
                    }
                }
                else if (layer.type === 'machinery') {
                    // Bloques técnicos repetitivos
                    ctx.fillStyle = layer.color;
                    let h = 200 + Math.abs(seed) * 300;
                    ctx.fillRect(x, GAME_HEIGHT - h, layer.width, h); // Abajo
                    ctx.fillRect(x, 0, layer.width, h * 0.5); // Arriba (techo)
                    
                    // Tubos conectores
                    ctx.strokeStyle = '#2a2a3d';
                    ctx.lineWidth = 5;
                    ctx.beginPath(); ctx.moveTo(x, 100); ctx.lineTo(x+layer.width, 120); ctx.stroke();
                }
                else if (layer.type === 'cables') {
                    // Curvas bezier simulando cables biológicos
                    ctx.strokeStyle = layer.color;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    let sag = 100 + seed * 50;
                    ctx.moveTo(x, 0);
                    ctx.quadraticCurveTo(x + layer.width/2, sag, x + layer.width, 0);
                    ctx.stroke();
                    
                    // Nodos brillantes en los cables
                    if (seed > 0.8) {
                        ctx.fillStyle = '#00ffff';
                        ctx.shadowBlur = 5; ctx.shadowColor = '#00ffff';
                        ctx.fillRect(x + layer.width/2 - 2, sag/2, 4, 4);
                        ctx.shadowBlur = 0;
                    }
                }
                else if (layer.type === 'tech_wall') {
                    // Pared principal de fondo
                    ctx.fillStyle = layer.color;
                    // Dibujar paneles hexagonales o rectangulares
                    ctx.fillRect(x, 0, layer.width, GAME_HEIGHT);
                    
                    ctx.strokeStyle = '#2a2a40';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x + 10, 50, layer.width - 20, 100);
                    ctx.strokeRect(x + 10, GAME_HEIGHT - 150, layer.width - 20, 100);
                    
                    // Luces de estado
                    ctx.fillStyle = seed > 0 ? '#00ff00' : '#ff0000';
                    ctx.globalAlpha = 0.3;
                    ctx.fillRect(x + 20, GAME_HEIGHT/2, 10, 10);
                    ctx.globalAlpha = 1.0;
                }
            }
            ctx.restore();
        });
    }

    // --- DIBUJO DEL MAPA (PLATAFORMAS DETALLADAS) ---
    function drawMap(ctx) {
        platforms.forEach(p => {
            // 1. Base metálica oscura
            ctx.fillStyle = '#0e0e14'; 
            ctx.fillRect(p.x, p.y, p.width, p.height);
            
            // 2. Textura de rejilla (Grid pattern)
            ctx.save();
            ctx.beginPath();
            ctx.rect(p.x, p.y, p.width, p.height);
            ctx.clip();
            
            ctx.strokeStyle = '#1f1f2e';
            ctx.lineWidth = 2;
            // Líneas diagonales para textura industrial
            for(let i = -p.height; i < p.width; i+=20) {
                ctx.beginPath();
                ctx.moveTo(p.x + i, p.y);
                ctx.lineTo(p.x + i + 20, p.y + p.height);
                ctx.stroke();
            }
            ctx.restore();

            // 3. Borde superior "Alien Alloy"
            ctx.fillStyle = '#2a2a40'; 
            ctx.fillRect(p.x, p.y, p.width, 8);
            
            // 4. Luces de borde (Glow strip)
            ctx.shadowBlur = 15; ctx.shadowColor = '#00ffff';
            ctx.fillStyle = '#00ffff';
            // Dibujar una linea fina brillante justo debajo del borde
            ctx.fillRect(p.x, p.y + 8, p.width, 2);
            ctx.shadowBlur = 0;

            // 5. Antenas y detalles estructurales
            ctx.fillStyle = '#111';
            if (p.width > 100) {
                // Antena pequeña
                ctx.fillRect(p.x + p.width - 40, p.y - 20, 4, 20);
                // Luz roja en antena
                ctx.fillStyle = `rgba(255, 0, 0, ${Math.abs(Math.sin(gameTime * 0.1))})`;
                ctx.fillRect(p.x + p.width - 42, p.y - 24, 8, 4);
            }
            
            // Chispas aleatorias de cables rotos
            if (Math.random() > 0.98) {
                 spawnParticles(p.x + Math.random() * p.width, p.y + p.height, 3, 'spark');
            }
        });
    }

    // --- DIBUJO PRIMER PLANO (FOREGROUND) ---
    function drawForeground(ctx, cameraX) {
        ctx.save();
        // Se mueve más rápido que la cámara para efecto de mucha cercanía
        let parallaxX = -cameraX * 1.2; 
        ctx.translate(parallaxX, 0);
        
        // Elementos oscuros y desenfocados
        ctx.fillStyle = '#000';
        ctx.filter = 'blur(4px)'; // Desenfoque para profundidad de campo
        
        let width = 600;
        let startI = Math.floor(-parallaxX / width) - 1;
        let endI = startI + 4;

        for (let i = startI; i < endI; i++) {
            let x = i * width;
            // Grandes tuberías verticales
            if (i % 2 === 0) {
                ctx.fillRect(x + 100, 0, 80, GAME_HEIGHT);
            } else {
                // Vigas horizontales arriba
                ctx.fillRect(x, 0, width, 150);
            }
        }
        ctx.filter = 'none';
        ctx.restore();
    }

    // --- BUCLE PRINCIPAL ---
    function loop() {
        gameTime++;
        
        // Cámara en auto-scroll sinusoidal
        camera.x = Math.sin(gameTime * 0.005) * 300 + 200;
        camera.y = Math.cos(gameTime * 0.01) * 10; // Leve flotación vertical

        // Generar polvo ambiental
        if (gameTime % 20 === 0) {
            spawnParticles(camera.x + Math.random() * GAME_WIDTH - GAME_WIDTH/2, Math.random() * GAME_HEIGHT, 1, 'dust');
        }

        // Updates
        player.update();
        walker.update();
        flyer.update();
        particles.forEach((p, index) => {
            p.update();
            if(p.life <= 0) particles.splice(index, 1);
        });

        // Render
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 1. Background (Capas 0-4)
        drawBackground(ctx, camera.x, camera.y);

        // Aplicar transformaciones de cámara para el mundo de juego
        ctx.save();
        let screenOffsetX = camera.x;
        
        // Truco visual del testbed original:
        // Mantenemos a los actores "centrados" en la pantalla dibujándolos relativos a la cámara,
        // pero el fondo se mueve independientemente.
        // Sin embargo, para que las partículas funcionen bien en el mundo, 
        // deberíamos dibujar todo en coordenadas mundo y trasladar el canvas.
        
        // En este testbed modificado:
        // Movemos el 'mundo' a la izquierda, pero trasladamos al jugador a la derecha para seguirlo.
        // Para simplificar el visualizador (ya que es un mock):
        
        // Dibujamos Mapa y Entidades fijos en pantalla (como si la cámara los siguiera perfectamente)
        // Solo desplazamos el contenido de las plataformas un poco para simular movimiento relativo si fuera necesario,
        // pero aquí usaremos coordenadas de pantalla fijas menos el offset de cámara para parallax.
        
        // Ajuste: Dibujamos el mapa moviéndose con la cámara inversa para simular que "avanzamos"
        // Como es un auto-scroll demo, vamos a dibujar el mapa centrado y mover el fondo.
        
        ctx.translate(-camera.x + 200, -camera.y); // Cámara afecta mapa
        drawMap(ctx);
        
        // Partículas (en coordenadas mundo)
        particles.forEach(p => p.draw(ctx));

        // Entidades (Para el demo, las forzamos a coordenadas de mundo relativas)
        player.draw(ctx);
        walker.draw(ctx);
        flyer.draw(ctx);
        
        ctx.restore();

        // 2. Efectos de superposición global
        // Neblina cian suave abajo
        let fog = ctx.createLinearGradient(0, GAME_HEIGHT - 200, 0, GAME_HEIGHT);
        fog.addColorStop(0, "rgba(0, 255, 255, 0)");
        fog.addColorStop(1, "rgba(0, 255, 255, 0.08)");
        ctx.fillStyle = fog;
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        // 3. Foreground (Capa 6 - Delante de todo)
        drawForeground(ctx, camera.x);

        requestAnimationFrame(loop);
    }

    // Start
    loop();

</script>
</body>
</html>