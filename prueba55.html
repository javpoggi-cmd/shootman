<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Shootman: Nivel 2 - Sector Profundo (Final)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #game-container {
            position: relative;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.9);
            border: 4px solid #333;
            background: #000;
            width: 1280px; 
            height: 720px;
        }
        canvas {
            display: block;
            background-color: #0f1210;
            image-rendering: pixelated;
            width: 100%;
            height: 100%;
        }
        #scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.15) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 4px, 6px 100%;
            pointer-events: none;
            z-index: 10;
        }
        #atmosphere-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at 50% 30%, rgba(20, 30, 25, 0) 40%, rgba(0, 0, 0, 0.5) 90%);
            pointer-events: none;
            z-index: 11;
        }
        #debug-ui {
            position: absolute; top: 10px; left: 10px; color: #00ffaa; z-index: 20;
            background: rgba(0,0,0,0.8); padding: 10px; border: 1px solid #333;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="testCanvas"></canvas>
    <div id="scanlines"></div>
    <div id="atmosphere-overlay"></div>
    <div id="debug-ui">
        <h3>NIVEL 2: SECTOR PROFUNDO</h3>
        <p>Detalle: Ventanas Asíncronas</p>
        <p>Foreground: Azoteas</p>
    </div>
</div>

<script>
    const canvas = document.getElementById('testCanvas');
    const ctx = canvas.getContext('2d');
    const GAME_WIDTH = 1280; 
    const GAME_HEIGHT = 720;
    canvas.width = GAME_WIDTH; 
    canvas.height = GAME_HEIGHT;

    // --- COLORES ORIGINALES ---
    const COLORS = { 
        player: '#e0e0e0', 
        playerAccent: '#ffaa00', 
        bullet: '#00ffaa', 
        enemyBullet: '#ff4444', 
        weapon: '#00ff00' 
    };
    
    const currentBiome = { 
        name: "INDUSTRIAL_DEEP", 
        sky: '#050505', 
        layers: ['#080808', '#0a0a0a', '#111111', '#161616', '#1a1a1a', '#222222'], 
        ground: '#2a332e', 
        groundDark: '#1e2420', 
        groundLight: '#35403a', 
        top: '#4a5e52',
        hazardYellow: '#aa8800'
    };
    
    const ENEMY_COLOR = '#cc4444';

    // --- VARIABLES GLOBALES ---
    let gameTime = 0;
    let camera = { x: 0, y: 0 };
    
    // --- UTILIDADES ---
    function randomInt(min, max) { return Math.floor(Math.random() * (max - min + 1) + min); }

    // --- CLASES DE PERSONAJES (MOCKS) ---
    class MockPlayer {
        constructor(x, y) {
            this.x = x; this.y = y; this.width = 24; this.height = 40; this.vx = 0; 
            this.animTimer = 0; this.facingRight = true; this.state = 'wait'; this.stateTimer = 0;
        }
        update() {
            this.animTimer++; this.stateTimer++;
            if (this.state === 'wait') {
                this.vx = 0;
                if (this.stateTimer > 60) { this.state = Math.random() > 0.5 ? 'walk_right' : 'walk_left'; this.stateTimer = 0; }
            } else if (this.state === 'walk_right') {
                this.vx = 3; this.facingRight = true; this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
            } else if (this.state === 'walk_left') {
                this.vx = -3; this.facingRight = false; this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
            }
            if(this.x < 100) { this.x = 100; this.state = 'walk_right'; }
            if(this.x > 600) { this.x = 600; this.state = 'walk_left'; }
        }
        draw(ctx) {
            ctx.save(); ctx.fillStyle = COLORS.player;
            let lean = 0; if (Math.abs(this.vx) > 1) lean = this.facingRight ? 3 : -3; 
            ctx.translate(lean, 0);
            if (Math.abs(this.vx) > 0.5) {
                let cycle = Math.sin(this.animTimer * 0.5);
                ctx.fillRect(this.x + 4, this.y + 25, 6, 15 + cycle * 3); 
                ctx.fillRect(this.x + 14, this.y + 25, 6, 15 - cycle * 3);
            } else { ctx.fillRect(this.x + 4, this.y + 25, 6, 15); ctx.fillRect(this.x + 14, this.y + 25, 6, 15); }
            ctx.fillStyle = '#fff'; ctx.fillRect(this.x, this.y + 10, this.width, 18);
            ctx.fillStyle = '#55f'; ctx.fillRect(this.facingRight ? this.x - 4 : this.x + 20, this.y + 12, 4, 10); 
            ctx.fillStyle = '#333'; ctx.fillRect(this.x + 2, this.y, 20, 12);
            ctx.fillStyle = COLORS.playerAccent; ctx.fillRect(this.facingRight ? this.x + 12 : this.x + 2, this.y + 3, 10, 4);
            ctx.fillStyle = '#555'; ctx.fillRect(this.facingRight ? this.x + 14 : this.x - 6, this.y + 14, 16, 6);
            ctx.restore();
        }
    }

    class MockWalker {
        constructor(x, y) {
            this.x = x; this.y = y; this.width = 30; this.height = 30; this.vx = 2; this.dir = 1; this.timer = 0; this.state = 'walk'; this.startX = x;
        }
        update() {
            this.timer++;
            if (this.state === 'walk') {
                this.x += this.vx;
                if (Math.abs(this.x - this.startX) > 150) { this.state = 'wait'; this.waitTimer = 60; }
            } else if (this.state === 'wait') {
                this.waitTimer--;
                if (this.waitTimer <= 0) { this.dir *= -1; this.vx = this.dir * 2; this.state = 'walk'; }
            }
        }
        draw(ctx) {
            ctx.fillStyle = ENEMY_COLOR;
            let anim = Math.sin(this.timer * 0.2);
            let drawY = this.y - 10; 
            ctx.fillRect(this.x, drawY, this.width, this.height);
            ctx.fillStyle = '#fff'; ctx.fillRect(this.x + 10, drawY + 5, 10, 10); ctx.fillStyle = '#f00'; ctx.fillRect(this.x + 13, drawY + 8, 4, 4);
            ctx.fillStyle = ENEMY_COLOR; 
            ctx.save(); ctx.translate(this.x + 5, drawY + 15); ctx.rotate(anim); ctx.fillRect(0, 0, 5, 15); ctx.restore();
            ctx.save(); ctx.translate(this.x + 25, drawY + 15); ctx.rotate(-anim); ctx.fillRect(0, 0, 5, 15); ctx.restore();
            ctx.fillRect(this.x + 5, drawY + 30, 5, 10 + anim * 5); ctx.fillRect(this.x + 20, drawY + 30, 5, 10 - anim * 5);
        }
    }

    class MockFlyer {
        constructor(x, y) { this.x = x; this.y = y; this.width = 30; this.height = 20; this.startX = x; this.timer = 0; }
        update() { this.timer++; this.x = this.startX + Math.sin(this.timer * 0.02) * 200; this.y += Math.cos(this.timer * 0.05) * 1; }
        draw(ctx) {
            let flap = Math.sin(this.timer * 0.8) * 10;
            ctx.fillStyle = ENEMY_COLOR; ctx.fillRect(this.x, this.y, 30, 20); ctx.fillStyle = '#777'; 
            ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x - 10, this.y - 10 + flap); ctx.lineTo(this.x + 10, this.y); ctx.fill();
            ctx.beginPath(); ctx.moveTo(this.x + 30, this.y); ctx.lineTo(this.x + 40, this.y - 10 + flap); ctx.lineTo(this.x + 20, this.y); ctx.fill(); 
            ctx.fillStyle = '#ff0'; ctx.fillRect(this.x + 10, this.y + 5, 10, 5);
        }
    }

    // --- PARTÍCULAS ---
    class ParticleSystem {
        constructor() { this.particles = []; }
        spawn(x, y, type) {
            this.particles.push({
                x: x, y: y, vx: (Math.random() - 0.5) * 2, vy: (Math.random() * 2) - 1, life: 1.0, type: type, size: Math.random() * 3 + 1
            });
        }
        updateAndDraw(ctx) {
            for(let i=this.particles.length-1; i>=0; i--) {
                let p = this.particles[i];
                p.x += p.vx; p.y += p.vy; p.life -= 0.01;
                if (p.type === 'smoke') { p.y -= 0.5; p.size += 0.1; ctx.fillStyle = `rgba(50, 50, 50, ${p.life * 0.4})`; } 
                else { p.y += 0.5; ctx.fillStyle = `rgba(150, 160, 150, ${p.life * 0.5})`; }
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
                if(p.life <= 0) this.particles.splice(i, 1);
            }
        }
    }
    const particles = new ParticleSystem();

    // --- GENERACIÓN DE FONDO ---
    
    function generateLayerData(count, widthMin, widthMax, heightBase, heightVar, color) {
        let items = [];
        let currentX = -200;
        for(let i=0; i<count; i++) {
            let w = randomInt(widthMin, widthMax);
            let h = heightBase + randomInt(0, heightVar);
            let gap = randomInt(5, 40);
            
            // LOGICA NUEVA PARA VENTANAS (ASINCRONAS)
            let windows = [];
            if (Math.random() > 0.3) {
                let winRows = Math.floor(h / 40);
                let winCols = Math.floor(w / 30);
                for(let r=0; r<winRows; r++) {
                    for(let c=0; c<winCols; c++) {
                        if ((c + r) % 3 === 0) continue; 
                        // Guardamos parámetros únicos para cada ventana
                        windows.push({ 
                            x: c*25 + 10, 
                            y: r*35 + 20, 
                            // Cada ventana tiene su propia "fase" y "velocidad" de encendido
                            phase: Math.random() * Math.PI * 2, 
                            speed: Math.random() * 0.005 + 0.001 
                        });
                    }
                }
            }
            
            // Techos
            let roofDetails = [];
            if (Math.random() > 0.5) {
                roofDetails.push({ x: randomInt(5, w-15), w: randomInt(5, 15), h: randomInt(10, 30), type: Math.random() > 0.5 ? 'antenna' : 'box' });
            }
            items.push({ x: currentX, w: w, h: h, wins: windows, roof: roofDetails });
            currentX += w + gap;
        }
        return { items, totalWidth: currentX, color };
    }

    const bgLayers = [
        { speed: 0.02, data: generateLayerData(15, 200, 500, 400, 200, currentBiome.layers[0]), yOffset: 150 },
        { speed: 0.05, data: generateLayerData(20, 150, 300, 300, 150, currentBiome.layers[1]), yOffset: 100 },
        { speed: 0.10, data: generateLayerData(25, 100, 250, 250, 150, currentBiome.layers[2]), yOffset: 80 },
        { speed: 0.20, data: generateLayerData(30, 80, 200, 200, 150, currentBiome.layers[3]), yOffset: 50 },
        { speed: 0.40, data: generateLayerData(30, 60, 180, 150, 100, currentBiome.layers[4]), yOffset: 20 },
        { speed: 0.60, data: generateLayerData(35, 50, 150, 100, 100, currentBiome.layers[5]), yOffset: 0 }
    ];

    // --- NUEVO FOREGROUND: AZOTEAS ---
    // En lugar de tubos, generamos "edificios" negros silueteados para la parte inferior
    function generateRooftops(width) {
        let rooftops = [];
        let cx = 0;
        while(cx < width) {
            let w = randomInt(100, 300);
            let h = randomInt(50, 120); // Altura desde abajo
            let details = [];
            // Añadir antenas o ventiladores a la silueta
            for(let k=0; k<randomInt(1,3); k++) {
                details.push({
                    dx: randomInt(10, w-10),
                    dh: randomInt(20, 50),
                    dw: randomInt(2, 5)
                });
            }
            rooftops.push({ x: cx, w: w, h: h, details: details });
            cx += w + randomInt(0, 50); // Pequeños huecos
        }
        return { items: rooftops, totalW: cx };
    }

    const fgData = {
        layer1: generateRooftops(2500), // Capa rápida
        layer2: generateRooftops(2500)  // Capa muy rápida
    };

    // --- OBJETOS DE JUEGO Y DECORACIÓN ---
    const player = new MockPlayer(200, 500);
    const walker = new MockWalker(800, 450);
    const flyer = new MockFlyer(600, 200);

    const platforms = [
        { x: 0, y: 540, width: 800, height: 200, props: [] }, 
        { x: 750, y: 490, width: 400, height: 20, props: [] }
    ];

    // GENERAR PROPS (Objetos decorativos) EN LAS PLATAFORMAS
    platforms.forEach(p => {
        // Añadir cajas, barriles, etc.
        let numProps = Math.floor(p.width / 150);
        for(let i=0; i<numProps; i++) {
            let px = randomInt(20, p.width - 40);
            // Evitar solapar demasiado (simple)
            let type = Math.random();
            if (type < 0.3) {
                // Caja
                p.props.push({ type: 'crate', x: px, w: 20, h: 20 });
            } else if (type < 0.6) {
                // Barril
                p.props.push({ type: 'barrel', x: px, w: 14, h: 24 });
            } else {
                // Terminal
                p.props.push({ type: 'terminal', x: px, w: 15, h: 25 });
            }
        }
    });

    // --- DIBUJO ---

    function drawBackground(ctx, camX) {
        // Cielo y Contaminación
        ctx.fillStyle = currentBiome.sky;
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        let grad = ctx.createLinearGradient(0, GAME_HEIGHT - 300, 0, GAME_HEIGHT);
        grad.addColorStop(0, currentBiome.sky);
        grad.addColorStop(1, '#1a221e'); 
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        bgLayers.forEach(layer => {
            let parallaxX = -(camX * layer.speed);
            let totalW = layer.data.totalWidth;
            
            ctx.save();
            ctx.translate(parallaxX % totalW, 0);
            
            for(let k=0; k<2; k++) {
                let xOff = k * totalW;
                if (parallaxX + xOff > GAME_WIDTH || parallaxX + xOff + totalW < 0) continue;

                ctx.translate(xOff, 0);
                ctx.fillStyle = layer.data.color;
                
                layer.data.items.forEach(b => {
                    let yPos = GAME_HEIGHT - b.h - layer.yOffset;
                    ctx.fillRect(b.x, yPos, b.w, b.h + 500);
                    
                    if (b.roof.length > 0) {
                        b.roof.forEach(r => {
                            if (r.type === 'antenna') {
                                ctx.fillRect(b.x + r.x + r.w/2 - 1, yPos - r.h, 2, r.h);
                                if (Math.sin(Date.now() * 0.005 + b.x) > 0.8) { // Luz roja lenta
                                    ctx.fillStyle = '#aa0000'; ctx.fillRect(b.x + r.x + r.w/2 - 2, yPos - r.h - 2, 4, 4); ctx.fillStyle = layer.data.color;
                                }
                            } else { ctx.fillRect(b.x + r.x, yPos - 10, r.w, 10); }
                        });
                    }

                    // VENTANAS ASINCRONAS
                    if (layer.speed > 0.05) {
                        b.wins.forEach(w => {
                            // Usamos la fase y velocidad única de cada ventana
                            // Sumamos Date.now() para animación
                            let time = Date.now();
                            let state = Math.sin(time * w.speed + w.phase);
                            
                            // Solo encender si el ciclo está en pico alto (efecto encendido/apagado esporádico)
                            if (state > 0.8) { 
                                ctx.fillStyle = '#fff75c'; // Encendida
                                ctx.fillRect(b.x + w.x, yPos + w.y, 6, 12);
                            } else if (state > 0.7) {
                                ctx.fillStyle = '#554433'; // Apagándose
                                ctx.fillRect(b.x + w.x, yPos + w.y, 6, 12);
                            }
                            // Si state < 0.7, no dibujamos (negro del edificio)
                        });
                        ctx.fillStyle = layer.data.color;
                    }
                });
                ctx.translate(-xOff, 0);
            }
            ctx.restore();
        });
    }

    function drawDetailedMap(ctx) {
        platforms.forEach(p => {
            // Cuerpo y Textura
            ctx.fillStyle = currentBiome.ground; ctx.fillRect(p.x, p.y, p.width, p.height);
            ctx.fillStyle = currentBiome.groundDark;
            for(let i=0; i<p.width; i+=64) {
                ctx.fillRect(p.x + i, p.y, 2, p.height);
                ctx.fillStyle = '#111'; ctx.fillRect(p.x + i + 4, p.y + 15, 4, 4); ctx.fillRect(p.x + i + 56, p.y + 15, 4, 4);
                ctx.fillStyle = currentBiome.groundDark;
            }
            // Borde superior y peligro
            ctx.fillStyle = currentBiome.top; ctx.fillRect(p.x, p.y, p.width, 10);
            ctx.fillStyle = currentBiome.hazardYellow;
            for(let i=0; i<p.width; i+=20) {
                ctx.beginPath(); ctx.moveTo(p.x + i, p.y + 10); ctx.lineTo(p.x + i + 10, p.y + 10); ctx.lineTo(p.x + i, p.y + 15); ctx.fill();
            }

            // DIBUJAR PROPS DECORATIVOS (ENCIMA DE LA PLATAFORMA)
            p.props.forEach(prop => {
                let py = p.y - prop.h; // Posición Y base (sobre el suelo)
                let px = p.x + prop.x;
                
                if (prop.type === 'crate') {
                    ctx.fillStyle = '#5a4a3a'; ctx.fillRect(px, py, prop.w, prop.h); // Caja madera
                    ctx.fillStyle = '#3a2a1a'; ctx.fillRect(px + 2, py + 2, prop.w - 4, prop.h - 4); // Borde interno
                    ctx.beginPath(); ctx.moveTo(px, py); ctx.lineTo(px+prop.w, py+prop.h); ctx.stroke(); // Cruz
                } else if (prop.type === 'barrel') {
                    ctx.fillStyle = '#445544'; ctx.fillRect(px, py, prop.w, prop.h); // Barril verde
                    ctx.fillStyle = '#223322'; ctx.fillRect(px, py + 5, prop.w, 2); ctx.fillRect(px, py + 15, prop.w, 2); // Aros
                    // Símbolo tóxico simple
                    ctx.fillStyle = '#ccff00'; ctx.fillRect(px + 4, py + 8, 4, 4);
                } else if (prop.type === 'terminal') {
                    ctx.fillStyle = '#222'; ctx.fillRect(px, py, prop.w, prop.h);
                    ctx.fillStyle = '#0f0'; ctx.fillRect(px + 2, py + 2, 8, 6); // Pantalla
                    // Luz parpadeante
                    if (Math.floor(Date.now() / 500) % 2 === 0) ctx.fillStyle = '#f00'; else ctx.fillStyle = '#500';
                    ctx.fillRect(px + 10, py + 15, 2, 2);
                }
            });

            // Decoración inferior
            if (p.height < 50) {
                ctx.fillStyle = '#151515'; ctx.fillRect(p.x + 20, p.y + p.height, p.width - 40, 10);
                for(let i=40; i<p.width-40; i+=40) ctx.fillRect(p.x + i, p.y + p.height, 5, 15);
            } else {
                ctx.fillStyle = '#1a1a1a'; ctx.fillRect(p.x + 100, p.y + 50, 200, 10);
                ctx.fillStyle = '#111'; ctx.fillRect(p.x + 150, p.y + 40, 20, 30);
            }
        });
    }

    // NUEVO FOREGROUND (AZOTEAS)
    function drawRooftopsLayer(ctx, data, speed, camX, yBase, color) {
        let px = -(camX * speed);
        ctx.fillStyle = color;
        ctx.save();
        ctx.translate(px % data.totalW, 0);
        
        for(let k=0; k<2; k++) { // Loop infinito
            let offset = k * data.totalW;
            ctx.translate(offset, 0);
            data.items.forEach(r => {
                let ry = yBase - r.h;
                // Edificio silueta
                ctx.fillRect(r.x, ry, r.w, r.h + 100);
                // Antenas
                r.details.forEach(d => {
                    ctx.fillRect(r.x + d.dx, ry - d.dh, d.dw, d.dh);
                });
            });
            ctx.translate(-offset, 0);
        }
        ctx.restore();
    }

    function drawForeground(ctx, camX) {
        // Capa Azoteas 1 (Oscura, rápida)
        drawRooftopsLayer(ctx, fgData.layer1, 1.2, camX, GAME_HEIGHT + 20, '#050505');
        
        // Capa Azoteas 2 (Más negra, muy rápida, muy abajo)
        drawRooftopsLayer(ctx, fgData.layer2, 1.5, camX, GAME_HEIGHT + 50, '#000000');
        
        // Niebla inferior para integrar
        let grad = ctx.createLinearGradient(0, GAME_HEIGHT - 80, 0, GAME_HEIGHT);
        grad.addColorStop(0, 'rgba(0,0,0,0)');
        grad.addColorStop(1, 'rgba(0,0,0,0.8)');
        ctx.fillStyle = grad;
        ctx.fillRect(0, GAME_HEIGHT - 80, GAME_WIDTH, 80);
    }

    // --- BUCLE ---
    function loop() {
        gameTime++;
        camera.x = Math.sin(gameTime * 0.01) * 300 + 100;
        
        player.update(); walker.update(); flyer.update();
        if(Math.random() > 0.8) particles.spawn(Math.random()*GAME_WIDTH, Math.random()*GAME_HEIGHT, 'dust');
        if(Math.random() > 0.9) particles.spawn(Math.random()*GAME_WIDTH, GAME_HEIGHT, 'smoke');

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        drawBackground(ctx, camera.x);
        
        ctx.save();
        ctx.translate(-camera.x + 200, 0); 
        drawDetailedMap(ctx);
        player.draw(ctx); walker.draw(ctx); flyer.draw(ctx);
        particles.updateAndDraw(ctx);
        ctx.restore();

        drawForeground(ctx, camera.x);

        requestAnimationFrame(loop);
    }

    loop();

</script>
</body>
</html>