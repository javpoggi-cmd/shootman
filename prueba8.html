<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Shootman: High-Fidelity Prototype</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #020202;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #game-container {
            position: relative;
            box-shadow: 0 0 60px rgba(0, 255, 200, 0.1);
            border: 1px solid #1a1a1a;
            background: #000;
            width: 1280px;
            height: 720px;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        /* Efecto CRT/Vignette sobre el canvas */
        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(0,0,0,0) 50%, rgba(0,0,0,0.8) 100%);
            pointer-events: none;
            z-index: 10;
        }
        #scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 11;
        }
        #debug-ui {
            position: absolute; top: 20px; left: 20px; 
            color: #00ffcc; 
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            z-index: 20;
            text-shadow: 0 0 5px rgba(0, 255, 204, 0.5);
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="testCanvas"></canvas>
    <div id="overlay"></div>
    <div id="scanlines"></div>
    <div id="debug-ui">
        <h3>SYS.RENDER_CORE_V2</h3>
        <p>ATMOSPHERE: HEAVY RAIN</p>
        <p>LIGHTING: DYNAMIC</p>
    </div>
</div>

<script>
    const canvas = document.getElementById('testCanvas');
    const ctx = canvas.getContext('2d');
    const GAME_WIDTH = 1280; 
    const GAME_HEIGHT = 720;
    canvas.width = GAME_WIDTH; 
    canvas.height = GAME_HEIGHT;

    // --- UTILS ---
    function randomRange(min, max) { return Math.random() * (max - min) + min; }
    
    // --- ESTÉTICA MODERNA ---
    const PALETTE = {
        skyTop: '#05070a',
        skyBot: '#101820',
        fog: 'rgba(10, 15, 20, 0.8)',
        neonCyan: '#00f3ff',
        neonRed: '#ff2a2a',
        metalDark: '#1a1a1a',
        metalLight: '#3d444d',
        rust: '#4a3b32',
        rain: 'rgba(180, 200, 210, 0.3)'
    };

    // --- VARIABLES GLOBALES VISUALES ---
    let frameCount = 0;
    let lightningIntensity = 0;
    let lightningTimer = randomRange(100, 300);

    // --- SISTEMA DE LLUVIA ---
    const rainDrops = [];
    for(let i=0; i<400; i++) {
        rainDrops.push({
            x: Math.random() * GAME_WIDTH,
            y: Math.random() * GAME_HEIGHT,
            l: Math.random() * 20 + 10,
            v: Math.random() * 10 + 15
        });
    }

    // --- CLASES DEL JUEGO (MOCKS LOGICOS) ---

    class MockPlayer {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 24; this.height = 40;
            this.vx = 0; 
            this.animTimer = 0;
            this.facingRight = true;
            this.state = 'wait'; 
            this.stateTimer = 0;
        }

        update() {
            this.animTimer++;
            this.stateTimer++;
            if (this.state === 'wait') {
                this.vx = 0;
                if (this.stateTimer > 60) { 
                    this.state = Math.random() > 0.5 ? 'walk_right' : 'walk_left';
                    this.stateTimer = 0;
                }
            } else if (this.state === 'walk_right') {
                this.vx = 3; this.facingRight = true; this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
            } else if (this.state === 'walk_left') {
                this.vx = -3; this.facingRight = false; this.x += this.vx;
                if (this.stateTimer > 120) { this.state = 'wait'; this.stateTimer = 0; }
            }
            if(this.x < 100) { this.x = 100; this.state = 'walk_right'; }
            if(this.x > 600) { this.x = 600; this.state = 'walk_left'; }
        }

        draw(ctx) {
            ctx.save();
            ctx.translate(Math.floor(this.x), Math.floor(this.y));
            if (!this.facingRight) {
                ctx.translate(this.width, 0);
                ctx.scale(-1, 1);
            }

            // Sombra
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.beginPath(); ctx.ellipse(this.width/2, this.height, 10, 3, 0, 0, Math.PI*2); ctx.fill();

            // Animación
            const bob = Math.abs(this.vx) > 0 ? Math.sin(this.animTimer * 0.4) * 1 : 0;
            const legSwing = Math.abs(this.vx) > 0 ? Math.sin(this.animTimer * 0.4) * 8 : 0;

            // 1. Pierna Trasera
            ctx.fillStyle = '#1e2124';
            ctx.fillRect(8 + legSwing, 25, 6, 15);
            ctx.fillStyle = '#0f1112'; // Bota
            ctx.fillRect(6 + legSwing, 36, 10, 4);

            // 2. Pierna Delantera
            ctx.fillStyle = '#2a2f36';
            ctx.fillRect(4 - legSwing, 25, 6, 15);
            ctx.fillStyle = '#15171a'; // Bota
            ctx.fillRect(2 - legSwing, 36, 10, 4);

            // 3. Torso (Armadura)
            let torsoY = 10 + bob;
            // Base
            ctx.fillStyle = '#2f353d'; 
            ctx.fillRect(2, torsoY, 18, 18);
            // Placa pectoral (Gradiente para volumen)
            let grd = ctx.createLinearGradient(0, torsoY, 20, torsoY + 18);
            grd.addColorStop(0, '#3d444d'); grd.addColorStop(1, '#1a1d21');
            ctx.fillStyle = grd;
            ctx.fillRect(4, torsoY + 2, 14, 10);
            
            // Detalles de luces en armadura
            ctx.fillStyle = PALETTE.neonCyan;
            ctx.fillRect(8, torsoY + 5, 2, 2); 
            ctx.globalAlpha = 0.5; ctx.fillRect(7, torsoY + 4, 4, 4); ctx.globalAlpha = 1; // Glow

            // 4. Cabeza (Casco Táctico)
            let headY = torsoY - 10;
            ctx.fillStyle = '#1a1d21';
            ctx.beginPath();
            ctx.moveTo(4, headY); ctx.lineTo(18, headY);
            ctx.lineTo(18, headY + 12); ctx.lineTo(14, headY + 14); ctx.lineTo(4, headY + 14);
            ctx.fill();
            
            // Visor brillante
            ctx.fillStyle = PALETTE.neonCyan;
            ctx.fillRect(12, headY + 4, 6, 3);
            // Glow del visor
            ctx.shadowBlur = 10; ctx.shadowColor = PALETTE.neonCyan;
            ctx.fillRect(12, headY + 4, 6, 3);
            ctx.shadowBlur = 0;

            // 5. Arma (Rifle futurista)
            ctx.fillStyle = '#000';
            ctx.fillRect(8, torsoY + 8, 20, 5); // Cuerpo arma
            ctx.fillStyle = '#444';
            ctx.fillRect(12, torsoY + 7, 10, 2); // Riel superior
            ctx.fillStyle = '#111';
            ctx.fillRect(28, torsoY + 9, 4, 3); // Cañon

            // 6. Brazo
            ctx.fillStyle = '#2a2f36';
            ctx.fillRect(6, torsoY + 4, 6, 14);

            ctx.restore();
        }
    }

    class MockWalker {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 30; this.height = 30;
            this.vx = 2; this.dir = 1; this.timer = 0;
            this.state = 'walk'; this.startX = x; this.waitTimer = 0;
        }

        update() {
            this.timer++;
            if (this.state === 'walk') {
                this.x += this.vx;
                if (Math.abs(this.x - this.startX) > 150) {
                    this.state = 'wait'; this.waitTimer = 60;
                }
            } else if (this.state === 'wait') {
                this.waitTimer--;
                if (this.waitTimer <= 0) {
                    this.dir *= -1; this.vx = this.dir * 2; this.state = 'walk';
                }
            }
        }

        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            
            // Estética MECHA INDUSTRIAL
            const bob = Math.sin(this.timer * 0.3) * 2;
            const legRot = Math.sin(this.timer * 0.3) * 0.4;

            // Cuerpo Principal
            ctx.fillStyle = '#443a35'; // Metal oxidado oscuro
            ctx.fillRect(0, -5 + bob, 30, 25);
            
            // Detalle metálico (Highlight)
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            ctx.fillRect(0, -5 + bob, 30, 2);

            // Ojo/Sensor (Estilo HAL/Terminator)
            ctx.fillStyle = '#111';
            ctx.fillRect(10, 0 + bob, 14, 10);
            
            ctx.fillStyle = PALETTE.neonRed;
            ctx.shadowColor = PALETTE.neonRed; ctx.shadowBlur = 15;
            ctx.beginPath(); ctx.arc(17, 5 + bob, 3, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0;

            // Antena
            ctx.strokeStyle = '#888'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(5, -5+bob); ctx.lineTo(5, -15+bob); ctx.stroke();
            // Luz de antena (parpadea)
            if(Math.floor(Date.now() / 200) % 2 === 0) {
                ctx.fillStyle = '#f00'; ctx.fillRect(4, -16+bob, 2, 2);
            }

            // Piernas (Inverse Kinematics falsos con rotación)
            ctx.fillStyle = '#222';
            
            // Pata Izq
            ctx.save();
            ctx.translate(5, 20 + bob);
            ctx.rotate(legRot);
            ctx.fillRect(-3, 0, 6, 12); // Muslo
            ctx.fillRect(-5, 12, 12, 4); // Pie
            ctx.restore();

            // Pata Der
            ctx.save();
            ctx.translate(25, 20 + bob);
            ctx.rotate(-legRot);
            ctx.fillRect(-3, 0, 6, 12);
            ctx.fillRect(-5, 12, 12, 4);
            ctx.restore();

            ctx.restore();
        }
    }

    class MockFlyer {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 30; this.height = 20; 
            this.startX = x; this.timer = 0;
        }

        update() {
            this.timer++;
            this.x = this.startX + Math.sin(this.timer * 0.02) * 200;
            this.y += Math.cos(this.timer * 0.05) * 1.5; 
        }

        draw(ctx) {
            ctx.save();
            ctx.translate(this.x + 15, this.y + 10); // Centro
            
            // Inclinación por movimiento
            let lean = Math.cos(this.timer * 0.02) * 0.2;
            ctx.rotate(lean);

            // Estética DRONE "HUNTER KILLER"
            // Propulsores laterales
            const thrust = Math.random() * 5 + 5;
            
            // Gradiente para el chasis
            let grd = ctx.createLinearGradient(-15, -10, 15, 10);
            grd.addColorStop(0, '#556'); grd.addColorStop(1, '#223');
            ctx.fillStyle = grd;
            
            // Forma de diamante/avión
            ctx.beginPath();
            ctx.moveTo(0, 10); // Nariz
            ctx.lineTo(-15, -5); // Ala izq
            ctx.lineTo(0, -10); // Cola
            ctx.lineTo(15, -5); // Ala der
            ctx.closePath();
            ctx.fill();

            // Propulsores (Glow)
            ctx.globalCompositeOperation = 'lighter';
            ctx.fillStyle = '#00aaff';
            // Izq
            ctx.beginPath(); ctx.arc(-12, -2, 3, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.moveTo(-12, -2); ctx.lineTo(-15, thrust); ctx.lineTo(-9, thrust); ctx.fill();
            // Der
            ctx.beginPath(); ctx.arc(12, -2, 3, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.moveTo(12, -2); ctx.lineTo(9, thrust); ctx.lineTo(15, thrust); ctx.fill();
            
            ctx.globalCompositeOperation = 'source-over';

            // Luz de escaneo inferior
            ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
            ctx.beginPath();
            ctx.moveTo(0, 5);
            ctx.lineTo(-20, 80);
            ctx.lineTo(20, 80);
            ctx.fill();

            ctx.restore();
        }
    }

    // --- INSTANCIAS ---
    const player = new MockPlayer(200, 500);
    const walker = new MockWalker(800, 450); 
    const flyer = new MockFlyer(600, 200);

    const platforms = [
        { x: 0, y: 540, width: 800, height: 200, type: 'floor' }, 
        { x: 750, y: 490, width: 400, height: 20, type: 'platform' } 
    ];

    // --- BACKGROUND COMPLEX (5 LAYERS) ---
    // Generamos edificios proceduralmente para el fondo
    function createBuildingLayer(count, minW, maxW, minH, maxH, color) {
        let buildings = [];
        let currentX = 0;
        for(let i=0; i<count; i++) {
            let w = randomRange(minW, maxW);
            let h = randomRange(minH, maxH);
            let gap = randomRange(5, 50);
            buildings.push({ x: currentX, w: w, h: h, windows: Math.random() > 0.6 });
            currentX += w + gap;
        }
        return { items: buildings, width: currentX, color: color };
    }

    const layers = [
        { speed: 0.05, data: createBuildingLayer(20, 80, 200, 400, 600, '#0a0c10') }, // Muy lejos (Siluetas gigantes)
        { speed: 0.10, data: createBuildingLayer(25, 60, 150, 300, 500, '#11141a') }, 
        { speed: 0.25, data: createBuildingLayer(30, 50, 120, 200, 400, '#181e26') },
        { speed: 0.50, data: createBuildingLayer(20, 80, 200, 100, 300, '#202833') },
        { speed: 0.80, data: createBuildingLayer(15, 100, 300, 50, 150, '#2a3340') }  // Cerca
    ];

    function drawParallax(ctx, camX) {
        // Cielo Gradiente
        let skyGrad = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
        skyGrad.addColorStop(0, PALETTE.skyTop);
        skyGrad.addColorStop(1, PALETTE.skyBot);
        ctx.fillStyle = skyGrad;
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        // Relámpagos
        if (lightningIntensity > 0) {
            ctx.fillStyle = `rgba(200, 230, 255, ${lightningIntensity * 0.6})`;
            ctx.fillRect(0,0, GAME_WIDTH, GAME_HEIGHT);
            lightningIntensity *= 0.85; // Desvanecer
            if(lightningIntensity < 0.01) lightningIntensity = 0;
        }

        // Dibujar Capas
        layers.forEach((layer, index) => {
            let parallaxX = -(camX * layer.speed) % layer.data.width;
            
            ctx.fillStyle = layer.data.color;
            
            // Dibujamos dos veces para el loop infinito
            [parallaxX, parallaxX + layer.data.width].forEach(offsetX => {
                if (offsetX > GAME_WIDTH || offsetX + layer.data.width < 0) return; // Cull

                layer.data.items.forEach(b => {
                    let bx = offsetX + b.x;
                    let by = GAME_HEIGHT - b.h;
                    
                    // Edificio Base
                    ctx.fillRect(bx, by, b.w, b.h + 100);
                    
                    // Detalles de luces (Ventanas cyberpunk)
                    if (b.windows && index < 3) {
                        ctx.fillStyle = Math.random() > 0.95 ? PALETTE.neonCyan : '#1a2a3a'; // Flickering
                        for(let wy = by + 20; wy < GAME_HEIGHT; wy += 40) {
                            if(Math.random() > 0.3) ctx.fillRect(bx + 10, wy, 4, 8);
                            if(b.w > 40 && Math.random() > 0.3) ctx.fillRect(bx + b.w - 15, wy, 4, 8);
                        }
                        ctx.fillStyle = layer.data.color; // Reset
                    }
                    
                    // Luces de advertencia en las puntas (Rojo)
                    if (index === 0 && Math.random() > 0.98) {
                         ctx.fillStyle = '#f00'; ctx.fillRect(bx + b.w/2, by - 2, 2, 2); ctx.fillStyle = layer.data.color;
                    }
                });
            });
            
            // Niebla entre capas
            let fogH = 300 - (index * 40);
            let fogGrad = ctx.createLinearGradient(0, GAME_HEIGHT - fogH, 0, GAME_HEIGHT);
            fogGrad.addColorStop(0, 'rgba(5, 8, 10, 0)');
            fogGrad.addColorStop(1, `rgba(5, 8, 10, ${0.4 + (index * 0.1)})`);
            ctx.fillStyle = fogGrad;
            ctx.fillRect(0, GAME_HEIGHT - fogH, GAME_WIDTH, fogH);
        });
    }

    function drawIndustrialMap(ctx, cameraX) {
        platforms.forEach(p => {
            let px = p.x;
            let py = p.y;
            
            // --- PLATAFORMA ---
            // Cuerpo metálico oscuro
            ctx.fillStyle = '#111';
            ctx.fillRect(px, py, p.width, p.height);
            
            // Textura de rayas de precaución (Hazard stripes)
            if (p.type === 'floor') {
                ctx.fillStyle = '#1a1a1a';
                for(let i = 0; i < p.width; i+=40) {
                    ctx.fillRect(px + i, py, 20, p.height);
                }
            } else {
                // Para la plataforma flotante: Rayas amarillas abajo
                ctx.fillStyle = '#b8860b';
                ctx.beginPath();
                for(let i=0; i<p.width; i+=40) {
                    ctx.moveTo(px + i, py + p.height);
                    ctx.lineTo(px + i + 10, py + p.height);
                    ctx.lineTo(px + i + 20, py + p.height - 10);
                    ctx.lineTo(px + i + 10, py + p.height - 10);
                }
                ctx.fill();
            }

            // Borde superior (Rejilla)
            ctx.fillStyle = '#444';
            ctx.fillRect(px, py, p.width, 6);
            ctx.fillStyle = '#000';
            for(let i=0; i<p.width; i+=10) ctx.fillRect(px + i, py, 2, 6);
            
            // Linea neón debajo del borde
            ctx.fillStyle = PALETTE.neonCyan;
            ctx.globalAlpha = 0.3;
            ctx.fillRect(px, py + 6, p.width, 2);
            ctx.globalAlpha = 1.0;
        });
    }

    // --- LOOP PRINCIPAL ---
    let camera = { x: 0, y: 0 };
    
    function loop() {
        frameCount++;
        
        // Control de clima
        if(frameCount % lightningTimer === 0) {
            lightningIntensity = 1.0;
            lightningTimer = Math.floor(randomRange(200, 600));
        }

        // Cámara automática
        camera.x = frameCount * 1.5; // Scroll constante
        
        // Update Entidades
        player.update();
        walker.update();
        flyer.update();

        // --- RENDER ---
        ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        
        // 1. Fondo Parallax
        drawParallax(ctx, camera.x);
        
        // 2. Escenario y Entidades (Sistema de Camara)
        ctx.save();
        
        // Simulación visual: Mantenemos el escenario centrado pero movemos el fondo
        // Para que se vea el movimiento, desplazamos las plataformas en contra del scroll pero las loopeamos
        // NOTA: Para este test visual, vamos a fijar las plataformas en pantalla y solo simular que el fondo se mueve rapido
        // para dar sensación de velocidad, pero dejaremos al jugador estatico en X relativa.
        
        // Dibujar Mapa
        // Hacemos un offset visual falso para los objetos para que parezca que están en el lugar, 
        // pero en realidad están fijos en coordenadas de pantalla para el test.
        drawIndustrialMap(ctx, camera.x);

        // Dibujar Entidades
        player.draw(ctx);
        walker.draw(ctx);
        flyer.draw(ctx);
        
        ctx.restore();

        // 3. Clima (Lluvia por encima de todo)
        ctx.strokeStyle = PALETTE.rain;
        ctx.lineWidth = 1;
        ctx.beginPath();
        rainDrops.forEach(d => {
            d.y += d.v;
            d.x -= 2; // Viento
            if (d.y > GAME_HEIGHT) { d.y = -10; d.x = Math.random() * GAME_WIDTH; }
            if (d.x < 0) d.x = GAME_WIDTH;
            
            ctx.moveTo(d.x, d.y);
            ctx.lineTo(d.x - 1, d.y + d.l);
        });
        ctx.stroke();

        requestAnimationFrame(loop);
    }

    loop();

</script>
</body>
</html>